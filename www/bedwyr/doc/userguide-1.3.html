<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd"> 
<HTML> 
<HEAD> 
<TITLE>A User Guide to Bedwyr v1.3
 
 
</TITLE> 
 
<META http-equiv="Content-Type" content="text/html; charset=US-ASCII"> 
<META name="GENERATOR" content="hevea 1.10"> 
<STYLE type="text/css"> 
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
</STYLE> 
<LINK REL=STYLESHEET type="text/css" HREF="http://slimmer.gforge.inria.fr/bedwyr/bd.css"> 
</HEAD> 
<BODY > 
<!--HEVEA command line is: /usr/bin/hevea -noiso userguide-1.3 --> 
<!--CUT DEF section 1 --><TABLE CLASS="title"><TR><TD><H1 CLASS="titlemain"><FONT SIZE=7>A User Guide to Bedwyr v1.3</FONT> 
<SUP><A NAME="text1" HREF="#note1">*</A></SUP> 
</H1><H3 CLASS="titlerest">David Baelde<SUP>1</SUP>,
Andrew Gacek<SUP>2</SUP>,
Quentin Heath<SUP>3</SUP>,<BR> 
 Dale Miller<SUP>3</SUP>,
Gopalan Nadathur<SUP>4</SUP>,
Alwen Tiu<SUP>5</SUP><BR><BR> 
<SUP>1</SUP>ITU, Copenhagen<BR> 
<SUP>2</SUP>Rockwell Collins<BR> 
<SUP>3</SUP>INRIA Saclay and LIX/&#XC9;cole Polytechnique<BR> 
<SUP>4</SUP>University of Minnesota<BR> 
<SUP>5</SUP>Australian National University
</H3></TD></TR> 
</TABLE><!--TOC section Contents--> 
<H2 CLASS="section"><!--SEC ANCHOR -->Contents</H2><!--SEC END --><!--TOC section Overview--> 
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc1">1</A>&#XA0;&#XA0;Overview</H2><!--SEC END --><P>Some recent theoretical work in proof search has illustrated that it
is possible to combine the following two computational principles into
one computational logic:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"> 
a symmetric treatment of finite success and finite failure.
This allows capturing both aspects of may and must behavior in
operational semantics and mixing model checking and logic programming.</LI><LI CLASS="li-enumerate">direct support for &#X3BB;-tree syntax, as in &#X3BB;Prolog,
via term-level &#X3BB;-binders, higher-order pattern
unification, and the &#X2207;-quantifier.
</LI></OL><P> 
All these features have a clean proof theory. The combination of
these features allow, for example, specifying rather declarative
approaches to model checking syntactic expressions containing
bindings. The Bedwyr system is intended as an implementation of these
computational logic principles.</P><!--TOC paragraph Why the name Bedwyr?--> 
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Why the name Bedwyr?</H5><!--SEC END --><P> 
In the legend of King Arthur and the round table, several knights
shared in the search for the holy grail. The name of one of them,
Parsifal, is used for an INRIA team where Bedwyr is currently
developed. Bedwyr was another one of those knights. Wikipedia (using
the spelling &#X201C;Bedivere&#X201D;) mentions that Bedwyr appears in <EM>Monty
Python and the Holy Grail</EM> where he is &#X201C;portrayed as a master of the
extremely odd logic in the ancient times, whom occasionally blunders."
Bedwyr is a re-implementation and rethinking of an earlier system
called Level 0/1 written by Alwen Tiu and described in
[<A HREF="#tiu05eshol">TNM05</A>]. It was an initial offering from &#X201C;Slimmer&#X201D;, a
jointly funded effort between INRIA and the University of Minnesota on
&#X201C;Sophisticated logic implementations for modeling and mechanical
reasoning&#X201D; from 2005 to 2010. For more information, see
 
<A HREF="http://slimmer.gforge.inria.fr/"><TT><TT>http://slimmer.gforge.inria.fr/</TT></TT></A>.</P><!--TOC paragraph What is the difference between <EM>hoas</EM> and &#X3BB;<EM>-tree syntax</EM>?--> 
<H5 CLASS="paragraph"><!--SEC ANCHOR -->What is the difference between <EM>hoas</EM> and &#X3BB;<EM>-tree syntax</EM>?</H5><!--SEC END --><P> 
The term &#X201C;higher-order abstract syntax&#X201D; (hoas) was originally coined
by Pfenning and Elliott in [<A HREF="#pfenning88pldi">PE88</A>] and names the general
practice (that was common then in, say, &#X3BB;Prolog
[<A HREF="#miller87slp">MN87</A>]) of using an abstraction in a programming or
specification language to encode binders in an object-language. Since
the choice of &#X201C;meta-language&#X201D; can vary a great deal, the term
&#X201C;hoas&#X201D; has come to mean different things to different people. When
hoas is used directly within functional programming or constructive
type systems, syntax with bindings contains functional objects, which
make rich syntactic manipulations difficult. Bedwyr, on the other
hand, follows the <EM>&#X3BB;</EM><EM>-tree</EM> approach [<A HREF="#miller00cl">Mil00</A>] to
hoas: in particular, Bedwyr&#X2019;s use of &#X3BB;-abstraction is meant to
provide an abstract form of syntax in which only the names of bindings
are hidden: the rest of the structure of syntactic expressions
remains.</P><!--TOC paragraph Is Bedwyr efficient?--> 
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Is Bedwyr efficient?</H5><!--SEC END --><P> 
Some care has been taken to implement the novel logical principles
that appear in Bedwyr. In particular, the system makes extensive use
of the implementation of the suspension calculus [<A HREF="#nadathur99jflp">Nad99</A>]
and other implementation ideas developed within the Teyjus
[<A HREF="#nadathur99cade">NM99</A>] implementation of &#X3BB;Prolog [<A HREF="#nadathur88iclp">NM88</A>].
Aspects of tabled deduction have also been added to the system
[<A HREF="#ramakrishna97cav">RRR<SUP>+</SUP>97</A>, <A HREF="#pientka05cade">Pie05</A>]. We have found that Bedwyr&#X2019;s
performance is good enough to explore a number of interesting
examples. It is not likely, however, that the current implementation
will support large examples. For example, the system implements the
occur-check within logic: this is, of course, necessary for sound
deduction but it does slow unification a lot. For example, the append
program is quadratic in the size of its first argument. There are a
number of well-known improvements to unification that make it possible
to remove many instances of the occur-check (and making append
linear). As of this time, such an improvement has not been added to
Bedwyr.</P><!--TOC paragraph An open source effort: Can I help?--> 
<H5 CLASS="paragraph"><!--SEC ANCHOR -->An open source effort: Can I help?</H5><!--SEC END --><P> 
The Bedwyr system was conceived as a prototype that could help
validate certain proof theory and proof search topic. In the end,
this prototype has illustrated the main principles that we hoped that
it would. It has also pointed out a number of new topics to be
explored. If you are interested in contributing examples, features,
or performance enhancements, or if you are interested in considering
the next generation of a system like this, please let an author of
this guide know: we are looking for contributions.</P><!--TOC paragraph Background assumed--> 
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Background assumed</H5><!--SEC END --><P> 
To read this guide, we shall assume that the reader is familiar with
the implementation of proof search that is found in, say, Prolog,
&#X3BB;Prolog, or Twelf. While familiarity with various foundations-oriented
papers (particularly,
[<A HREF="#mcdowell03tcs">MMP03</A>, <A HREF="#miller05tocl">MT05</A>, <A HREF="#tiu04phd">Tiu04</A>, <A HREF="#baelde08lfmtp">Bae08b</A>, <A HREF="#tiu10tocl">TM10</A>]) is
important for understanding fully this system, much can be learned
from studying the examples provided in the distribution.</P><!--TOC section Get Bedwyr--> 
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">2</A>&#XA0;&#XA0;Get Bedwyr</H2><!--SEC END --><P>Different means of getting Bedwyr are listed on Slimmer&#X2019;s INRIA Gforge
project site:
 
<A HREF="http://slimmer.gforge.inria.fr/bedwyr/#download"><TT><TT>http://slimmer.gforge.inria.fr/bedwyr/#download</TT></TT></A>.
You can either download tarballs, get any development version using SVN,
or use Slimmer&#X2019;s unofficial Apt repository | instructions are provided
on the project page.
The development of Bedwyr is meant to be an open source project.
If you are keen to work on the source code and/or examples, please contact
one of the &#X201C;Project Admins&#X201D; of the project (as listed at
 
<A HREF="https://gforge.inria.fr/projects/slimmer/"><TT><TT>https://gforge.inria.fr/projects/slimmer/</TT></TT></A>.</P><!--TOC subsection Distribution layout--> 
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc3">2.1</A>&#XA0;&#XA0;Distribution layout</H3><!--SEC END --><P>The Bedwyr distribution is organized as follows:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <TT>src/</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>Source code</TD></TR> 
<TR><TD ALIGN=right NOWRAP> <TT>doc/</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>Documentation | you&#X2019;re reading it</TD></TR> 
<TR><TD ALIGN=right NOWRAP> <TT>contrib/</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>Emacs and Vim support</TD></TR> 
<TR><TD ALIGN=right NOWRAP> <TT>examples/</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>Examples | reading them helps</TD></TR> 
</TABLE><!--TOC subsection Build--> 
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc4">2.2</A>&#XA0;&#XA0;Build</H3><!--SEC END --><P>Bedwyr&#X2019;s main build dependency is the OCaml compiler suite.
You also need some standard tools you may already have, especially
autoconf and GNU make (part of the GNU toolchain),
and bash, tar, gzip and bzip2 for the installation.</P><P>Then, the procedure is quite simple.</P><PRE CLASS="verbatim"> $ autoconf
 $ ./configure
 $ make
</PRE><P>You&#X2019;ll get the bedwyr executable in <TT>src/bedwyr</TT>.</P><P>By default, Bedwyr is built using the native-code compiler <TT>ocamlopt</TT>,
since it is much faster. If you don&#X2019;t have it or don&#X2019;t want it (e.g.
for easier debugging) use <TT>./configure --disable-nativecode</TT>.</P><P>You can also enable the documentation generation by using
<TT>./configure --enable-doc</TT> and <TT>make doc</TT>. This userguide
and the ocamldoc documentation will be generated in <TT>doc/</TT>.</P><!--TOC subsection Test--> 
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc5">2.3</A>&#XA0;&#XA0;Test</H3><!--SEC END --><P>Testing the core library (should be instantaneous):
</P><PRE CLASS="verbatim"> $ make -C src/ndcore test
</PRE><P>Same test, then running <TT>bedwyr</TT> on some examples (may take up to
one minute):
</P><PRE CLASS="verbatim"> $ make test
</PRE><!--TOC section User interface--> 
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc6">3</A>&#XA0;&#XA0;User interface</H2><!--SEC END --><P>When you run Bedwyr, you specify a file or collection of files for it to
load; the objects declared and defined in those files will be loaded in
the corresponding order. You can then use the interactive toplevel to
ask queries against those definitions, or call meta-commands.
Those queries and commands can also be specified on the command-line via
the option <CODE>-e</CODE> (e.g.
<TT>bedwyr -e &#X2019;X = 0.&#X2019; -e &#X2019;#typeof X = 1.&#X2019;</TT>), in which case they are
processed in the order they are given, after the files and before the
toplevel.</P><!--TOC subsection Definition files--> 
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc7">3.1</A>&#XA0;&#XA0;Definition files</H3><!--SEC END --><P>Definition files are usually named with a <CODE>.def</CODE> extension. You can
find several of them in the <CODE>examples</CODE> directory of the Bedwyr
distribution. They contain definitions, meta-commands, and declarations
for the types (<TT><I>Kind</I></TT>&#XA0;<I>id</I>&#XA0;<TT><I>type</I>.</TT>) and the constants (<TT><I>Type</I></TT>&#XA0;<I>id</I>&#XA0;<I>type</I><TT>.</TT>) that are not predefined. Definitions are given
as blocks with a header containing declarations and an optional body
containing a set of clauses, in which uppercase variables are implicitly
universally quantified:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>&#XA0;&#XA0;<I>def</I>_<I>block</I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><TT><I>Define</I></TT>&#XA0;<I>declarations</I><TT>.</TT>&#XA0;</TD></TR> 
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><TT><I>Define</I></TT>&#XA0;<I>declarations</I>&#XA0;<TT><I>by</I></TT>&#XA0;
<I>definitions</I><TT>.</TT>&#XA0;</TD></TR> 
<TR><TD ALIGN=right NOWRAP>&#XA0;&#XA0;<I>declarations</I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><I>decl</I>&#XA0;<TT>,</TT>&#XA0;<I>declarations</I>&#XA0;</TD></TR> 
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I>decl</I></TD></TR> 
<TR><TD ALIGN=right NOWRAP>&#XA0;&#XA0;<I>decl</I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><I>flavour</I>&#XA0;<I>id</I>&#XA0;<TT>:</TT>&#XA0;<I>type</I>&#XA0;</TD></TR> 
<TR><TD ALIGN=right NOWRAP>&#XA0;&#XA0;<I>flavour</I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><I>inductive</I>&#XA0;|&#XA0;<I>coinductive</I>&#XA0;|</TD></TR> 
<TR><TD ALIGN=right NOWRAP>&#XA0;&#XA0;<I>definitions</I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><I>clause</I>&#XA0;<TT>;</TT>&#XA0;<I>definitions</I>&#XA0;</TD></TR> 
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I>clause</I></TD></TR> 
<TR><TD ALIGN=right NOWRAP>&#XA0;&#XA0;<I>clause</I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><I>id</I>&#XA0;<I>atom</I>*&#XA0;<TT>:=</TT>&#XA0;<I>formula</I>&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I>id</I>&#XA0;<I>atom</I>*&#XA0;</TD></TR> 
</TABLE></TD></TR> 
</TABLE><P>A predicate with an empty definition is always false;
the head of a bodiless clause is always true.
A predicate can only depend on predicates defined up to its definition
block, so multiple predicates in one block is the only way to achieve
mutual recursion.</P><P>The only meta-command that is really intended for definition files is the
include command:
</P><PRE CLASS="verbatim">#include "another/file.def".</PRE><P>The <CODE>#include</CODE> can really be seen as the inclusion of another file,
as Bedwyr doesn&#X2019;t have any namespace or module system.</P><!--TOC subsubsection Emacs mode--> 
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc8">3.1.1</A>&#XA0;&#XA0;Emacs mode</H4><!--SEC END --><P>Assuming Bedwyr is installed in standard Linux system folders, you can
use the Emacs mode for Bedwyr by adding these two lines to your
<TT>~/.emacs</TT> file:
</P><PRE CLASS="verbatim">(load "/usr/share/bedwyr/contrib/emacs/bedwyr.el")
(setq bedwyr-program "/usr/bin/bedwyr")
;; Of course you can change both locations to wherever you want.
</PRE><P>Then you should be able to load any <CODE>.def</CODE> file
and have syntax highlighting and some rough auto-indenting.
Also if you do <CODE>C-c C-c</CODE> it will start Bedwyr
and load the current file you are working on.</P><!--TOC subsubsection Vim syntax highlighting--> 
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc9">3.1.2</A>&#XA0;&#XA0;Vim syntax highlighting</H4><!--SEC END --><P>There is also a basic syntax highlighting file for vim. With a standard
system installation, the files
<CODE>/usr/share/vim/vimfiles/[ftdetect|syntax]/bedwyr.vim</CODE> should
suffice; otherwise do the following:
</P><UL CLASS="itemize"><LI CLASS="li-itemize"> 
copy <TT>contrib/vim/syntax/bedwyr.vim</TT> to
your <TT>~/.vim/syntax/</TT> directory to make it available
</LI><LI CLASS="li-itemize">copy <TT>contrib/vim/ftdetect/bedwyr.vim</TT> to
your <TT>~/.vim/ftdetect/</TT> directory to have it used automatically
for all <TT>*.def</TT> files
</LI></UL><!--TOC subsection Toplevel--> 
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc10">3.2</A>&#XA0;&#XA0;Toplevel</H3><!--SEC END --><P>The interactive toplevel is automatically loaded once the files have
been parsed, unless the flag <CODE>-I</CODE> is passed to Bedwyr. You can
either query a formula, or run a command. In queries, free and bound
variables are
the only objects that can be used without prior declaration, and their
instantiations in solutions are displayed.</P><P>In the following example we load a set of definitions and prove that
the untyped &#X3BB;-term &#X3BB; <I>x</I>.<I>x</I>&#XA0;<I>x</I> has no simple type.</P><PRE CLASS="verbatim"> $ src/bedwyr examples/lambda.def
[...welcome message...]
?= (exists T, wt nil (abs x\ app x x) T) -&gt; false.
Yes.
More [y] ?
No more solutions.
?=
</PRE><P>Notice that we had to use the term <CODE>(abs x\ app x x)</CODE> instead of
<CODE>(x1\ x1 x1)</CODE>: the former encodes the untyped &#X3BB;-term
&#X3BB; <I>x</I> (<I>x</I> <I>x</I>) by mapping
object-level abstraction to <TT>abs</TT> and object-level application to
<TT>app</TT>, while the latter is not a legal term in Bedwyr. (Prior to
version 1.3, Bedwyr did not use simple typing on its own terms.)</P><P>Most of the errors that can stop the reading of a file (parsing or
typing error, undeclared object, etc) are correctly caught by the
toplevel, though the line number reported for the error is often not
useful.</P><!--TOC subsubsection Line editing--> 
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc11">3.2.1</A>&#XA0;&#XA0;Line editing</H4><!--SEC END --><P>Bedwyr has no line editing facilities at all. Thus, we recommend using
<TT>ledit</TT> or <TT>rlwrap</TT>, which provides such features. Get one
of them from your usual package manager or at
<A HREF="http://pauillac.inria.fr/~ddr/ledit/"><TT><TT>http://pauillac.inria.fr/~ddr/ledit/</TT></TT></A> 
or 
<A HREF="http://utopia.knoware.nl/~hlub/uck/rlwrap/"><TT><TT>http://utopia.knoware.nl/~hlub/uck/rlwrap/</TT></TT></A>.</P><P>Then you can simply run <CODE>ledit src/bedwyr</CODE>. One can also define
an alias in his <TT>~/.bashrc</TT>, such as the following which also
makes use of <TT>~/.bedwyr_history</TT> to remember history from one session to
another:<BR> 
<CODE>alias bedwyr="ledit -h </CODE><TT>~/.bedwyr_history</TT><CODE> -x /path/to/bedwyr"</CODE>.</P><!--TOC subsection Meta-commands--> 
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc12">3.3</A>&#XA0;&#XA0;Meta-commands</H3><!--SEC END --><!--TOC subsubsection Session management--> 
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc13">3.3.1</A>&#XA0;&#XA0;Session management</H4><!--SEC END --><P>Those commands alter the internal set of definitions of Bedwyr:
</P><UL CLASS="itemize"><LI CLASS="li-itemize"> 
<CODE>#include</CODE> is meant to be used in <CODE>.def</CODE> files.
</LI><LI CLASS="li-itemize"><CODE>#session</CODE> is a better <CODE>#include</CODE> meant for query mode.
It accepts any number of filenames as parameters, and this set of files
will be remembered as the current <EM>session</EM>.
When you pass filenames on Bedwyr&#X2019;s command line,
it is equivalent to call <CODE>#session</CODE> with these definition files.
</LI><LI CLASS="li-itemize"><CODE>#reload</CODE> clears all the definitions,
and then reloads all the session&#X2019;s files. It is useful if they have
been changed.
</LI><LI CLASS="li-itemize"><CODE>#reset</CODE> clears all the definitions and empties the session.
</LI></UL><!--TOC subsubsection Assertions--> 
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc14">3.3.2</A>&#XA0;&#XA0;Assertions</H4><!--SEC END --><P>Three kinds of assertions can be used in definition files.
These tests are not executed unless the <CODE>-t</CODE> flag has been passed
on Bedwyr&#X2019;s command-line, in which case any assertion failure is fatal.
</P><UL CLASS="itemize"><LI CLASS="li-itemize"> 
<CODE>#assert F</CODE> checks that the formula <I>F</I> has at least one solution.
</LI><LI CLASS="li-itemize"><CODE>#assert_not F</CODE> checks that <I>F</I> has no solution.
</LI><LI CLASS="li-itemize"><CODE>#assert_raise F</CODE> checks that the proof-search for <I>F</I> triggers
a runtime error.
</LI></UL><P>Our examples include a lot of assertions, to make sure that definitions have
(and keep) the intended meaning. These assertions are also the basis of
Bedwyr&#X2019;s correctness and performance tests ran using <CODE>make test</CODE>.</P><!--TOC subsubsection Other commands--> 
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc15">3.3.3</A>&#XA0;&#XA0;Other commands</H4><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize"> 
Tabling
<UL CLASS="itemize"><LI CLASS="li-itemize"> 
<CODE>#equivariant on</CODE> sets an alternative tabling mode
</LI><LI CLASS="li-itemize"><CODE>#clear_table p</CODE> clears the results cached for a
predicate
</LI><LI CLASS="li-itemize"><CODE>#clear_tables</CODE> clears all cached results
</LI></UL></LI><LI CLASS="li-itemize">Output
<UL CLASS="itemize"><LI CLASS="li-itemize"> 
<CODE>#debug on</CODE> adds a lot of output to the proof search
</LI><LI CLASS="li-itemize"><CODE>#time on</CODE> displays computation times between results
</LI><LI CLASS="li-itemize"><CODE>#env</CODE> lists all declared objects with their kind or
type
</LI><LI CLASS="li-itemize"><CODE>#typeof F</CODE> type-checks a formula, and also displays
the type of its free variables
</LI><LI CLASS="li-itemize"><CODE>#show_table p</CODE> prints the table of a predicate
</LI><LI CLASS="li-itemize"><CODE>#save_table p "file.def"</CODE> outputs the table of a
predicate in a Bedwyr-compatible format
</LI></UL></LI><LI CLASS="li-itemize">General purpose
<UL CLASS="itemize"><LI CLASS="li-itemize"> 
<CODE>#help</CODE> 
</LI><LI CLASS="li-itemize"><CODE>#exit</CODE> 
</LI></UL> 
</LI></UL><!--TOC section The logic behind Bedwyr--> 
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc16">4</A>&#XA0;&#XA0;The logic behind Bedwyr</H2><!--SEC END --><P> 
<A NAME="logic"></A></P><P>The logic behind Bedwyr, named LINC, is an extension to a higher-order
version of intuitionistic logic that has been developed over the past
few years. The acronym LINC, which stands for &#X201C;lambda, induction,
nabla, and co-induction&#X201D;, lists the main novel components of the
logic. In particular, &#X3BB;-terms are supported directly (and,
hence, the &#X3BB;-tree syntax approach to higher-order abstract
syntax is supported [<A HREF="#miller00cl">Mil00</A>]). Induction and co-induction
are also available. The nabla &#X2207; quantifier has been added to
this logic in order to increase the expressiveness of programs using
&#X3BB;-tree syntax in negated situations. The proof theory of LINC
is given in [<A HREF="#miller05tocl">MT05</A>, <A HREF="#tiu04phd">Tiu04</A>]. Since this earlier work on
LINC, more recent work on the logic <FONT COLOR=red><I>G</I></FONT> 
[<A HREF="#gacek.twolevel">GMN10</A>, <A HREF="#gacek11ic">GMN11</A>] and with fixed points in linear logic
[<A HREF="#baelde08phd">Bae08a</A>, <A HREF="#baelde12tocl">Bae12</A>] has further improved our understanding
of using fixed points, induction, co-induction, and
&#X2207;-quantification.</P><P>Below we provide a high-level overview of the logical aspects of Bedwyr.
More explicit information on this system can be found in
[<A HREF="#tiu05eshol">TNM05</A>]: n.b., the name &#X201C;Level 0/1&#X201D; in that paper has now
been replaced by Bedwyr.</P><!--TOC subsection Built-in treatment of bindings-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc17">4.1</A>&#XA0;&#XA0;Built-in treatment of bindings</H3><!--SEC END --><P>Bedwyr treats &#X3BB;-abstractions within terms as primitive as well
as allowing for variables of function type and quantifiers within
formulas (&#X2200;, &#X2203;, &#X2207;). The system
implements &#X201C;higher-order pattern unification&#X201D; (also called
<I>L</I><SUB>&#X3BB;</SUB>-unification) [<A HREF="#miller91jlc">Mil91</A>]. This kind of unification
appears to be the weakest extension to first-order unification that
treats bindings as a primitive. A number of automated deduction systems
implement this kind of unification (e.g., Twelf, Teyjus, Coq, and
Minlog). Full &#X3B2;-conversion is implemented by Bedwyr as well.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV> 
<PRE CLASS="verbatim">% The predicate a holds for 3, 5, and 2.
a (s (s (s z))).
a (s (s (s (s (s z))))).
a (s (s z)).
 
% The less-than-or-equal relation
leq z N.
leq (s N) (s M) :- leq N M.
 
% Compute the maximum of a
maxa N :- a N, pi x\ a x =&gt; leq x N.
</PRE><DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 1: Computing the maximum of a defined predicate (&#X3BB;Prolog).</TD></TR> 
</TABLE></DIV> 
<A NAME="maxa-lp"></A> 
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC subsection Syntax and semantics of definitions--> 
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc18">4.2</A>&#XA0;&#XA0;Syntax and semantics of definitions</H3><!--SEC END --><P>Some systems implementing aspects of higher-order logic programming,
such as &#X3BB;Prolog, accept the &#X201C;open-world assumption&#X201D;: any conclusion
drawn in their logic will hold in any extension of the underlying logic
programming language.
For example, consider the &#X3BB;Prolog program in Figure&#XA0;<A HREF="#maxa-lp">1</A> (the
signature has been left out), where the last clause has an implication
<CODE>=&gt;</CODE> in the goal. During proof search, this implication
causes &#X3BB;Prolog to add a new eigenvariable, say <CODE>c</CODE>, to the runtime
signature
and to extend the current program with an atomic fact about it:
<CODE>(a c)</CODE>. In such a new world, however, the <TT>leq</TT> relation
does not have any information about this &#X201C;non-standard&#X201D; number
<TT>c</TT>.
Bedwyr on the contrary accepts the &#X201C;closed-world assumption&#X201D;: the
notion of programs is replaced by <EM>definitions</EM> that capture the
&#X201C;if-and-only-if&#X201D; closure of logic programs. In the corresponding
(excerpt from a) program in Figure&#XA0;<A HREF="#maxa-bdw">2</A>, Bedwyr takes the
assumption <CODE>(a c)</CODE> and asks &#X201C;Given the assumption that
<CODE>(a c)</CODE> is true, how could have it been proved?&#X201D; The natural
answer to this is that that assumption could have been proved if
<CODE>c</CODE> was either 3 or 5 or 2. Thus, this will cause a case analysis:
in particular, the query <CODE>(maxa N)</CODE> will cause the following goals
to be considered:
</P><DIV CLASS="center"> 
<TT>(a N)&#XA0;&#XA0;&#XA0;&#XA0;(leq 3 N)&#XA0;&#XA0;&#XA0;&#XA0;(leq 5 N)&#XA0;&#XA0;&#XA0;&#XA0;(leq 2 N)
</TT></DIV><P> 
Here we use the numeric symbols &#X2018;2&#X2019;, &#X2018;3&#X2019;, etc., as abbreviations of the
corresponding terms formed using <TT>z</TT> and <TT>s</TT>. The usual
approach to unification and depth-first proof search will now produce
the proper maximum value. This change allows Bedwyr to give a
computational interpretation to finite failure and to do deduction that
encodes model checking.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV> 
<PRE CLASS="verbatim">Define a : int -&gt; prop by
  a (s (s (s z)));
  a (s (s (s (s (s z)))));
  a (s (s z)).
 
Define leq : int -&gt; int -&gt; prop by
  leq z N;
  leq (s N) (s M) := leq N M.
 
Define maxa : int -&gt; prop by
  maxa N := a N, forall  x, a x -&gt; leq x N.
</PRE><DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 2: Computing the maximum of a defined predicate (Bedwyr).</TD></TR> 
</TABLE></DIV> 
<A NAME="maxa-bdw"></A> 
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P><BR> 
<BR> 
There are two orthogonal extensions to higher-order intuitionistic
logic that have been incorporated into Bedwyr. We describe them next.</P><!--TOC subsection Symmetry of finite success and finite failure--> 
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc19">4.3</A>&#XA0;&#XA0;Symmetry of finite success and finite failure</H3><!--SEC END --><P>The underlying logic of <EM>fixed points</EM> (also known as <EM>definitions</EM>)
[<A HREF="#girard92mail">Gir92</A>, <A HREF="#schroeder-Heister93lics">SH93</A>, <A HREF="#mcdowell03tcs">MMP03</A>, <A HREF="#momigliano03types">MT03</A>]
contains an inference rule that allows for failure in unification
(and, hence, in simple proof search) to be turned into a success.
Thus, simple forms of &#X201C;negation-as-failure&#X201D; can be naturally
captured in Bedwyr and the underlying logic. It is also possible to
describe both <EM>may</EM> and <EM>must</EM> behaviors in process calculi.
For example, not only can one code reachability in process calculus
but bisimulation is also possible. One way to view this enhancement
to proof search is the following: Let <I>A</I> and <I>B</I> be two atomic
formulas. Then, finite success is captured by proving the sequent
&#X2014;&#X2192; <I>A</I>, finite failure is captured by proving the sequent
<I>A</I>&#X2014;&#X2192;, and simulation is captured by proving the sequent
<I>A</I>&#X2014;&#X2192; <I>B</I>.</P><!--TOC subsection The &#X2207; quantifier--> 
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc20">4.4</A>&#XA0;&#XA0;The &#X2207; quantifier</H3><!--SEC END --><P>In order to treat specifications using &#X3BB;-tree syntax
properly, it appears that a new quantifier, called &#X2207;, is
necessary. If finite success is all that is needed, the &#X2207; can
be replaced with the universal quantifier. When finite failure is
involved, however, the &#X2207; quantifier plays an independent role.
See [<A HREF="#miller05tocl">MT05</A>, <A HREF="#tiu04phd">Tiu04</A>, <A HREF="#tiu05concur">Tiu05</A>] for more on this
quantifier. It is worth pointing out that we know of no examples
involving &#X2207; that do not also involve &#X3BB;-tree syntax.</P><!--TOC section How Bedwyr works--> 
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc21">5</A>&#XA0;&#XA0;How Bedwyr works</H2><!--SEC END --><P> 
<A NAME="sec:howto"></A></P><P>A better understanding of the tool is probably needed to get your work
done.</P><!--TOC subsection Proof search within LINC--> 
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc22">5.1</A>&#XA0;&#XA0;Proof search within LINC</H3><!--SEC END --><P> 
<A NAME="psearch"></A></P><P>Bedwyr is a proof-search engine for a small fragment of the LINC
logic. In principle, Bedwyr uses two provers. <EM>Prover 1</EM> is similar to
the depth-first interpreter used in &#X3BB;Prolog. The main
difference is in the proof of an implication.
To prove an implication <I>A</I>&#X21D2; <I>B</I>, prover 1 calls <EM>prover 0</EM> 
to enumerate all possible solutions
{&#X3B8;<SUB><I>i</I></SUB>&#XA0;|&#XA0;<I>i</I>=1,&#X2026;,<I>n</I>} for <I>A</I>,
and then prover 1 tries to prove <I>B</I>&#X3B8;<SUB>1</SUB>&#X2227;&#X2026;&#X2227; <I>B</I>&#X3B8;<SUB><I>n</I></SUB>.
If <I>A</I> has no solution (that is, if <I>n</I>=0), the implication is true.
The substitutions generated by prover 1 are for existential<SUP><A NAME="text2" HREF="#note2">1</A></SUP> 
variables, as usual in logic programming.
On the other hand, the substitutions generated by prover 0 are for
universal variables.</P><P>To illustrate this,
consider the following goal:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X2200;&#XA0;<I>x</I>&#XA0;&#XA0;&#XA0;.&#XA0;&#XA0;&#XA0;(&#X2203;&#XA0;<I>y</I>&#XA0;&#XA0;&#XA0;.&#XA0;&#XA0;&#XA0;<I>x</I>=<I>s</I>&#XA0;<I>y</I>)&#XA0;&#X21D2;&#XA0;<I>x</I>=0&#XA0;&#X21D2;&#XA0;<I>false</I>&#XA0;</TD></TR> 
</TABLE><P> 
(This formula formalizes the fact that if <I>x</I> is the successor of some
number then <I>x</I> is not zero.)
Bedwyr will call prover 1 on it. The prover introduces a universal variable
and reaches the first implication.
It then calls prover 0 on (&#X2203; <I>y</I> &#XA0; . &#XA0; <I>x</I> = <I>s</I>&#XA0;<I>y</I>).
Prover 0 introduces an existential variable <I>y</I>,
and the unification instantiates <I>x</I> to get the only solution.
Back to prover 1, we have to prove (<I>s</I>&#XA0;<I>y</I> = 0 &#X21D2; <I>false</I>)
where <I>y</I> is still an existential variable. Prover 0 is given <I>s</I>&#XA0;<I>y</I>=0
to prove and fails to do so: that failure is a success for prover 1.</P><P>We&#X2019;ve seen in Section <A HREF="#logic">4</A> with the <CODE>maxa</CODE> example
(Figure&#XA0;<A HREF="#maxa-bdw">2</A>) how this treatment of the implication allows
Bedwyr to check formulas which are not provable in traditional (pure) logic
programming languages such as &#X3BB;Prolog.
As often, this novelty has a price. The systematic enumeration leads to
infinite search for simple formulas like (<I>A</I> &#X21D2; <I>A</I>) as soon as
<I>A</I> does not have a finite number of solutions.
Further development of Bedwyr may provide
real support for induction and co-induction.</P><P>Prover 0 is similar to prover 1.
The first difference is this dual treatment of variables;
soundness requires another one.
Because it needs to completely destruct formulas in order to enumerate
solutions, prover 0 requires its connectives to be <EM>asynchronous</EM> on the
left: they can be immediately destructed (introduced, in sequent
calculus terminology) without restricting provability.
This means that implication and universal quantification are forbidden on the
left of implications.</P><P>Prover 1 instantiates existential variables, and considers universal variables
as (scoped) constants. Prover 0 produces substitutions for universal variables,
considers existential variables introduced in prover 0 as constants,
but we have no satisfactory answer for existential variables introduced in
prover 1.
As a consequence, in prover 0, unification raises an run-time error
when the instantiation of an existential variable is needed.
More details about that can be found in Section <A HREF="#restrict-logic-variables">5.3.2</A>.</P><!--TOC subsection Tabling--> 
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc23">5.2</A>&#XA0;&#XA0;Tabling</H3><!--SEC END --><P> 
<A NAME="tabling"></A></P><P>Proof search for a defined atom is done by unfolding the definition
for the atom, i.e. by replacing it with the body of the definition |
usually a disjunction of several clauses.
It is possible that loops occur in the proof-search,
and that the same goals arise several times.
By default, Bedwyr doesn&#X2019;t detect any of these issues, which makes the
proof-search much longer than needed, or infinite.
To address this, several search-directives
allow the user to instruct Bedwyr to keep records of certain
proved, disproved or ongoing formulas,
hence avoiding redundant search.
Bedwyr uses tabling in the underlying implementation to keep track of that.</P><P>Tabling is used in both prover 0 and prover 1 (see Section&#XA0;<A HREF="#psearch">5.1</A>).
The current implementation restricts tabling to atomic goals
with no occurrence of existential variables in prover 1.
In prover 0, only ground atomic goals (no occurrence of existential or universal
variables) are tabled.
For these goals, successes are always tabled, but some restrictions apply
to the tabling of failures, which is discussed in Section
<A HREF="#restrict-failures-tabling">5.2.2</A>.</P><P>The use of tabling makes it possible to do proof search for
&#X201C;non-terminating&#X201D; definitions, by simple loop checking.
Bedwyr will only detect loops on tabled goals, as described above.
The detection of a loop in the proof search for a predicate, say
<I>p</I>&#XA0;<I>t</I>, can have several interpretations, depending on whether
we consider <I>p</I>&#XA0;<I>t</I> as an <EM>inductive predicate</EM> or
a <EM>coinductive predicate</EM>. In the former case, that means that
<I>p</I>&#XA0;<I>t</I> is not provable, since otherwise it would contradict
the well-foundedness of inductive definitions. In the latter case,
we would have a proof of <I>p</I>&#XA0;<I>t</I>.</P><P>Tabling is by default not enabled in Bedwyr. To enable it, two keywords
are provided: <TT>inductive</TT> and <TT>coinductive</TT>.
To use tabling on a predicate <I>p</I>, one of them has to be added in the
declaration of <I>p</I>, in the header of the definition block.
Note that a definition block cannot contain both inductive and
co-inductive predicates at the same time, as it might lead to
contradictions | see [<A HREF="#momigliano03types">MT03</A>] for more details.</P><P>The command <CODE>#show_table pred</CODE> allows one to inspect the contents of
<CODE>pred</CODE>&#X2019;s table: formulas which have been proved or disproved. The
output displays one formula per line, with the prefix <CODE>P</CODE> for
proved and <CODE>D</CODE> for disproved. The formulas are abstracted over by
their generic and universal variables. The relative scopings of generic
and universal variables is not displayed although that information is
present internally: such information is needed, for example, to avoid
that a proof of (&#X2200; <I>x</I>&#X2207; <I>y</I>&#XA0; . &#XA0; <I>p</I>&#XA0;<I>x</I>&#XA0;<I>y</I>) is used as a proof for
(&#X2207; <I>y</I>&#X2200; <I>x</I>&#XA0; . &#XA0; <I>p</I>&#XA0;<I>x</I>&#XA0;<I>y</I>). The displaying of this information will
be fixed with planned extensions of the tabling mechanisms that will
implicitly allow extra axioms on &#X2207; (see [<A HREF="#tiu06lfmtp">Tiu06</A>]) in
order to be able to inspect in a meaningful way one predicate&#X2019;s table
from another logic program.</P><P>For example, if we define
</P><PRE CLASS="verbatim">Define inductive neq : nat -&gt; nat -&gt; prop by
  neq X Y := X = Y -&gt; false.
</PRE><P>and ask the queries <TT>forall x, nabla y, neq x y</TT> 
and <TT>nabla y, forall x, neq x y</TT>, we end up with the following
puzzling table:
</P><PRE CLASS="verbatim">?= #show_table neq.
Table for neq contains (P=Proved, D=Disproved):
 [P] nabla x1, x2\ neq x2 x1
 [D] nabla x1, x2\ neq x2 x1
?=
</PRE><P>The two entries are indistinguishable by the user, but internally some
extra information does separate them.</P><P>Other tabling related commands are <CODE>#clear_tables</CODE> and
<CODE>#clear_table &lt;pred&gt;</CODE> which clear all or some of the tabled entries.</P><!--TOC subsubsection A bisimulation example--> 
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc24">5.2.1</A>&#XA0;&#XA0;A bisimulation example</H4><!--SEC END --><P>In some cases the table contents has important uses: for
example, once the co-inductive predicate <TT>bisim</TT> (for bisimulation
in some of the example files) has been checked, the table for the
predicate <TT>bisim</TT> describes a bisimulation.
We give here a simple example of checking bisimulation of finite
state automata.
The example is distributed with Bedwyr in <CODE>examples/bisim.def</CODE>.
For more sophisticated examples involving the &#X3C0;-calculus,
we refer the reader to Section&#XA0;<A HREF="#pi-examples">6.2</A>.</P><P>Consider the following transition system (taken from [<A HREF="#milner99book">Mil99</A>],
page 19):
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>p</I>1&#XA0;/<SUB>/</SUB>[<I>lld</I>]<SUB><I>b</I></SUB>&#XA0;/<SUP>/</SUP>[<I>dd</I>]<SUP><I>a</I></SUP>&#XA0;<I>p</I>0&#XA0;/<SUB>/</SUB>[<I>rru</I>]<SUB><I>a</I></SUB>&#XA0;/<SUP>/</SUP>[<I>rrd</I>]<SUB><I>a</I></SUB>&#XA0;<I>p</I>2&#XA0;(<I>ur</I>,<I>dr</I>)<SUP><I>a</I></SUP>&#XA0;/<SUP>/</SUP>[<I>llu</I>]<SUP><I>b</I></SUP> 
 
&#XA0;&#XA0;&#XA0;&#XA0;
 
<I>q</I>0&#XA0;/<SUP>/</SUP>[<I>rrd</I>]<SUP><I>a</I></SUP>&#XA0;<I>q</I>1&#XA0;(<I>ur</I>,<I>dr</I>)<SUP><I>a</I></SUP>&#XA0;/<SUB>/</SUB>[<I>dll</I>]<SUB><I>b</I></SUB>&#XA0;<I>q</I>2&#XA0;/<SUB>/</SUB>[<I>rru</I>]<SUB><I>a</I></SUB> 
 
</TD></TR> 
</TABLE><P> 
The state <I>p</I>0 and <I>q</I>0 are bisimilar (see [<A HREF="#milner99book">Mil99</A>] for a proof).
This transition system is encoded in Bedwyr as follows:
</P><PRE CLASS="verbatim">Define next : state -&gt; trans -&gt; state -&gt; prop by
  next p0 a p1;
  next p0 a p2;
  next p1 b p0;
  next p1 a p2;
  next p2 a p2;
  next p2 b p0;
  next q0 a q1;
  next q1 a q1;
  next q1 b q2;
  next q2 a q1.
</PRE><P>The bisimulation relation is encoded as the following definition
</P><PRE CLASS="verbatim">Define coinductive bisim : state -&gt; state -&gt; prop by
  bisim P Q :=
    (forall P1 A, next P A P1 -&gt;
                     exists Q1, next Q A Q1 /\ bisim P1 Q1) /\
    (forall Q1 A, next Q A Q1 -&gt;
                     exists P1, next P A P1 /\ bisim P1 Q1).
</PRE><P>Using this definition of bisimulation, Bedwyr is able to prove that
<I>p</I>0 and <I>q</I>0 are indeed bisimilar. Here is an instance of a run in Bedwyr:
</P><PRE CLASS="verbatim">?= bisim p0 q0.
Yes.
More [y] ? y
No more solutions.
?= #show_table bisim.
Table for bisim contains (P=Proved, D=Disproved):
 [P] (bisim p1 q1)
 [P] (bisim p2 q1)
 [P] (bisim p0 q0)
 [P] (bisim p0 q2)
?=
</PRE><P>The table produced gives exactly the bisimulation set
needed to prove the bisimilarity of <I>p</I>0 and <I>q</I>0, i.e.,
the set {(<I>p</I>0,<I>q</I>0), (<I>p</I>0, <I>q</I>2), (<I>p</I>1,<I>q</I>1), (<I>p</I>2,<I>q</I>1) }.</P><!--TOC subsubsection Limitations of failures tabling--> 
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc25">5.2.2</A>&#XA0;&#XA0;Limitations of failures tabling</H4><!--SEC END --><P>
<A NAME="restrict-failures-tabling"></A></P><P>Successes for tabled goals are always remembered and used to avoid
re-proving them. However, storing failures is more complicated.
The failure of proof-search for some goal doesn&#X2019;t necessarily mean
that the formula is false: proof-search can have been aborted because
of loop detection on an inductive definition, which might actually be true.</P><P>Consider the following example.
</P><PRE CLASS="verbatim">Define
  inductive p : prop,
  inductive q : prop
by
  p := q \/ true;
  q := p.
</PRE><P>Let&#X2019;s study how the proof-search goes:
Try to prove <CODE>p</CODE>, unfold it, try <CODE>q</CODE>, unfold it, try <CODE>p</CODE>.
Noticing a loop, a failure happens.
However, marking <CODE>q</CODE> as disproved would be wrong,
since it is clearly provable.
Indeed, the second clause for <CODE>p</CODE> is tried, and yields a
success, meaning that <CODE>q</CODE> is true too.</P><P>Bedwyr&#X2019;s implementation of tabling is very simple and conservative.
It marks goals as
disproved only if no inductive-loop failures has been involved in the failure.
This is a very strong limitation, which makes some examples (like
<CODE>peterson.def</CODE>) too long because the proof-search spends a lot of time
checking again and again that the same formulas are false.</P><P>On our example, <CODE>q</CODE> is not marked as disproved
but it isn&#X2019;t marked as proved either: the information is lost.
If <CODE>p</CODE> is defined to be <CODE>q</CODE>,
then it becomes false and is marked as such,
but the table for <CODE>q</CODE> is left blank.</P><!--TOC subsection Two runtime errors from the interpreter--> 
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc26">5.3</A>&#XA0;&#XA0;Two runtime errors from the interpreter</H3><!--SEC END --><P>The strategy used by Bedwyr for attempting proofs is not complete.
That strategy involves using two provers (prover 0 and prover 1),
tabling, and depth-first search.
Many of the incompleteness that one encounters in
traditional logic programming languages, such as Prolog and &#X3BB;Prolog,
resulting from depth-first search certainly reappear in Bedwyr. We
mention two additional sources of incompleteness in the proof search
engine of Bedwyr.</P><!--TOC subsubsection <I>L</I><SUB>&#X3BB;</SUB> and non-<I>L</I><SUB>&#X3BB;</SUB> unification problems--> 
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc27">5.3.1</A>&#XA0;&#XA0;<I>L</I><SUB>&#X3BB;</SUB> and non-<I>L</I><SUB>&#X3BB;</SUB> unification problems</H4><!--SEC END --><P> 
A subset of &#X3BB;Prolog, called <I>L</I><SUB>&#X3BB;</SUB>, was presented in [<A HREF="#miller91jlc">Mil91</A>] where
it was shown that an implementation of proof search could be written
in which only a small subset of higher-order unification was required.
Furthermore, that subset was decidable, unary, and did not need typing
information. This subset of unification was called <I>L</I><SUB>&#X3BB;</SUB>-unification in
[<A HREF="#miller91jlc">Mil91</A>] but is now more commonly referred to as <EM>higher-order pattern unification</EM> 
[<A HREF="#nipkow93lics">Nip93</A>, <A HREF="#nadathur05iclp">NL05</A>]. In that subset, variables in
functional position are applied to distinct variables which must be
bound in the scope of the binding of the functional variable.</P><P>Bedwyr allows for unrestricted applications of variables to argument
but it is only willing to solve <I>L</I><SUB>&#X3BB;</SUB>-unification problems. As a result,
Bedwyr will occasionally complain that it needs to solve a &#X201C;not LLambda
unification problem&#X201D; and stop searching for a proof.</P><P>To illustrate this aspect of Bedwyr&#X2019;s incompleteness, consider the
problem of specifying the instantiation of a first-order quantifier.
In particular, consider the specification
</P><PRE CLASS="verbatim">Kind tm, fm   type.
Type all   (tm -&gt; fm) -&gt; fm.
Type p         tm -&gt; fm.
Type a         tm.
Define instan : fm -&gt; tm -&gt; fm -&gt; prop by
   instan (all B) T (B T).
</PRE><P>Thus, <TT>instan</TT> relates a universally quantified formula and a term
to the result of instantiating that quantifier with that term.
It is the case, however, that a
unification problem containing <CODE>(B T)</CODE> does not belong to the
<I>L</I><SUB>&#X3BB;</SUB> subset.
As a result, the following query results in a runtime error.
</P><PRE CLASS="verbatim">?= instan (all x\ p x) a (p X).
Not LLambda unification encountered: a
?=
</PRE><P>In some situations, a specification can be written so that the
problematic unification is delayed to a point where the unification
problem is within the <I>L</I><SUB>&#X3BB;</SUB> restriction. In this particular case, if
the clause in the definition of <TT>instan</TT> is rewritten to the
logically equivalent clause
</P><PRE CLASS="verbatim">   instan (all B) T S := S = (B T).
</PRE><P>this same query now returns an appropriate solution.
</P><PRE CLASS="verbatim">?= instan (all x\ p x) a (p X).
Solution found:
 X = a
More [y] ?
No more solutions.
?=
</PRE><P>An improvement to Bedwyr would be for it to automatically delay
unification problems that are outside the <I>L</I><SUB>&#X3BB;</SUB>-subset: delaying
&#X201C;difficult&#X201D; unification problems in the hope that future
instantiations and &#X3B2;-reduction will make them &#X201C;simple&#X201D; is
employed in such systems as Twelf and the second version of the Teyjus
implementation of &#X3BB;Prolog [<A HREF="#teyjus.website">GHN<SUP>+</SUP>08</A>].</P><!--TOC subsubsection Restriction on the occurrences of logic variables--> 
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc28">5.3.2</A>&#XA0;&#XA0;Restriction on the occurrences of logic variables</H4><!--SEC END --><P> 
<A NAME="restrict-logic-variables"></A></P><P>As we have already noted, in the current implementation of Bedwyr
there are restrictions on negative occurrences of logic variables |
i.e. to the left of an implication.
This restriction arises from the fact that we do not
have a satisfactory and comprehensive understanding of unification in
the prover 1 that incorporates such variables. As a result, Bedwyr
is incomplete since it generates a run-time error in these cases.
Consider the following two queries.
</P><PRE CLASS="verbatim">?= exists X, X = 42 -&gt; false.
At line 1, character 26:
Error: logic variable on the left
?= exists X, f X = 42 -&gt; false.
Yes.
More [y] ?
No more solutions.
?=
</PRE><P>The first query is certainly meaningful and is provable if there is a
term different from 42 (say, 43): in Bedwyr, this query generates a
run-time error since it requires dealing with a prover-1
existential variable within prover-0 unification. The second query illustrates
that some instances of prover-0 unification can tolerate the
occurrences of prover-1 existential variables.</P><P>Sometimes, one can change a specification to avoid this runtime
error. A simple example is provided by the following two queries.
</P><PRE CLASS="verbatim">?= exists X, (X = 42 -&gt; false) /\ X = 17.
At line 1, character 38:
Error: logic variable on the left
?= exists X, X = 17 /\ (X = 42 -&gt; false).
Yes.
More [y] ?
No more solutions.
?=
</PRE><P>Such reordering of goals is something a future version of Bedwyr might
attempt to do automatically.</P><!--TOC section Examples of Bedwyr code--> 
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc29">6</A>&#XA0;&#XA0;Examples of Bedwyr code</H2><!--SEC END --><DIV CLASS="flushright"> 
Few things are harder to put up with<BR> 
than the annoyance of a good example.<BR> 
&#X2013; Mark Twain
</DIV><P>The distribution of Bedwyr comes with several examples of its use.
These examples can be classified roughly as follows.</P><DL CLASS="description"><DT CLASS="dt-description"> 
<B>Basic examples</B></DT><DD CLASS="dd-description"> These examples are small and illustrate some
simple aspects of the system.</DD><DT CLASS="dt-description"><B>Model checking</B></DT><DD CLASS="dd-description"> Some simple model-checking-style examples are
provided.</DD><DT CLASS="dt-description"><B>Games</B></DT><DD CLASS="dd-description"> Bedwyr allows for a simple approach to explore for
winning strategies in some simple games, such as tic-tac-toe.</DD><DT CLASS="dt-description"><B>&#X3BB;</B><B>-calculus</B></DT><DD CLASS="dd-description"> Various relations and properties of the
&#X3BB;-calculus are developed in some definition files.</DD><DT CLASS="dt-description"><B>Simulation and bisimulation</B></DT><DD CLASS="dd-description"> These relationships between
processes where an important class of examples for which the theory
behind Bedwyr was targeted. Examples of checking simulation is done
for abstract transition systems, value-passing CCS, and the
&#X3C0;-calculus. The &#X3C0;-calculus examples are of particular note:
all side-conditions for defining the operational semantics and
bisimulation are handled directly and declaratively by the logic
underlying Bedwyr. See Section&#XA0;<A HREF="#pi-examples">6.2</A> below for some more
details about the &#X3C0;-calculus in Bedwyr.</DD></DL><!--TOC subsection Hypothetical reasoning--> 
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc30">6.1</A>&#XA0;&#XA0;Hypothetical reasoning</H3><!--SEC END --><P>For those familiar with &#X3BB;Prolog, a key difference between
Bedwyr and &#X3BB;Prolog is that the latter allows for &#X201C;hypothetical&#X201D;
reasoning and such reasoning is central to the way that &#X3BB;Prolog treats
bindings in syntax. Bedwyr treats implication and universals in
goal formulas in a completely different way: via the closed world
assumption.</P><P>Sometimes, when dealing with &#X3BB;-tree syntax in Bedwyr, one
wishes to program operations as one might do in &#X3BB;Prolog. This is possible
in the sense that one can write in Bedwyr an interpreter for suitable
fragments of &#X3BB;Prolog. This is done, for example, in the <TT>seq.def</TT> 
definition file. There is a goal-directed proof search procedure for a
small part of hereditary Harrop formulas (in particular, the minimal
theory of the fragment based on &#X22A4;, &#X2227;, &#X2283;, and
&#X2200;). This interpreter is prepared to use a logic program that
is stored as a binary predicate. For example, in &#X3BB;Prolog, one would write
type checking for simple types over the untyped &#X3BB;-calculus
encoded using <TT>app</TT> and <TT>abs</TT> as
</P><PRE CLASS="verbatim">typeof (app M N) B :- typeof M (arrow A B), typeof N A.
typeof (abs R) (arrow A B) :- pi x\ typeof x A =&gt; typeof (R x) B.
</PRE><P>The hypothetical reasoning that is involved in typing the object-level
&#X3BB;-binder in the second clause above is not available directly
in Bedwyr. One can, however, rewrite these clauses as simply
&#X201C;facts&#X201D; in Bedwyr:
</P><PRE CLASS="verbatim">Define simple : form -&gt; form -&gt; prop by
  simple (type_of (app M N) Tb)
    (type_of M (Ta \mytilde&gt; Tb) &amp;&amp; type_of N Ta);
  simple (type_of (abs R) (Ta \mytilde&gt; Tb))
    (for_all x\ type_of x Ta --&gt; type_of (R x) Tb).
 
Define atom : form -&gt; prop by
  atom (type_of X T).
</PRE><P>See <CODE>progs_small.def</CODE> for the complete declarations. The first
definition describes a logic program called <TT>simple</TT> that directly
encodes the above &#X3BB;Prolog program; the second definition tells the
interpreter in <TT>seq.def</TT> how to recognize an object-level atomic
formula. A call to <TT>seq atom simple tt (type_of term Ty)</TT> will
now attempt to perform simple type checking on <TT>term</TT>.
Specifically, it should now be possible to prove in Bedwyr the goal
</P><PRE CLASS="verbatim">(exists Ty, seq atom simple tt (type_of (abs x\ app x x) Ty))
  -&gt; false.
</PRE><P>in other words, the self-application &#X3BB; <I>x</I>(<I>x</I> <I>x</I>) does not have a
simple type.</P><P>This &#X201C;two-level approach&#X201D; of specification uses Bedwyr as a
meta-language in which a simple intuitionistic logic is encoded as an
object logic: computations can then be specified in the object-logic
in the usual way and the Bedwyr can be used to reason about that specification.
This general approach has been described in more detail in
[<A HREF="#miller06ijcar">Mil06</A>, <A HREF="#gacek.twolevel">GMN10</A>].</P><!--TOC subsection The &#X3C0;-calculus example in more detail--> 
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc31">6.2</A>&#XA0;&#XA0;The &#X3C0;-calculus example in more detail</H3><!--SEC END --><P> 
<A NAME="pi-examples"></A></P><P>To illustrate another example and how it
can be used, consider the implementation of the &#X3C0;-calculus that is
contained in the example file <CODE>pi/pi.def</CODE>. Of the several
things defined in that file, the operational semantics for the
&#X3C0;-calculus is given using one-step transitions: for a specific
example, see Figure&#XA0;<A HREF="#one-step">3</A>. First notice some similarities
between the syntax of clauses and that used in &#X3BB;Prolog. In
particular, the backslash is used to denote the &#X3BB;-binder. One
of the syntactic difference is that the head and body of clauses are
separated from each other using the <CODE>:=</CODE> instead of the
<CODE>:-</CODE> (turnstile). The former symbol is used to remind
the Bedwyr user that programs are used to define &#X201C;if and only if&#X201D;
completions of specifications (whereas, in &#X3BB;Prolog the <CODE>:-</CODE> is the
more usual &#X201C;if&#X201D; interpretation).</P><P>Beyond the syntactic differences, the operational semantics of &#X3BB;Prolog
and Bedwyr differ significantly. If a specification is simply a Horn
clause program, the two systems coincide. They differ in the operational
interpretation of implication: in Bedwyr, to prove <I>A</I>&#X2283; <I>B</I>, all
possible ways to prove <I>A</I> are explored and
for each answer substitution &#X3B8; that is found, the goal
<I>B</I>&#X3B8; is attempted (see Section&#XA0;<A HREF="#psearch">5.1</A>). Bedwyr also
contains the &#X2207;-quantifier [<A HREF="#miller05tocl">MT05</A>].</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV> 
<PRE CLASS="verbatim">[...]
onep (in X M)    (dn X) M;
one  (out X Y P) (up X Y) P;
one  (match X X P) A Q := one  P A Q;
onep (match X X P) A M := onep P A M;
one  (nu P) A (nu Q)          :=
  nabla x, one  (P x) A (Q x);
onep (nu P) A (y\ nu x\Q x y) :=
  nabla x, onep (P x) A (y\ Q x y);
one (par P Q) tau (par R T) :=
  exists X Y M, onep P (dn X) M /\
    one Q (up X Y) T /\ R = (M Y);
one (par P Q) tau (par R T) :=
  exists X Y M, onep Q (dn X) M /\
    one P (up X Y) R /\ T = (M Y);
[...]
</PRE><DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 3: Some lines in <TT>pi.def</TT> used to define one-step transitions.
See the example file for the full definition.</TD></TR> 
</TABLE></DIV> 
<A NAME="one-step"></A><PRE CLASS="verbatim">Define coinductive bisim : p -&gt; p -&gt; prop by
  bisim P Q :=
    (forall A P1, one P A P1 -&gt;
      exists Q1, one Q A Q1 /\ bisim P1 Q1) /\
    (forall X M, onep P (dn X) M -&gt;
      exists N, onep Q (dn X) N /\
      forall w, bisim (M w) (N w)) /\
    (forall X M, onep P (up X) M -&gt;
      exists N, onep Q (up X) N /\
      nabla w, bisim (M w) (N w)) /\
    (forall A Q1, one Q A Q1 -&gt;
      exists P1, one P A P1 /\ bisim P1 Q1) /\
    (forall X N, onep Q (dn X) N -&gt;
      exists M, onep P (dn X) M /\
      forall w, bisim (M w) (N w)) /\
    (forall X N, onep Q (up X) N -&gt;
      exists M, onep P (up X) M /\
      nabla w, bisim (M w) (N w)).
</PRE><DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 4: The definition of (open) bisimulation.</TD></TR> 
</TABLE></DIV><P> 
<A NAME="bisim"></A> 
</P><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Returning to the example in Figure&#XA0;<A HREF="#one-step">3</A>, notice that two
predicates are defined: <TT>one</TT> and <TT>onep</TT>. The first one
relates a process, an action, and a process. The second one relates a
process, an abstraction of an action, and an abstraction of a
process. The <TT>one</TT> predicate is used to capture &#X201C;free
transitions&#X201D; and the &#X201C;&#X3C4;-transition&#X201D; while the second is used
to capture bounded transitions. See [<A HREF="#tiu04fguc">TM04</A>, <A HREF="#tiu05concur">Tiu05</A>] for
more details on this encoding strategy for the &#X3C0;-calculus.</P><P>Figure&#XA0;<A HREF="#bisim">4</A> provides all that is necessary to specify (open)
bisimulation for (finite) &#X3C0;-calculus. The keyword <TT>coinductive</TT> tells the system that it will be attempting to explore a
greatest fixed point. That keyword also enables tabling, which avoids redundant
computations and accept loops as successes (see Section <A HREF="#tabling">5.2</A>).
The other cases should look natural, at least
once one understands the &#X3BB;-tree approach to representing syntax
and the use of the &#X2207;-quantifier. The main thing to point out
here is that in the specification, no special side conditions need to
be added to the system: all the familiar side conditions from the
usual papers on the &#X3C0;-calculus are treated by the implementation
of the Bedwyr logic: the user of the system no longer needs to deal
with them explicitly but implicitly and declaratively (via quantifier
scope, &#X3B1;&#X3B2;&#X3B7;-conversion, etc).</P><P>It is now possible to test some simple examples in the system. For
example,
</P><PRE CLASS="verbatim"> $ src/bedwyr examples/pi/pi.def
[...welcome message...]
?= bisim (in a x\ in a y\ z)
     (in a x\ nu w\ in a y\ out w w z).
Yes.
More [y] ? y
No more solutions.
?= bisim (in a x\ nu y\ match x y (out c c z))
     (in a x\ z).
Yes.
More [y] ? y
No more solutions.
?= bisim (nu x\ out a x (in c y\ match x y (out c c z)))
     (nu x\ out a x (in c y\ z)).
No.
?=
</PRE><P>These query prove that
<I>a</I>(<I>x</I>).<I>a</I>(<I>y</I>).0 and <I>a</I>(<I>x</I>).(&#X3BD; <I>w</I>).<I>a</I>(<I>y</I>).<I>w</I>!<I>w</I>.0 are bisimilar,
that
<I>a</I>(<I>x</I>).(&#X3BD; <I>y</I>).[<I>x</I>=<I>y</I>].<I>c</I>!<I>c</I>.0 and <I>a</I>(<I>x</I>).0 are bisimilar, and that
(&#X3BD; <I>x</I>).<I>a</I>!<I>x</I>.<I>c</I>(<I>y</I>).[<I>x</I>=<I>y</I>].<I>c</I>!<I>c</I>.0 and
(&#X3BD; <I>x</I>).<I>a</I>!<I>x</I>.<I>c</I>(<I>y</I>).0 are not bisimilar.</P><P>Several other aspects of the &#X3C0;-calculus are explored in the examples
files of the distribution. For example, the file <CODE>pi_modal.def</CODE> 
contains a specification of the modal logics for mobility described in
[<A HREF="#milner93tcs">MPW93</A>], and the file <CODE>corr-assert.def</CODE> specifies the
checking of &#X201C;correspondence assertions&#X201D; for the &#X3C0;-calculus as
described in [<A HREF="#gordon03tcs">GJ03</A>].
</P><!--TOC section Syntax--> 
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc32">A</A>&#XA0;&#XA0;Syntax</H2><!--SEC END --><P>Although the concrete syntax of Bedwyr was originally derived from that
of &#X3BB;Prolog in the Teyjus implementation[<A HREF="#nadathur99cade">NM99</A>], it has
now evolved in such a way that, by design, it resembles that of Abella
[<A HREF="#abella.website">Gac10</A>], a
proof assistant itself derived both from &#X3BB;Prolog and from the first
implementation of Bedwyr. This means that there is no syntactic
compatibility whatsoever between versions 1.2 and 1.3.</P><!--TOC subsection Tokens--> 
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc33">A.1</A>&#XA0;&#XA0;Tokens</H3><!--SEC END --><P>Names for objects such as types, predicates, constants and variables are
character strings built with letters, digits and the special characters
<CODE>-^&lt;&gt;=~+*&amp;:|</CODE>, <CODE>?`$'</CODE> and <CODE>_/@#!</CODE>. Names must be
separated by space-like characters (space, <CODE>TAB</CODE>, <CODE>CR</CODE>,
<CODE>LF</CODE>), parentheses or C-style inline nested comments.
As a general rule, variables starting with an uppercase character
(<CODE>A-Z</CODE>) in a query or the body of a definition are free variables
which are implicitly existentially quantified, a digit cannot be the
first character of a name, and the contiguous characters <CODE>/*</CODE> are
never part of names and always start an inline comment, except in a
quoted string.
Moreover, keywords are implicitly excluded from the present definition.</P><P>More precisely, we divide the special characters into three categories:
</P><UL CLASS="itemize"><LI CLASS="li-itemize"> 
infix characters (<CODE>-^&lt;&gt;=~+*&amp;:|</CODE>)
</LI><LI CLASS="li-itemize">prefix characters (<CODE>?`$'</CODE>)
</LI><LI CLASS="li-itemize">tail characters (<CODE>_/@#!</CODE>)
</LI></UL><P> 
which gives us three token categories:
</P><UL CLASS="itemize"><LI CLASS="li-itemize"> 
upper names, starting with <CODE>A-Z</CODE> and containing any letter,
digit, or prefix or tail character (i.e., anything but an infix):
<CODE>Foo?0</CODE>, <CODE>B@r</CODE>, <CODE>My_Var'</CODE> 
</LI><LI CLASS="li-itemize">prefix names, starting with <CODE>a-z</CODE> or a prefix character and
containing any letter, digit, or prefix or tail character (i.e.,
anything but an infix): <CODE>l33t</CODE>, <CODE>h#sh</CODE>, <CODE>?Your_Var</CODE> 
</LI><LI CLASS="li-itemize">infix names, the only ones to contain infix characters, and
containing nothing else: <CODE>--&gt;</CODE>, <CODE>|=</CODE>, <CODE>^^</CODE> 
</LI></UL><P> 
As already said, a free variable will be denoted by an upper name. A
bound variable can use either an upper or a prefix name, but it is
customary to use upper names for explicitly existentially quantified
variables, so that visual consistency is kept when we take advantage of
the implicit quantification of free variables. A type or predicate can
use any prefix name, a constant can use any prefix or infix name.</P><P>Though no name can begin with <CODE>_</CODE><SUP><A NAME="text3" HREF="#note3">2</A></SUP>, this character can
serve as a placeholder for an unspecified term, in which case it serves
as a fresh one-time free variable, except when used instead of a
variable name in a binding (abstraction or quantification), where it
serves as vacuous abstraction.</P><!--TOC subsection Concrete syntax--> 
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc34">A.2</A>&#XA0;&#XA0;Concrete syntax</H3><!--SEC END --><P>The grammar for formulas and terms is given in Figure&#XA0;<A HREF="#concrete">5</A>.
The abstraction over variable <CODE>x</CODE> in <CODE>term</CODE> is denoted by
<CODE>x\term</CODE> | which is read as &#X3BB; <I>x</I>. <I>term</I>. The scope of the
infix &#X3BB;-abstraction extends to the right as far as possible
inside of a term, but not across formula operators: the term
<CODE>x\ y\ f y x = g x y</CODE> is parenthesized as
<CODE>(x\ (y\ ((f y) x))) = ((g x) y)</CODE>.
On the other hand, the scope of the n-ary quantifiers extends to the
right even over formula operators: the formula
<TT>forall x y, f y x = g x y</TT> is parenthesized as
<TT>forall x y, (((f y) x) = ((g x) y))</TT>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV> 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=right NOWRAP><I>form</I></TD><TD VALIGN=top ALIGN=center NOWRAP>::=</TD><TD VALIGN=top ALIGN=left NOWRAP><I>term</I>&#XA0;<CODE>=</CODE>&#XA0;<I>term</I></TD><TD VALIGN=top ALIGN=left>equality</TD></TR> 
<TR><TD VALIGN=top ALIGN=right NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=center NOWRAP>|</TD><TD VALIGN=top ALIGN=left NOWRAP><I>form</I>&#XA0;<CODE>/\</CODE>&#XA0;<I>form</I></TD><TD VALIGN=top ALIGN=left>conjunction</TD></TR> 
<TR><TD VALIGN=top ALIGN=right NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=center NOWRAP>|</TD><TD VALIGN=top ALIGN=left NOWRAP><I>form</I>&#XA0;<CODE>\/</CODE>&#XA0;<I>form</I></TD><TD VALIGN=top ALIGN=left>disjunction</TD></TR> 
<TR><TD VALIGN=top ALIGN=right NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=center NOWRAP>|</TD><TD VALIGN=top ALIGN=left NOWRAP><I>form</I>&#XA0;<CODE>-&gt;</CODE>&#XA0;<I>form</I></TD><TD VALIGN=top ALIGN=left>implication</TD></TR> 
<TR><TD VALIGN=top ALIGN=right NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=center NOWRAP>|</TD><TD VALIGN=top ALIGN=left NOWRAP><CODE>forall x y z,</CODE>&#XA0;<I>form</I></TD><TD VALIGN=top ALIGN=left>universal quantification</TD></TR> 
<TR><TD VALIGN=top ALIGN=right NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=center NOWRAP>|</TD><TD VALIGN=top ALIGN=left NOWRAP><CODE>exists X Y Z,</CODE>&#XA0;<I>form</I></TD><TD VALIGN=top ALIGN=left>existential quantification</TD></TR> 
<TR><TD VALIGN=top ALIGN=right NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=center NOWRAP>|</TD><TD VALIGN=top ALIGN=left NOWRAP><CODE>nabla x y z,</CODE>&#XA0;<I>form</I></TD><TD VALIGN=top ALIGN=left>generic quantification</TD></TR> 
<TR><TD VALIGN=top ALIGN=right NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=center NOWRAP>|</TD><TD VALIGN=top ALIGN=left NOWRAP><I>term</I></TD><TD VALIGN=top ALIGN=left>&nbsp;</TD></TR> 
<TR><TD VALIGN=top ALIGN=right NOWRAP><I>term</I></TD><TD VALIGN=top ALIGN=center NOWRAP>::=</TD><TD VALIGN=top ALIGN=left NOWRAP><I>atom</I>*</TD><TD VALIGN=top ALIGN=left>application</TD></TR> 
<TR><TD VALIGN=top ALIGN=right NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=center NOWRAP>|</TD><TD VALIGN=top ALIGN=left NOWRAP><I>atom</I>*&#XA0;<I>id</I><CODE>\</CODE>&#XA0;<I>term</I></TD><TD VALIGN=top ALIGN=left>application on an
abstraction</TD></TR> 
<TR><TD VALIGN=top ALIGN=right NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=center NOWRAP>|</TD><TD VALIGN=top ALIGN=left NOWRAP><I>term</I>&#XA0;<I>infix</I>&#XA0;<I>term</I></TD><TD VALIGN=top ALIGN=left>(partial) infix application</TD></TR> 
<TR><TD VALIGN=top ALIGN=right NOWRAP><I>atom</I></TD><TD VALIGN=top ALIGN=center NOWRAP>::=</TD><TD VALIGN=top ALIGN=left NOWRAP><I>true</I>&#XA0;|&#XA0;<I>false</I></TD><TD VALIGN=top ALIGN=left><TT>prop</TT></TD></TR> 
<TR><TD VALIGN=top ALIGN=right NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=center NOWRAP>|</TD><TD VALIGN=top ALIGN=left NOWRAP><CODE>(</CODE><I>term</I><CODE>)</CODE></TD><TD VALIGN=top ALIGN=left>&nbsp;</TD></TR> 
<TR><TD VALIGN=top ALIGN=right NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=center NOWRAP>|</TD><TD VALIGN=top ALIGN=left NOWRAP><CODE>(</CODE><I>formula</I><CODE>)</CODE></TD><TD VALIGN=top ALIGN=left>&nbsp;</TD></TR> 
<TR><TD VALIGN=top ALIGN=right NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=center NOWRAP>|</TD><TD VALIGN=top ALIGN=left NOWRAP><CODE>(</CODE><I>infix</I><CODE>)</CODE></TD><TD VALIGN=top ALIGN=left>prefix version of an infix
constant</TD></TR> 
<TR><TD VALIGN=top ALIGN=right NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=center NOWRAP>|</TD><TD VALIGN=top ALIGN=left NOWRAP><CODE>"</CODE><I>string</I><CODE>"</CODE></TD><TD VALIGN=top ALIGN=left><TT>string</TT></TD></TR> 
<TR><TD VALIGN=top ALIGN=right NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=center NOWRAP>|</TD><TD VALIGN=top ALIGN=left NOWRAP>[0&#X2212;9]+</TD><TD VALIGN=top ALIGN=left><TT>nat</TT></TD></TR> 
<TR><TD VALIGN=top ALIGN=right NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=center NOWRAP>|</TD><TD VALIGN=top ALIGN=left NOWRAP><I>id</I></TD><TD VALIGN=top ALIGN=left>name</TD></TR> 
</TABLE></TD></TR> 
</TABLE> 
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 5: Grammar for formulas and terms.</TD></TR> 
</TABLE></DIV> 
<A NAME="concrete"></A> 
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>In its normal state, an infix constant has to be at least of arity 2:
<TT>(x **)</TT> raises a parsing error, while <TT>(x ** y)</TT> is legal and
can even be applied to another term if <TT>**</TT> is of arity 3 or more.
It is also possible to use the prefix version of an infix constant by
surrounding it with parentheses, in which case any arity is permitted:
<TT>(**) x</TT> and <TT>(**) x y z</TT> are both syntacticly legal.</P><P>A normal application has precedence over the application of an infix
constant: <TT>w x ** y z</TT> is parenthesized as <TT>(w x) ** (y z)</TT>;
otherwise, all infix constants have the same priority, and are
right-associative, to mimic the behavior of <TT>-&gt;</TT>.</P><!--TOC section References--> 
<H2 CLASS="section"><!--SEC ANCHOR -->References</H2><!--SEC END --><DL CLASS="thebibliography"><DT CLASS="dt-thebibliography"> 
<A NAME="baelde08phd"><FONT COLOR=purple>[Bae08a]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
David Baelde.
<EM>A linear approach to the proof-theory of least and greatest
fixed points</EM>.
PhD thesis, Ecole Polytechnique, December 2008.</DD><DT CLASS="dt-thebibliography"><A NAME="baelde08lfmtp"><FONT COLOR=purple>[Bae08b]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
David Baelde.
On the expressivity of minimal generic quantification.
In A.&#XA0;Abel and C.&#XA0;Urban, editors, <EM>International Workshop on
Logical Frameworks and Meta-Languages: Theory and Practice (LFMTP 2008)</EM>,
number 228, pages 3&#X2013;19, 2008.</DD><DT CLASS="dt-thebibliography"><A NAME="baelde12tocl"><FONT COLOR=purple>[Bae12]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
David Baelde.
Least and greatest fixed points in linear logic.
13(1), January 2012.
ACM Transactions on Computational Logic.</DD><DT CLASS="dt-thebibliography"><A NAME="abella.website"><FONT COLOR=purple>[Gac10]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Andrew Gacek.
The Abella interactive theorem prover &#X2013; version 1.3.5, September
2010.
Available from <TT>http://abella.cs.umn.edu/</TT>.</DD><DT CLASS="dt-thebibliography"><A NAME="teyjus.website"><FONT COLOR=purple>[GHN</FONT><SUP><FONT COLOR=purple>+</FONT></SUP><FONT COLOR=purple>08]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Andrew Gacek, Steven Holte, Gopalan Nadathur, Xiaochu Qi, and Zach Snow.
The Teyjus system &#X2013; version 2, March 2008.
Available from <TT>http://teyjus.cs.umn.edu/</TT>.</DD><DT CLASS="dt-thebibliography"><A NAME="girard92mail"><FONT COLOR=purple>[Gir92]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Jean-Yves Girard.
A fixpoint theorem in linear logic.
An email posting to the mailing list linear@cs.stanford.edu, February
1992.</DD><DT CLASS="dt-thebibliography"><A NAME="gordon03tcs"><FONT COLOR=purple>[GJ03]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Andrew&#XA0;D. Gordon and Alan Jeffrey.
Typing correspondence assertions for communication protocols.
<EM>Theoretical Computer Science</EM>, 300(1-3):379&#X2013;409, 2003.</DD><DT CLASS="dt-thebibliography"><A NAME="gacek.twolevel"><FONT COLOR=purple>[GMN10]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Andrew Gacek, Dale Miller, and Gopalan Nadathur.
A two-level logic approach to reasoning about computations.
Accepted to the J. of Automated Reasoning, August 2010.</DD><DT CLASS="dt-thebibliography"><A NAME="gacek11ic"><FONT COLOR=purple>[GMN11]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Andrew Gacek, Dale Miller, and Gopalan Nadathur.
Nominal abstraction.
<EM>Information and Computation</EM>, 209(1):48&#X2013;73, 2011.</DD><DT CLASS="dt-thebibliography"><A NAME="miller91jlc"><FONT COLOR=purple>[Mil91]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Dale Miller.
A logic programming language with lambda-abstraction, function
variables, and simple unification.
<EM>J. of Logic and Computation</EM>, 1(4):497&#X2013;536, 1991.</DD><DT CLASS="dt-thebibliography"><A NAME="milner99book"><FONT COLOR=purple>[Mil99]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Robin Milner.
<EM>Communicating and Mobile Systems : The </EM><EM>&#X3C0;</EM><EM>-calculus</EM>.
Cambridge University Press, New York, NY, USA, 1999.</DD><DT CLASS="dt-thebibliography"><A NAME="miller00cl"><FONT COLOR=purple>[Mil00]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Dale Miller.
Abstract syntax for variable binders: An overview.
In John Lloyd and et. al., editors, <EM>Computational Logic - </EM><EM>CL</EM><EM> 
2000</EM>, number 1861 in LNAI, pages 239&#X2013;253. Springer, 2000.</DD><DT CLASS="dt-thebibliography"><A NAME="miller06ijcar"><FONT COLOR=purple>[Mil06]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Dale Miller.
Representing and reasoning with operational semantics.
In U.&#XA0;Furbach and N.&#XA0;Shankar, editors, <EM>Proceedings of IJCAR:
International Joint Conference on Automated Reasoning</EM>, volume 4130 of <EM>LNAI</EM>, pages 4&#X2013;20, August 2006.</DD><DT CLASS="dt-thebibliography"><A NAME="mcdowell03tcs"><FONT COLOR=purple>[MMP03]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Raymond McDowell, Dale Miller, and Catuscia Palamidessi.
Encoding transition systems in sequent calculus.
<EM>Theoretical Computer Science</EM>, 294(3):411&#X2013;437, 2003.</DD><DT CLASS="dt-thebibliography"><A NAME="miller87slp"><FONT COLOR=purple>[MN87]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Dale Miller and Gopalan Nadathur.
A logic programming approach to manipulating formulas and programs.
In Seif Haridi, editor, <EM>IEEE Symposium on Logic Programming</EM>,
pages 379&#X2013;388, San Francisco, September 1987.</DD><DT CLASS="dt-thebibliography"><A NAME="milner93tcs"><FONT COLOR=purple>[MPW93]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Robin Milner, Joachim Parrow, and David Walker.
Modal logics for mobile processes.
<EM>Theoretical Computer Science</EM>, 114(1):149&#X2013;171, 1993.</DD><DT CLASS="dt-thebibliography"><A NAME="momigliano03types"><FONT COLOR=purple>[MT03]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Alberto Momigliano and Alwen Tiu.
Induction and co-induction in sequent calculus.
In Mario&#XA0;Coppo Stefano&#XA0;Berardi and Ferruccio Damiani, editors, <EM>Post-proceedings of TYPES 2003</EM>, number 3085 in LNCS, pages 293 &#X2013; 308,
January 2003.</DD><DT CLASS="dt-thebibliography"><A NAME="miller05tocl"><FONT COLOR=purple>[MT05]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Dale Miller and Alwen Tiu.
A proof theory for generic judgments.
<EM>ACM Trans. on Computational Logic</EM>, 6(4):749&#X2013;783, October
2005.</DD><DT CLASS="dt-thebibliography"><A NAME="nadathur99jflp"><FONT COLOR=purple>[Nad99]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Gopalan Nadathur.
A fine-grained notation for lambda terms and its use in intensional
operations.
<EM>Journal of Functional and Logic Programming</EM>, 1999(2), March
1999.</DD><DT CLASS="dt-thebibliography"><A NAME="nipkow93lics"><FONT COLOR=purple>[Nip93]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Tobias Nipkow.
Functional unification of higher-order patterns.
In M.&#XA0;Vardi, editor, <EM>Proc. 8th </EM><EM>IEEE</EM><EM> Symposium on Logic in
Computer Science (</EM><EM>LICS</EM><EM> 1993)</EM>, pages 64&#X2013;74. IEEE, June 1993.</DD><DT CLASS="dt-thebibliography"><A NAME="nadathur05iclp"><FONT COLOR=purple>[NL05]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Gopalan Nadathur and Natalie Linnell.
Practical higher-order pattern unification with on-the-fly raising.
In <EM>ICLP 2005: 21st International Logic Programming
Conference</EM>, volume 3668 of <EM>LNCS</EM>, pages 371&#X2013;386, Sitges, Spain,
October 2005. Springer.</DD><DT CLASS="dt-thebibliography"><A NAME="nadathur88iclp"><FONT COLOR=purple>[NM88]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Gopalan Nadathur and Dale Miller.
An Overview of &#X3BB;Prolog.
In <EM>Fifth International Logic Programming Conference</EM>, pages
810&#X2013;827, Seattle, August 1988. MIT Press.</DD><DT CLASS="dt-thebibliography"><A NAME="nadathur99cade"><FONT COLOR=purple>[NM99]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Gopalan Nadathur and Dustin&#XA0;J. Mitchell.
System description: Teyjus&#X2014;a compiler and abstract machine based
implementation of Lambda Prolog.
In H.&#XA0;Ganzinger, editor, <EM>Proceedings of the 16th International
Conference on Automated Deduction</EM>, pages 287&#X2013;291, Trento, Italy, July 1999.
Springer-Verlag LNCS.</DD><DT CLASS="dt-thebibliography"><A NAME="pfenning88pldi"><FONT COLOR=purple>[PE88]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Frank Pfenning and Conal Elliott.
Higher-order abstract syntax.
In <EM>Proceedings of the </EM><EM>ACM</EM><EM>-</EM><EM>SIGPLAN</EM><EM> Conference on Programming
Language Design and Implementation</EM>, pages 199&#X2013;208. ACM Press, June 1988.</DD><DT CLASS="dt-thebibliography"><A NAME="pientka05cade"><FONT COLOR=purple>[Pie05]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Brigitte Pientka.
Tabling for higher-order logic programming.
In <EM>20th International Conference on Automated Deduction, Talinn,
Estonia</EM>, pages 54 &#X2013; 69. Springer-Verlag, 2005.</DD><DT CLASS="dt-thebibliography"><A NAME="ramakrishna97cav"><FONT COLOR=purple>[RRR</FONT><SUP><FONT COLOR=purple>+</FONT></SUP><FONT COLOR=purple>97]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Y.&#XA0;S. Ramakrishna, C.&#XA0;R. Ramakrishnan, I.&#XA0;V. Ramakrishnan, Scott&#XA0;A. Smolka,
Terrance Swift, and David&#XA0;Scott Warren.
Efficient model checking using tabled resolution.
In <EM>Proceedings of the 9th International Conference on Computer
Aided Verification (CAV97)</EM>, number 1254 in LNCS, pages 143&#X2013;154, 1997.</DD><DT CLASS="dt-thebibliography"><A NAME="schroeder-Heister93lics"><FONT COLOR=purple>[SH93]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Peter Schroeder-Heister.
Rules of definitional reflection.
In M.&#XA0;Vardi, editor, <EM>Eighth </EM><EM>Annual Symposium on Logic in
Computer Science</EM>, pages 222&#X2013;232. IEEE Computer Society Press, IEEE, June
1993.</DD><DT CLASS="dt-thebibliography"><A NAME="tiu04phd"><FONT COLOR=purple>[Tiu04]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Alwen Tiu.
<EM>A Logical Framework for Reasoning about Logical Specifications</EM>.
PhD thesis, Pennsylvania State University, May 2004.</DD><DT CLASS="dt-thebibliography"><A NAME="tiu05concur"><FONT COLOR=purple>[Tiu05]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Alwen Tiu.
Model checking for &#X3C0;-calculus using proof search.
In Mart&#XED;n Abadi and Luca de&#XA0;Alfaro, editors, <EM>CONCUR</EM>,
volume 3653 of <EM>LNCS</EM>, pages 36&#X2013;50. Springer, 2005.</DD><DT CLASS="dt-thebibliography"><A NAME="tiu06lfmtp"><FONT COLOR=purple>[Tiu06]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Alwen Tiu.
A logic for reasoning about generic judgments.
In A.&#XA0;Momigliano and B.&#XA0;Pientka, editors, <EM>International Workshop
on Logical Frameworks and Meta-Languages:Theory and Practice (LFMTP&#X2019;06)</EM>,
2006.</DD><DT CLASS="dt-thebibliography"><A NAME="tiu04fguc"><FONT COLOR=purple>[TM04]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Alwen Tiu and Dale Miller.
A proof search specification of the &#X3C0;-calculus.
In <EM>3rd Workshop on the Foundations of Global Ubiquitous
Computing</EM>, volume 138 of <EM>ENTCS</EM>, pages 79&#X2013;101, September 2004.</DD><DT CLASS="dt-thebibliography"><A NAME="tiu10tocl"><FONT COLOR=purple>[TM10]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Alwen Tiu and Dale Miller.
Proof search specifications of bisimulation and modal logics for the
&#X3C0;-calculus.
<EM>ACM Trans. on Computational Logic</EM>, 11(2), 2010.</DD><DT CLASS="dt-thebibliography"><A NAME="tiu05eshol"><FONT COLOR=purple>[TNM05]</FONT></A></DT><DD CLASS="dd-thebibliography"> 
Alwen Tiu, Gopalan Nadathur, and Dale Miller.
Mixing finite success and finite failure in an automated prover.
In <EM>Proceedings of ESHOL&#X2019;05: Empirically Successful Automated
Reasoning in Higher-Order Logics</EM>, pages 79 &#X2013; 98, December 2005.</DD></DL><P>Any paper listed above that was written by one of the
authors of this guide can be found on their respective home pages.
</P><!--BEGIN NOTES document--> 
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes"> 
<A NAME="note1" HREF="#text1">*</A></DT><DD CLASS="dd-thefootnotes">Support has been obtained for this work from the following
sources: from INRIA (first through the &#X201C;&#XC9;quipes
Associ&#XE9;es&#X201D; Slimmer, and the &#X201C;ADT&#X201D; BATT),
and from the NSF Grants CCR-0429572 (that also included
support for Slimmer) and OISE-0553462.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note2" HREF="#text2">1</A></DT><DD CLASS="dd-thefootnotes"> 
We avoid the usual names (<EM>logic variables</EM> for existential variables and
<EM>eigenvariables</EM> for universal variables) in order to clearly separate the
high-level description given here from the implementation, which is not
detailed, but in which the class of a variable isn&#X2019;t static.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note3" HREF="#text3">2</A></DT><DD CLASS="dd-thefootnotes">Actually, such names
exist and are accepted by the parser, but are rejected by the type,
constant and predicate declarations, as they are read-only names, only
used for undocumented, internally defined predicates (usually
experimental, non-logical, and with side-effects).
</DD></DL> 
<!--END NOTES--> 
<!--CUT END --> 
<!--HTMLFOOT--> 
<!--ENDHTML--> 
<!--FOOTER--> 
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://hevea.inria.fr/index.html"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
