% Simple intruder theory and symbolic trace checking.
%
% It uses a 'constrained implication'. 
% A --> B means A is kept as a constraint in the antecedent
% of the sequent, and is used only to derive finite failure.
%


member X (cons X L).
member X (cons Y L) := member X L.

synth (cons X L) M := member M (cons X L).
synth (cons X L) (pr M N) := synth (cons X L) M, synth (cons X L) N.
synth (cons X L) (enc M N) := synth (cons X L) M, synth (cons X L) N.

remove X (cons X L) L.
remove X (cons Y L) (cons Y R) := remove X L R.

sat L (cons X (cons Y R)) := remove (pr X Y) L R.
sat L (cons X (cons Y R)) := remove (enc X Y) L R, synth L Y.
 
saturate L L.
saturate L R := sat L R, saturate R K.

deduce L M := saturate L K, synth K M.


% safe L P 
% this is provable if the process P never reaches the 'bad' state,
% in its interaction with an intruder. 
% Here L is the knowledge accumulated by the intruder during its
% interaction with P.

safe L z.
safe L (out A M P) := safe (cons M L) P.
safe L (in  A M)   := 
  pi Y\ (deduce L Y) --> safe L (M Y).
safe L (match X Y P) := (X = Y => safe L P).
safe L (nu M) := nabla x\ safe L (M x).


% no: k is made public, so the intruder has access to k
ex1 := safe nil (nu k\ out a k (in a y\ match y k bad)).

% yes: both m and k are private, although (enc m k) is public, so 
% the intruder has no access to m.
ex2 := safe nil (nu k\ nu m\ out a (enc m k) (in a y\ match y m bad)).

% no: the intruder can decrypt (enc m k) with k
ex3 := safe nil (nu k\ nu m\ out a (enc m k) (out a k (in a y\ match y m bad))).

% no: 
% the intruder's knowledge at the end of the trace
%  a, (enc Y k), (enc m (enc a k))
% The message m can be decrypted if Y is instantiated to a.
% Since a is available to the intruder, this is a valid instantiation,
% so m can be decrypted.
ex4 := safe (cons a nil) 
      (nu k\ nu m\ 
          in a (y\ 
             out a (enc y k) 
               (out a (enc m (enc a k))
                    (match y a (in a (w\ match w m bad)))
               )
          )
        ).

% yes: 
% This is similar to ex4, except that the first output is an encryption
% of m, not y.
ex5 := safe (cons a nil) 
      (nu k\ nu m\ 
          in a (y\ 
             out a (enc m k) 
               (out a (enc m (enc a k))
                    (in a (w\ match w m bad))
               )
          )
        ).

% yes: 
% In order to decrypt
%   (enc m (enc (pr m a) k))
% the intruder needs to know (enc (pr m a) k).
% The intruder has access to (enc Y k), where Y
% is anything that can be synthesized from its initial 
% knowledge, which contains only a, so the intruder can't
% synthesize (enc (pr m a) k).

ex6 := safe (cons a nil) 
      (nu k\ nu m\ 
          in a (y\ 
             out a (enc y k) 
               (out a (enc m (enc (pr m a) k))
                    (in a (w\ match w m bad))
               )
          )
        ).

% Yes:
% same as ex6, except that the initial knowledge is
% a bit more complicated; the name a has to be decoded. 

ex7 := safe (cons (enc a b) (cons b nil))
      (nu k\ nu m\ 
          in a (y\ 
             out a (enc y k) 
               (out a (enc m (enc (pr m a) k))
                    (in a (w\ match w m bad))
               )
          )
        ).


% No:
% modified slightly from ex7, the second message is
% encrypted using (enc (pr b a) k), and since the intruder
% can generate (pr b a) (to be fed to the first input),
% it will have access to (enc (pr b a) k).

ex8 := safe (cons (enc a b) (cons b nil))
      (nu k\ nu m\ 
          in a (y\ 
             out a (enc y k) 
               (out a (enc m (enc (pr b a) k))
                    (in a (w\ match w m bad))
               )
          )
        ).
