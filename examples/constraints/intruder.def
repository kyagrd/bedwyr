% Simple intruder theory and symbolic trace checking.
%
% Version 1:
% It uses a 'constrained implication'. 
% A --> B means A is kept as a constraint in the antecedent
% of the sequent, and is used only to derive finite failure.
%
% Infinite failure can still occur in checking intruder's theory
% saturation. This is fixed in version 2 which uses a finite failure
% detection in conjunction. See intruder2.def


member X (cons X L).
member X (cons Y L) := member X L.

% Message constructors:
% kind msg.
% sn : string -> msg.  % secret names
% pn : string -> msg.  % public names
% pr : msg -> msg -> msg.
% enc : msg -> msg -> msg. 

synth L M := member M L.
synth L (pn N). % Public names are always known to the intruder
synth L (pr M N) := synth L M, synth L N.
synth L (enc M N) := synth L M, synth L N.

remove X (cons X L) L.
remove X (cons Y L) (cons Y R) := remove X L R.

sat L (cons X (cons Y R)) := remove (pr X Y) L R.
sat L (cons X (cons Y R)) := remove (enc X Y) L R, synth L Y.
 
saturate L L.
saturate L R := sat L R, saturate R K.

deduce L M := saturate L K, synth K M.


% safe L P 
% this is provable if the process P never reaches the 'bad' state,
% in its interaction with an intruder. 
% Here L is the knowledge accumulated by the intruder during its
% interaction with P.

safe L zero.
safe L (out A M P) := safe (cons M L) P.
safe L (in  A M)   := 
  pi Y\ (deduce L Y) --> safe L (M Y).
safe L (match X Y P) := (X = Y => safe L P).
safe L (nu M) := nabla x\ safe L (M (sn x)).

% no
ex0 := safe nil (in (pn a) y\ bad).

% no: k is made public, so the intruder has access to k
ex1 := safe nil (nu k\ out (pn a) (sn k) (in (pn a) y\ match y (sn k) bad)).

% yes: both m and k are private, although (enc m k) is public, so 
% the intruder has no access to m.
ex2 := safe nil 
    (nu k\ nu m\ 
      out (pn a) (enc (sn m) (sn k))
      (in (pn a) y\ match y (sn m) bad)).

% no: the intruder can decrypt (enc m k) with k
ex3 := safe nil 
    (nu k\ nu m\ 
      out (pn a) (enc (sn m) (sn k))
      (out (pn a) (sn k) (in (pn a) y\ match y (sn m) bad))).

% no: 
% the intruder's knowledge at the end of the trace
%  a, (enc Y k), (enc m (enc a k))
% The message m can be decrypted if Y is instantiated to a.
% Since a is available to the intruder, this is a valid instantiation,
% so m can be decrypted.
ex4 := safe nil 
      (nu k\ nu m\ 
          in (pn a) 
          (y\ 
            out (pn a) (enc y (sn k)) 
             (out (pn a)  (enc (sn m) (enc (pn a) (sn k)))
               (in (pn a) (w\ match w (sn m) bad)))
          )
        ).

% yes: 
% This is similar to ex4, except that the first output is an encryption
% of m, not y.
ex5 := safe nil 
      (nu k\ nu m\ 
          in (pn a) 
          (y\ 
             out (pn a)  (enc (sn m) (sn k)) 
             (out (pn a) (enc (sn m) (enc (pn a) (sn k)))
                  (in (pn a) (w\ match w (sn m) bad))
              )
          )
        ).

% yes: 
% In order to decrypt
%   (enc m (enc (pr m a) k))
% the intruder needs to know (enc (pr m a) k).
% The intruder has access to (enc Y k), where Y
% is anything that can be synthesized from its initial 
% knowledge, which contains only a, so the intruder can't
% synthesize (enc (pr m a) k).

ex6 := safe nil 
      (nu k\ nu m\ 
          in (pn a) 
          (y\ 
             out (pn a) 
	     	 (enc y (sn k)) 
               	 (out (pn a) 
	       	      (enc (sn m) (enc (pr (sn m) (pn a)) (sn k)))
                      (in (pn a) (w\ match w (sn m) bad))
               	 )
          )
       ).

% Yes:
% same as ex6, except that the initial knowledge is
% a bit more complicated; the name a has to be decoded. 

ex7 := safe (cons (enc (sn a) (sn b)) (cons (sn b) nil))
      (nu k\ nu m\ 
          in (sn a) 
	     (y\ 
             	 out (sn a) (enc y (sn k)) 
		     (out (sn a) 
		     	  (enc (sn m) (enc (pr (sn m) (sn a)) (sn k)))
                    	  (in (sn a) (w\ match w (sn m) bad))
                     )
             )
       ).


% No:
% modified slightly from ex7, the second message is
% encrypted using (enc (pr b a) k), and since the intruder
% can generate (pr b a) (to be fed to the first input),
% it will have access to (enc (pr b a) k).

ex8 := safe (cons (enc (sn a) (sn b)) (cons (sn b) nil))
      (nu k\ nu m\ 
          in (sn a) 
	  (y\ 
             out (sn a) 
	     	 (enc y (sn k)) 
               	 (out (sn a)
		      (enc (sn m) (enc (pr (sn b) (sn a)) (sn k)))
                      (in (sn a) (w\ match w (sn m) bad))
                 )
          )
       ).


% Infinite loop. There's an infinite failure when checking
% deducibility constraints.

ex9 := safe nil 
       (nu b\ 
           in (pn a) 
	      (y\ 
	      	  out (pn a) (enc (pn a) y) 
          	      (in (pn a) w\ match w (sn b) bad)
              )
       ).
