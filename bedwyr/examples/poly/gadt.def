% An example from Kaustuv, with some modifications. 

Kind nt    type.
Type z      nt.
Type s      nt -> nt.

Kind bool   type.
Type tt,ff  bool.

Kind exp type -> type.
Type nat_exp  nt  -> exp nt.  
                              
Type bool_exp bool -> exp bool.
Type if_exp   exp bool -> exp A -> exp A -> exp A.

% Not quite the same as Kaustuv's definition of eval, as we forbid a predicate in
% the head to be typed differently in the body. So we split the eval predicate into
% two types. 
% This prevents run time typing error, as currently types are not checked during
% unification. In the future, this should be addressed by enforcing type-checking
% in unification (but may be less efficient). 

Define evaln : (exp A) -> A -> prop, evalb : (exp B) -> B -> prop by
   evaln (nat_exp N) N ; 
   evaln (if_exp I T E) V := (evalb I tt /\ evaln T V) \/ (evalb I ff /\ evaln E V) ;
   evalb (bool_exp B) B ; 
   evalb (if_exp I T E) V := (evalb I tt /\ evalb T V) \/ (evalb I ff /\ evalb E V).

% This example won't type check, because eval is used at two distinct types in
% the body. 
% Define eval : exp A -> A -> prop by 
%    eval (nat_exp N) N ;
%    eval (bool_exp B) B ;
%    eval (if_exp I T E) V := (eval I tt /\ eval T V) \/ (eval I ff /\ eval E V).


Kind list   type -> type.
Type nil    list A.
Type cons   A -> list A -> list A.

% The polymorphic member predicate is as usual. 
Define member : A -> list A -> prop by
  member X (cons X L) ; 
  member X (cons Y L) := member X L.

% Example queries: 
%   member 1 (cons 1 nil) /\ member "a" (cons "a" nil) 
% is okay, but
%
%   member 1 (cons "a" nil)
%
% produces type error. 
% Similarly, 
%   member 1 (cons 1 (cons "a" nil))
% is also not well-typed. 



% These are just to test the parser and the kind/type checking. 
Kind map    type -> type -> type.
Type empty  map K D.
Type add    K -> D -> map K D -> map K D.

