% Specification of late pi-calculus and strong bisimulation
%
% Please refer to the following paper for background:
%
% Alwen Tiu and Dale Miller. A proof search specification of
% the pi-calculus. Proceedings of FGUC04.
% Available from http://www.loria.fr/~tiu

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%    Static type checking of pi-calculus expressions     %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%%%% lambda Prolog style typing declaration for the pi-calculus
%%%% kind  n   type.   % Names
%%%% type  a, x, y     n.
%%%%
%%%% type  tau  a.     % Actions
%%%% type  dn, up      n -> n -> a.
%%%%
%%%% kind  p    type.  % Processes
%%%% type  in   	    n -> (n -> p) -> p.
%%%% type  out  	    n -> n -> p -> p.
%%%% type  taup 	    p -> p.
%%%% type  match       n -> n -> p -> p.
%%%% type  plus, par   p -> p -> p.
%%%% type  nu          (n -> p) -> p).
%%%% type  bang        p -> p.
%%%% type  z           p.
%%%%
%%%% type  one    p -> a -> p -> o.
%%%% type  onep   p -> (n -> a) -> (n -> p) -> o.
%%%
%%%% {{{
%%%% Type checking for names, actions, and processes are implemented directly
%%%% This is useful since Bedwyr does not do any static checking of syntax.
%%%
%%%% We include a small interpreter for hereditary Harrop formulas.  This
%%%% will allow us to write typing rules using familiar (lambda Prolog-like)
%%%% clauses.
%%%
%%%#include "../seq.def".
%%%
%%%% The logic program clauses for checking of the three syntactic classes in
%%%% the pi-calculus: names, actions, processes.  Best to think of "picheck"
%%%% as really the ":-" in lambda Prolog written as a prefix symbol.
%%%
%%%Define
%%%  atom
%%%by
%%%  atom (name   A);
%%%  atom (action A);
%%%  atom (proc   A).
%%%Define
%%%  picheck
%%%by
%%%  picheck (name a) tt;
%%%  picheck (name x) tt;
%%%  picheck (name y) tt;
%%%  picheck (action tau) tt;
%%%  picheck (action (up X Y))     (and (name X) (name Y));
%%%  picheck (action (dn X Y))     (and (name X) (name Y));
%%%  picheck (proc (in X P))       (and (_forall x\ (name x) implies (proc (P x))) (name X));
%%%  picheck (proc (out X Y P))    (and (and (name X) (name Y)) (proc P));
%%%  picheck (proc (taup P))       (proc P);
%%%  picheck (proc (match  X Y P)) (and (and (name X) (name Y)) (proc P));
%%%  picheck (proc (plus P Q))     (and (proc P) (proc Q));
%%%  picheck (proc (par  P Q))     (and (proc P) (proc Q));
%%%  picheck (proc (nu P))         (_forall x\ (name x) implies (proc (P x)));
%%%  picheck (proc (bang P))       (proc P);
%%%  picheck (proc z)              tt.
%%%
%%%% Check that all examples (listed below) actually type check.
%%%Define
%%%  typecheck
%%%by
%%%  typecheck := forall N P, example N P -> prv picheck (proc P).
%%%
%%%% Tell us which clause does not type check (if any).
%%%Define
%%%  whichwrong
%%%by
%%%  whichwrong N := exists P, example N P /\ (prv picheck (proc P) -> false).
%%%
%%%% }}}
%%%% {{{
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                 A few example processes                %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define
  example
by
  example 0  (nu x\ match x a (taup z));
  example 1  (par (in x y\z) (out x a z));
  example 2  (plus (in x y\out x a z) (out x a (in x y\z)));
  example 3  (in x u\ (plus (taup (taup z)) (taup z)));
  example 4  (in x u\ (plus (taup (taup z))
                    (plus (taup z)
                          (taup (match u y (taup z))))));
  example 5  (nu a\ (par (in x y\z) (out x a z)));
  example 6  (nu a\ (plus (in x y\out x a z) (out x a (in x y\z))));
  example 7  (taup z);
  example 8  (nu x\ (par (in x y\z) (out x a z)));
  example 9  (nu x\ out a x z);
  example 10 (par (in x y\ z) (nu y\ out x y z));
  example 11 (in x u\ nu y\ ((plus (taup (taup z))
                           (plus (taup z)
                                 (taup (match u y (taup z)))))));
  example 12 (bang P) := example 1 P;
  example 13 (bang (nu x\ par (out x a z) (in x y\ out c y z)));
  example 14 (bang (taup (out c a z))).

% }}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%     One step transition rules for the pi-calculus      %%%%
%%%%     Notice the rules are nearly identical to the       %%%%
%%%%     published inference rules for the pi-calculus.     %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define
  agent
by
  agent (zero C)    (in C s\ in C n\ out n nil z);
  agent (succ P C)  (in C s\ in C n\ out s P z);
  agent (add P Q R) (nu s\ nu n\ out P s (out P n
                    (in R ss\ in R nn\
                      (plus (in s k\ nu kk\ (par (out ss kk z) (add k Q kk)))
                            (in n nil\ out Q ss (out Q nn z))))));
  agent (nat (s N) C) (in C s\ in C zz\ nu n\ par (out s n z) (nat N n));
  agent (nat zz    C) (zero C);
  % Church natural numbers as encoded in the MWB examples
  agent (zero S Z) (nu i\ out Z i z);
  agent (un   S Z) (nu i\ out S i (nu i\ out Z i z));
  agent (deux S Z) (nu i\ out S i (nu i\ out S i (nu i\ out Z i z)));
  agent (succ S Z Y W) (nu i\ out Y i (copy S Z Y W));
  agent (copy S Z Y W) (plus (in S i\ succ S Z Y W)
                              (in Z i\ nu i\ out W i z));
  agent (add S1 Z1 S2 Z2 Y W)
      (plus (in S1 i\ nu i\ out Y i (add S1 Z1 S2 Z2 Y W))
            (in Z1 i\ copy S2 Z2 Y W));
  agent (church S Z zz)     (nu i\ out Z i z);
  agent (church S Z (ss N)) (nu i\ out S i (church S Z N)).

% bound input
Define
  one,
  onep
by
  onep (in X M) (dn X) M;
  % free output
  one (out X Y P) (up X Y) P;
  % tau
  one  (taup P) tau P;
  % match prefix
  one  (match X X P) A Q := one P A Q;
  onep (match X X P) A M := onep P A M;
  % sum
  one  (plus P Q) A R := one  P A R;
  one  (plus P Q) A R := one  Q A R;
  onep (plus P Q) A M := onep P A M;
  onep (plus P Q) A M := onep Q A M;
  % par
  one  (par P Q) A (par P1 Q) := one P A P1;
  one  (par P Q) A (par P Q1) := one Q A Q1;
  onep (par P Q) A (x\par (M x) Q) := onep P A M;
  onep (par P Q) A (x\par P (N x)) := onep Q A N;
  % restriction
  one  (nu x\P x) A (nu x\Q x)      := nabla x, one  (P x) A (Q x);
  onep (nu x\P x) A (y\ nu x\Q x y) := nabla x, onep (P x) A (y\ Q x y);
  % open
  onep (nu x\M x) (up X) N := nabla y, one (M y) (up X y) (N y);
  % close
  one (par P Q) tau (nu y\ par (M y) (N y)) :=
    exists X, onep P (dn X) M /\ onep Q (up X) N;
  one (par P Q) tau (nu y\ par (M y) (N y)) :=
    exists X, onep P (up X) M /\ onep Q (dn X) N;
  % comm
  one (par P Q) tau (par R T) :=
    exists X Y M, onep P (dn X) M /\ one Q (up X Y) T /\ R = (M Y);
  one (par P Q) tau (par R T) :=
    exists X Y M, onep Q (dn X) M /\ one P (up X Y) R /\ T = (M Y);
  % Rep-act
  one  (bang P) A (par P1 (bang P)) := one P A P1;
  onep (bang P) X (y\ par (M y) (bang P)) := onep P X M;
  % Rep-com
  one (bang P) tau (par (par R T) (bang P)) :=
    exists X Y M, onep P (dn X) M /\ one P (up X Y) R /\ T = (M Y);
  % Rep-close
  one (bang P) tau (par (nu y\ par (M y) (N y)) (bang P)) :=
    exists X, onep P (up X) M /\ onep P (dn X) N;
  %% Allow agent-style definitions as a controled recursion
  one  P A PP := agent P Body /\ one  Body A PP;
  onep P A PP := agent P Body /\ onep Body A PP.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%              Simulation and bisimulation               %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define
  coinductive sim
by
  sim P Q :=
	(forall A P1, one P A P1 -> exists Q1, one Q A Q1 /\ sim P1 Q1) /\
	(forall X M, onep P (dn X) M -> exists N, onep Q (dn X) N /\
					forall w, sim (M w) (N w)) /\
	(forall X M, onep P (up X) M -> exists N, onep Q (up X) N /\
					nabla w, sim (M w) (N w)).

Define
  coinductive bisim
by
  bisim P Q :=
	(forall A P1, one P A P1 -> exists Q1, one Q A Q1 /\ bisim P1 Q1) /\
	(forall X M, onep P (dn X) M -> exists N, onep Q (dn X) N /\
					forall w, bisim (M w) (N w)) /\
	(forall X M, onep P (up X) M -> exists N, onep Q (up X) N /\
					nabla w, bisim (M w) (N w)) /\
	(forall A Q1, one Q A Q1 -> exists P1, one P A P1 /\ bisim P1 Q1) /\
	(forall X N, onep Q (dn X) N -> exists M, onep P (dn X) M /\
					forall w, bisim (M w) (N w)) /\
	(forall X N, onep Q (up X) N -> exists M, onep P (up X) M /\
					nabla w, bisim (M w) (N w)).

#assert (bisim (in a x\ in a y\ z) (in a x\ nu w\ in a y\ z)).
#assert (forall P, bisim (in a x\ nu y\ match x y P)
                     (in a x\ z)).
#assert_not (P = out a a z /\
             bisim (nu x\ out a x (in c y\ match x y P))
                   (nu x\ out a x (in c y\ z))).

% {{{
% Weak bisimulation ===========================================================

Define
  taus
by
  taus P QQ := one P tau Q /\ taus Q QQ;
  taus P P.

Define
  weak_one
by
  weak_one Q (up X Y) P := taus Q QQ /\ one QQ A PP /\ taus PP P;
  weak_one Q tau QQ     := taus Q QQ.

Define
  weak_onep
by
  weak_onep Q (up X) P :=
  taus Q QQ /\ onep QQ (up X) PP /\ nabla x, taus (PP x) (P x);
  weak_onep Q (dn X) P :=
  taus Q QQ /\ onep QQ (dn X) PP /\ nabla x, taus (PP x) (P x). % forall -> not llam

Define
  coinductive weak_sim
by
  weak_sim P Q :=
    forall A X M,
      (one  P A M      -> exists N, weak_one  Q A N /\
                                   weak_sim M N) /\
      (onep P (dn X) M -> exists N, weak_onep Q (dn X) N /\
                            forall w, weak_sim (M w) (N w)) /\
      (onep P (up X) M -> exists N, weak_onep Q (up X) N /\
                            nabla w, weak_sim (M w) (N w)).

Define
  coinductive weak_bisim
by
  weak_bisim P Q :=
	(forall A P1, one P A P1 ->
           exists Q1, weak_one Q A Q1 /\ weak_bisim P1 Q1) /\

	(forall X M, onep P (dn X) M -> exists N, weak_onep Q (dn X) N /\
					forall w, weak_bisim (M w) (N w)) /\

	(forall X M, onep P (up X) M -> exists N, weak_onep Q (up X) N /\
					nabla w, weak_bisim (M w) (N w)) /\

	(forall A Q1, one Q A Q1 ->
           exists P1, weak_one P A P1 /\ weak_bisim P1 Q1) /\

	(forall X N, onep Q (dn X) N -> exists M, weak_onep P (dn X) M /\
					forall w, weak_bisim (M w) (N w)) /\

	(forall X N, onep Q (up X) N -> exists M, weak_onep P (up X) M /\
					nabla w, weak_bisim (M w) (N w)).
% }}}
