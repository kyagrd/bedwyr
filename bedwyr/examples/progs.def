#include "seq.def".

% Simple union of two binary relations.  These can be used to
% join together two logic programming specifications.

Define
  orelse
by
  orelse P Q X Y := P X Y \/ Q X Y.

% If you want to form the union of these two "logic programs",
% use either
%    (orelse exprog infer)
% or the lambda-expression
%    (x\y\ exprog x y ; infer x y)
% as the first argument of prv and seq.

% The empty theory can be written as (x\y\ false).

%% Examples:

Define
  atom
by
  atom (append X Y Z);
  atom a;
  atom b;
  atom (p X Y);
  atom (typeof X T);
  atom (copy S T);
  atom (subst R S T);
  atom (eval E V).
#assert (prv (x\y\ false) ((and a b) implies (and tt a))).
#assert
  (forall t u w,
     prv (x\y\ false) (_forall x\ _forall y\ (p x t) implies (p y u) implies (p x w)) ->
     w = t).

Define
  exprog
by
% Appending of two lists
  exprog (append nil L L) tt;
  exprog (append (cons X L) K (cons X M)) (append L K M).



Define
  prog
by
% Specification of simply typing inference for untyped lambda-calculus.
  prog (typeof (lam x\ B x) (Tin implies Tout))
     (_forall x\ typeof x Tin implies typeof (B x) Tout);
  prog (typeof (app A B) Tout) (and (typeof A (Tin implies Tout)) (typeof B Tin));
% Implementation of substitution into the untyped lambda-calculus.
  prog (copy (app M N) (app M' N')) (and (copy M M') (copy N N'));
  prog (copy (lam M) (lam M))
     (_forall x\ _forall x'\ copy x x' implies copy (M x) (M' x'));
  prog (subst R S T) (_forall x\ copy x S implies copy (R x) T);
% Call-by-value evaluation
  prog (eval (lam x\ M x) (lam x\ M x)) tt;
  prog (eval (app M N) V)
     (and (and (eval M (lam M')) (subst M' N M'')) (eval M'' V)).

#assert (prv prog (typeof (lam x\ lam y\ x) T)).

#assert (prv prog (typeof (app (lam x\ lam y\ x) (lam x\ x)) T)).

#assert_not   (forall T, prv prog (typeof (lam x\ app x x) T)).
#assert       (forall T, prv prog (typeof (lam x\ app x x) T) -> false).
#assert_raise ((forall T, prv prog (typeof (lam x\ app x x) T) -> false) => true).

#assert (forall T S, prv prog (typeof (lam x\ x) (T implies S)) -> T = S).

% The following has four proofs.
#assert (exists R, prv prog (subst R (lam x\x) (app (lam x\x) (lam y\y)))).
