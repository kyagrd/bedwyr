
% I use the __ prefix to avoid collision with user definitions.
% We use the #type declarations to fill the environment, and check
% definition's clauses against that.
% For now, type information are mandatory.
% Other analysis could include polymorphic types, mode checking, etc.

test := __typecheck "examples/3bits.def".
__typecheck File := parse File X, __check (bind true o (bind false o nil)) X.

__check Env nil.
__check Env (cons (command "kind" K) L)   := __check Env L.
__check Env (cons (command "type" X T) L) := __check (bind X T Env) L.
__check Env (cons (command "assert" X) L) :=
  print (checking test),
  __typed Env X o,
  __check Env L.
__check Env (cons (clause Head Body) L) :=
  print (checking clause for Head),
  __lookup Env Head T,
  __typed Env Body T,
  __check Env L.

__lookup (bind X T L) X T.
__lookup (bind Y Z L) X T := __lookup L X T.

__typed Env (X ,  Y) o := __typed Env X o, __typed Env Y o.
__typed Env (X ;  Y) o := __typed Env X o, __typed Env Y o.
__typed Env (X => Y) o := __typed Env X o, __typed Env Y o.

__typed Env (pi    X) o :=
  pi x\ __typed (bind x T Env) (X x) o.
__typed Env (nabla X) o :=
  pi x\ __typed (bind x T Env) (X x) o.
__typed Env (sigma X) o :=
  pi x\ __typed (bind x T Env) (X x) o.

__typed Env (A = B) o := __typed Env A T, __typed Env B T.

__typed Env (lam X) (I->O) :=
  pi x\ __typed (bind x I Env) (X x) O.
__typed Env (app X Y) O := (atom print) = X ;
                           (__typed Env X (I->O), __typed Env Y I).
__typed Env (atom X) T := __lookup Env X T.
