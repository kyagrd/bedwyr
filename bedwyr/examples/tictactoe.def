% convert Internal External
% Allows us to convert between internal and external formats.
% The external format is simple to read and write, but the internal
% format is better for recursion.

Kind    list,
        cell,
        row,
        board   type.

Type    nil'    list.
Type    b,o,x   cell.
Type    c       cell -> list -> list.
Type    row     cell -> cell -> cell -> row.
Type    board   row -> row -> row -> board.

Define
  convert : list -> board -> prop
by
  convert (c A (c B (c C (c D (c E (c F (c G (c H (c I nil')))))))))
          (board (row A B C) (row D E F) (row G H I)).

% winner Player Board
% True if Player has won on the Board
Define
  winner : cell -> list -> prop
by
  winner W (c W (c W (c W (c A (c B (c C (c D (c E (c F nil')))))))));
  winner W (c A (c B (c C (c W (c W (c W (c D (c E (c F nil')))))))));
  winner W (c A (c B (c C (c D (c E (c F (c W (c W (c W nil')))))))));
  winner W (c W (c A (c B (c W (c C (c D (c W (c E (c F nil')))))))));
  winner W (c A (c W (c B (c C (c W (c D (c E (c W (c F nil')))))))));
  winner W (c A (c B (c W (c C (c D (c W (c E (c F (c W nil')))))))));
  winner W (c W (c A (c B (c C (c W (c D (c E (c F (c W nil')))))))));
  winner W (c A (c B (c W (c C (c W (c D (c W (c E (c F nil'))))))))).

% nowinner Board
% True if nobody has won on the Board yet
Define
  nowinner : list -> prop
by
  nowinner B := forall X, winner X B -> X = b.

% move Board Player Board'
% True if Board' is the same as Board except for one move by Player.
Define
  move : list -> cell -> list -> prop
by
  move (c b L) W (c W L);
  move (c X L) W (c X K) := move L W K.

% somemove Board
% True if there is a possible move on the Board
Define
  somemove : list -> prop
by
  somemove L := exists K, move L o K.

% nomoves Board
% True if there are no possible moves on the Board.
Define
  nomoves : list -> prop
by
  nomoves L := somemove L -> false.

% tie Board
% True if the Board is a tie.
Define
  tie : list -> prop
by
  tie L := nomoves L /\ nowinner L.

% xwins Board
% True if x has a winning strategy for Board, assuming o plays first.
Define
  xwins : list -> prop
by
  xwins L := winner x L;
  xwins L := forall K, move L o K -> (nowinner K /\ exists M, move K x M /\ xwins M).

% owins Board
% True if o has a winning strategy for Board, assuming o plays first.
Define
  inductive owins : list -> prop
by
  owins L := winner o L;
  owins L := nowinner L /\ exists K, move L o K /\
               (winner o K \/ somemove K /\ forall M, move K x M -> owins M).

% These definitions are not stratified, but might be nice.
% Note: they would require that move L o K checks that x has not won,
%       and vice-versa.
% xwins L := forall K, move L o K  -> owins K => false.
% owins L := forall K, move L x K  -> xwins K => false.

% notxwins Board
% True if x does not have a winning strategy for Board, assuming o plays first.
% It would be nice to use (forall L, xwins L -> false), but xwins is level 1.
Define
  coinductive notxwins : list -> prop
by
  notxwins L := tie L \/ winner o L;
  notxwins L := nowinner L /\ exists K, move L o K /\
                  (tie K \/ winner o K \/ forall M, move K x M -> notxwins M).

% play Board
% This predicate lets you play tic-tac-toe against the computer.
% Given a board, the computer attempts to make a move in a winning
% strategy. If this is not possible, it attempts to make a move in a
% non-losing strategy. If this is not possible, it just makes some move.
Define
  play_to_win : list -> list -> prop
by  
  play_to_win L K := winner o K \/ somemove K /\ forall M, move K x M -> owins M.

Define
  play_to_tie : list -> list -> prop
by  
  play_to_tie L K := tie K \/ forall M, move K x M -> notxwins M.

Define
  play : board -> prop
by
  play L' := convert L L' /\ nowinner L /\ exists K,
      ((move L o K /\ play_to_win L K /\ print "Playing to win...") \/
       (move L o K /\ play_to_tie L K /\ print "Playing to tie...") \/
       (move L o K /\ print "Playing to lose...")) /\
      convert K K' /\ print K'.

#assert (convert Board (board (row x x x) (row b b b) (row b b b)) /\
         xwins Board).

#assert (convert Board (board (row x x b) (row b b b) (row b b b)) /\
         xwins Board).

#assert (convert Board (board (row x b o) (row b b b) (row b b b)) /\
         notxwins Board).

#assert (convert Board (board (row b b b) (row b b b) (row b b b)) /\
         notxwins Board).
