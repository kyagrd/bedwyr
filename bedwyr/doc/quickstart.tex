\documentclass[a4paper,twocolumn]{article}
\input{include/tex/preamble.tex}
\usepackage{amssymb}

\hypersetup{pdftitle={Bedwyr 1.4 QuickStart}}
\lstset{style=bedwyr}

\title{{\Huge A Quick-Start Guide to\\Bedwyr v1.4}}
\author{Quentin Heath\\
        Inria Saclay--\^Ile-de-France \& LIX, \'Ecole polytechnique}

\begin{document}
\maketitle

% ============================================================================
\section{Overview}

Bedwyr is a generalization of logic programming that allows model checking
directly on syntactic expression possibly containing bindings.  It identifies
finite successes and finite failures under the closed world assumption.  The
logic manipulated, a subset of LINC (for \emph{lambda, induction, nabla,
co-induction}), contains object-level $\lambda$-abstractions, three quantifiers
(including the $\nabla$ quantifier), and inductive and co-inductive
definitions.  While LINC is a extension of higher-order intuitionistic logic,
formulae are restricted to a fragment where connectives on the left of an
implication must have invertible rules (i.e. no universal quantifier nor
implication -- this is what enables the closed-world assumption), while equalities are
restricted to the \Ll{} fragment (allowing for the use of higher-order pattern
unification).

The system, written in OCaml, is part of an open source project.
The \href{http://slimmer.gforge.inria.fr/bedwyr/#download}{web page}
offers multiple ways to get it:
\begin{itemize}
  \item read-only SVN repository
  \item sources tarball
  \item precompiled binaries (win32, GNU/Linux, OCaml bytecode)
  \item GNU/Linux (Gentoo and Debian) unofficial packages
  \item Windows installer
\end{itemize}

The \href{http://slimmer.gforge.inria.fr/bedwyr/#documentation}{documentation}
includes this quick-start guide, a reference manual and the source-code
documentation.

% ============================================================================
\section{Input}

\begin{figure}[t]
  \centering
  \begin{tabular}{rl|ccc}
                            &                              & .def       & REPL       & CLI \\
    \hline
         \ref{sec:commands} & \lstinline+Define p : prop.+ & \checkmark &            & \texttt{-d} \\
          \ref{sec:queries} & \lstinline+X = 42.+          &            & \checkmark & \texttt{-e} \\
    \ref{sec:meta-commands} & \lstinline+#print_env.+      & \checkmark & \checkmark & \texttt{-d/-e} \\
  \end{tabular}
\end{figure}

\subsection{Commands (definition mode)}
\label{sec:commands}

Commands are used to declare new types and constants, declare and
define predicates, and define theorems (which are not proved, but are
used as lemmas).

They are grouped in definition files (plain text files, usually named
\path{*.def}), or passed onto the CLI (command-line interface) via the
\texttt{-d} option.

\subsection{Queries (toplevel)}
\label{sec:queries}

Queries are plain formulae that Bedwyr attempts to solve.  If
possible, it outputs the list of solutions (substitutions of the free
variables).  Otherwise, if the formula is not handled by the prover
(non-invertible connective on the left) or by the unifier (not \Ll{}),
resolution aborts.

They are entered interactively in an REPL (read-eval-print loop), or
passed onto the CLI via the \texttt{-e} option.

\subsection{Meta-commands}
\label{sec:meta-commands}

Meta-commands can be used wherever commands or queries are allowed.
Most of them aim at improving the user experience by executing strictly
non-logical tasks, mainly input (\lstinline+#include "inc.def".+), output
(\lstinline+#typeof X Y :: nil.+) or testing (\lstinline+#assert true.+).
A few of them change proof structure, but not provability
(\lstinline+#freezing 4.+, \lstinline+#saturation 2.+).

% ============================================================================
\section{Sample definition file}

\autoref{def:maxa} shows a complete sample definition file,
with the declarations for a type and two constants, along with a few predicates.

\begin{figure}[t]
  \lstinputlisting[%
    caption={\protect\path{maxa.def}},%
    label=def:maxa%
  ]{include/linc/maxa.def}
\end{figure}

The predicate \lstinline+a+ is a typical example of what must be done to build
a Bedwyr example: even with a theoretically infinite search space
(here, Church numerals), Bedwyr only does finite reasoning, and hence must be
given an explicit description of its finite actual search space.

The use of the \lstinline+inductive+ keyword has two consequences.
Firstly, memoization is used on the corresponding predicate;
secondly, it has an impact on the way loops in computation are handled.
Since the \lstinline+leq+ predicate obviously cannot loop,
only the first aspect is used here (meaning we might as well have used the
\lstinline+coinductive+ keyword instead).

% ============================================================================
\section{REPL demo}

\autoref{repl:maxa} shows an example of use of the interactive toplevel
following the invocation of \verb+bedwyr maxa.def+.

\begin{figure}[t]\begin{lstlisting}[%
  style=bedwyr-repl,caption={Interactive session},label=repl:maxa]
?= #env.
*** Types ***
   list : * -> *
   ch : *
*** Constants ***
   (::) : A -> (list A) -> list A
   nil : list A
   s : ch -> ch
   z : ch
*** Predicates ***
   a : ch -> prop
 I leq : ch -> ch -> prop
   maxa : ch -> prop
   member : A -> (list A) -> prop
?= leq X (s z).
Solution found:
 X = z
More [y] ? y
Solution found:
 X = s z
More [y] ? y
No more solutions.
?= maxa X.
Solution found:
 X = s (s (s (s (s z))))
More [y] ? y
No more solutions.
?= #exit.
\end{lstlisting}\end{figure}

The \lstinline+#env.+ meta-command shows all declared objects
(including the standard pre-declared list-related objects),
and displays \lstinline+leq+ as inductive.
The call to the query \lstinline+leq X (s (s z)).+ offers to display all
solutions, one by one.
The call to the query \lstinline+maxa X.+ does the same,
but a subsequent call to \lstinline+#show_table leq.+ would then show the table
filled with \lstinline+leq+-headed atoms, either marked as proved or disproved.

\end{document}
