\documentclass{article}
\bibliographystyle{alpha}
\usepackage{url}
\newcommand{\lp}{$\lambda$Prolog}

\title{{\Huge Bedwyr} \\ User Guide}
\author{David Baelde, Andrew Gacek, Dale Miller, Gopalan Nadathur}

\begin{document}
\maketitle

\tableofcontents

\paragraph{Layout}
In Section \ref{sec:install} we install Bedwyr as distributed
in tarballs or from the SVN.
In Section \ref{sec:interface} we describe the way the user interacts with 
Bedwyr, the command-line, the prompt and the syntax.
In Section \ref{sec:howto} we try to give the user an understanding
of the main concepts in order to use Bedwyr efficiently.

\paragraph{Why this name?}
In the legend of King Arthur and the round table, several knights
shared in the search for the holy grail.  The name of one of them,
Parsifal, is used for an INRIA team associated with the ``Slimmer''
effort.  Bedwyr was another one of those knights.  For more
information, see \url{http://www.lix.polytechnique.fr/parsifal/} and
\url{http://slimmer.gforge.inria.fr/}.


% ============================================================================
\newpage
\section{Get Bedwyr}
\label{sec:install}

You can get Bedwyr from Slimmer's INRIA Gforge project page:
\url{http://gforge.inria.fr/projects/slimmer}.
There you can download tarballs or get the development version using SVN
| instructions are provided on the project page.  The development of
Bedwyr is meant to be an open source project.  If you are keen
to work on the source code and/or examples, please contact
one of the ``Project Admins'' of the project (as listed at the above url).

\subsection{Distribution layout}

The Bedwyr distribution is organized as follows:

\begin{tabular}{rl}
  \texttt{/src}      & Source code \\
  \texttt{/doc}      &  Documentation | you're reading it \\
  \texttt{/examples} &  Examples | reading them helps
\end{tabular}

\subsection{Build}

Bedwyr's only dependency is the OCaml compiler suite.
Then, the procedure is quite simple.

\begin{verbatim}
# ./configure
# make
\end{verbatim}

You'll get the bedwyr executable in \texttt{src/bedwyr}.

\subsection{Test}

\begin{verbatim}
Testing the core library:
# make -C src test
More tests, including examples in Bedwyr:
# make test
\end{verbatim}

\subsection{Line editing}

By default, Bedwyr is built using the nativecode compiler \texttt{ocamlopt},
since it is much faster. If you don't have it or don't want it (e.g.
for easier debugging) use \texttt{./configure --disable-nativecode}.

Bedwyr has no line editing facilities at all. We recommend using \texttt{ledit}
for a nicer experience. Get it (from your usual package manager of at
(\url{ftp://ftp.inria.fr/INRIA/cristal/Daniel.de_Rauglaudre/Tools})
and simply run \texttt{ledit src/bedwyr}.

\subsection{Emacs mode}

Assuming Bedwyr sits in your \verb.~/bedwyr. directory,
you can use the Emacs mode for Bedwyr by adding these two lines to your
\verb,~/.emacs, file:
\begin{verbatim}
(load "~/bedwyr/contrib/bedwyr.el")
(setq bedwyr-program "~/bedwyr/src/bedwyr")
;; Of course you can change both locations to wherever you want.
\end{verbatim}

Then you should be able to load any \verb:.def: file
and have syntax highlighting and some rough auto-indenting.
Also if you do \verb.C-c C-c. it will start Bedwyr
and load the current file you are working on.

% ============================================================================
%\newpage
\section{User interface}
\label{sec:interface}

\subsection{Syntax}

Bedwyr uses HOAS (Higher-Order Abstract Syntax), which means that formulas
of the Linc logic and of the object logics are represented using 
$\lambda$-terms. The term normalization is implicit, the equality is the 
equality of $\lambda$-terms, notable handling implicitly $\alpha$-equivalence.

The abstraction over \verb.x. in \verb.term. is denoted by \verb.x\term. | 
which is read as $\lambda x. term$. On top of that we build 
formulas: e.g. we write \verb.pi x\ x=x.
(that is $pi\;(\lambda{}x.(=\;x\;x))$)
to represent $\forall x. x=x$.

Formulas are formed as follows:
\[\begin{array}{rclp{5cm}}
form &::=& form \texttt{,}  form & conjunction \\
     & | & form \texttt{;}  form & disjunction \\
     & | & form \texttt{=>} form & implication \\
     & | & \verb.pi x\.    form  & universal quantification over $x$ \\
     & | & \verb.sigma x\. form  & existential quantification over $x$ \\
     & | & \verb.nabla x\. form  & generic quantification over $x$ \\
     & | & atomic & definition \\
     & | & term \verb.=. term & equality \\
term &::=& id & identifiers are non-empty sequences of \verb.[A-Za-z0-9/_']. \\
     & | & term \; term+ & application \\
     & | & id \verb.\. term & abstraction \\
     & | & term \; infix \; term & infix operators are
             \verb.+., \verb.-., \verb.*., \verb.->. and \verb.<-.. \\
     & | & \verb.(. term \verb.). & \\
atomic &::=& id \; term* & a possibly empty application with a constant head \\
\end{array}\]

\subsection{Running Bedwyr}

Bedwyr has two modes: one for extending definitions and one for querying.
Definitions should be put in a file, as a set of clauses.
\[ clause ::= atomic \;\verb.:=.\; term \verb|.| \]
Such files are usually named with a \verb|.def| extension, you can find several
in the \verb.examples. directory of the Bedwyr distribution.

Queries are then asked against a given set of definitions.
Any well-formed formula is a query.

In queries, variables starting with an uppercase character (\verb.A-Z_.)
are implicitely quantified existentially, and their instantiations in solutions
are displayed.

In definitions, uppercase variables are implicitely universally quantified.

You can run Bedwyr in interactive mode by simply calling \texttt{src/bedwyr}.
You'll then get the Bedwyr prompt. In the following example we load a set of 
definitions and check a theorem about it: $\lambda x.x\;x$ has no simple type.

\begin{verbatim}
dbaelde@poum bedwyr % src/bedwyr
[...welcome message...]
?= #include "examples/lambda.def".
?= (sigma T\ wt nil (abs x\ app x x) T) => false.
+ 1ms
Yes.
More [y] ?
+ 0ms
No more solutions.
?= pi x\ X x = x x.
+ 0ms
Solution found:
 X = (x1\x1 x1)
More [y] ?
+ 0ms
No more solutions.
\end{verbatim}

A simpler way to load definition files is to pass them directly on the
command-line (call \verb|src/bedwyr examples/lambda.def|).
Other options are detailed in \verb.src/bedwyr --help..

% ============================================================================
%\newpage
\section{How to use Bedwyr ?}
\label{sec:howto}

A better undestanding of the tool is probably needed to get your work done.

\subsection{Proof-search within Level 0/1}

Bedwyr is a proof-search engine for the Level 0/1 fragment of the Linc logic.
Roughly, the Level 0/1 fragment requires that the formulas on the left of
implications do not contain implications and universal quantifications.
It allows the proof-search to be simple and (more) efficient,
since the formulas on the left can be immediately eliminated.

To prove an implication $A\Rightarrow B$,
Bedwyr enumerates all possible solutions $\theta_i$ for $A$,
and then tries to prove $B\theta_1\wedge\dots\wedge B\theta_N$.
In particular when $A$ has no solution, the formula is true.

Two runtime errors can occur:
when the prover encounters an unification which isn't a higher-order pattern;
when a logic variable appears on the left of an implication.

Examples will help to understand the second one:
\begin{verbatim}
?= X=1 => X=1.
Unknown error: Failure("logic variable on the left")
?= X=1, pi x\ x = X => x = X.
+ 0ms
Solution found:
 X = 1
More [y] ?
+ 0ms
No more solutions.
\end{verbatim}
The first query requires radically different tools than those we use |
namely, disunification. The query actually has infinitely many solutions,
any term other than $1$ fits $X$.
In the second case, it works, since \verb.X. is instantiated at the time the
implication is processed.

\subsection{Tabling}

Until now, all definitions (inductive, coinductive or non-recursive)
are treated the same way, loops can occur in the proof-search, and Bedwyr
won't avoid them. Also, Bedwyr can do the same search several times without
noticing. To solve that, we use tabling.

Although quite weak, tabling in Bedwyr is already a great improvement.
It is still under work.

For tabled definitions, being inductive of coinductive matters, and this 
matters only for tabled definitions.
Tabling is thus enabled by prepending the \texttt{inductive} or
\texttt{coinductive} keyword to \emph{every} clause of the definition |
even if the definition is non-recursive.

For now, tabling only applies to goals which do not contain logic variables.
Then, loops are successes for coinductive definitions,
and failures for inductive ones.


\section{The logic behind Bedwyr}
\label{logic}

The logic behind Bedwyr is an extension to a higher-order version of
intuitionistic logic.  Below we provide a high-level overview of the
logical aspects of Bedwyr that differentiate it from (the logics
underlying) \lp\ and Prolog.  More explicit information on this system
can be found in \cite{tiu05eshol}: n.b., the name ``Level 0/1'' in
that paper has now been replace by Bedwyr.


\paragraph{Built-in treatment of bindings}
Function variables are allowed and $\lambda$-abstractions are
primitive, and these are supported by the implementation of
``higher-order pattern unification'' (also called
$L_\lambda$-unification) \cite{miller91jlc}.  This kind of unification
appears to be the weakest extension to first-order unification that
treats bindings as a primitive.  A number of ``proof search'' systems
implement this kind of unification (eg, Twelf, Teyjus, Coq, and
Minlog).  Full $\beta$-conversion is implemented by Bedwyr as well.
As a result, {\em higher-order abstract syntax} is fully supported.
\lp\ similarly implements all these features, although \lp\ implements
full higher-order unification (that is, it is not restricted to the
$L_\lambda$ subset).  Another different with \lp\ is that Bedwyr does
not have a built-in notion of types, while \lp\ is simply typed.

\begin{figure}
\begin{verbatim}
% The predicate a holds for 3, 5, and 2.
a (s (s (s z))).
a (s (s (s (s (s z))))).
a (s (s z)).

% The less-than-or-equal relation
leq z N.
leq (s N) (s M) := leq N M.

% Compute the maximum of a
maxa N := a N, pi x\ a x => leq x N.
\end{verbatim}
\caption{Computing the maximum of a defined predicate.}
\label{maxa}
\end{figure}

\paragraph{Syntax and semantics of clauses}
Clauses in Bedwyr resemble those in \lp, but the underlying proof
search semantics of those clauses can differ significantly.  For example,
consider the Bedwyr program in Figure~\ref{maxa}.  These clauses are
identical to those in \lp\ except for the use of \verb+:=+ instead of
\verb+:-+.  Actually the ``proof search semantics'' for all but the
last clause above is the same in Bedwyr and \lp\ (and, in this case,
Prolog too).  The last clause, however, has an implication \verb+=>+
in the goal, something also allowed in \lp.  During proof search,
however, this occurrence of the implication in \lp\ causes the current
program to be extended with an atomic fact of the form \verb+(a c)+,
where {\tt c} is a new eigenvariable of the proof search.  In reality,
\lp\ uses the ``open-world assumption'': it adds a new item {\tt c}
and a new fact about it {\tt (a c)}.  In such a new world, however, the 
{\tt leq} relation to does not have any information about this
``non-standard'' number {\tt c}.  In constract to this, Bedwyr will
take the assumption  {\tt (a c)} and ask ``Given the assumption that 
{\tt (a c)} is true, how could it have been proved?''  The nature
answer to this is that that assumption could have been proved if {\tt
c} was either 3 or 5 or 2.  Thus, this analysis will cause a case
analysis: in particular, the query {\tt (maxa N)} will cause the
following goals to be considered:
\begin{verbatim}
        (a N)     (leq 3 N)    (leq 5 N)    (leq 2 N)
\end{verbatim}
The usual approach to unification and depth-first proof search will
now produce the proper maximum value.

\bigskip
There are two orthogonal extensions to higher-order intuitionistic
logic that have been incorporated into Bedwyr.   We describe them next.

\paragraph{Symmetry of finite success and finite failure}
The underlying logic of {\em fixed points} (also known as {\em
definitions})
\cite{girard92mail,schroeder-Heister93lics,mcdowell03tcs,momigliano03types}
contains an inference rule that allows for failure in unification
(and, hence, in simple proof search) to be turned into a success.
Thus, simple forms of ``negation-as-failure'' can be naturally
captured in Bedwyr and the underlying logic.  It is also possible to
describe both {\em may} and {\em must} behaviors in process calculi.
For example, not only can one code reachability in process calculus
but bisimulation is also possible.  One way to view this enhancement
to proof search is the following: Let $A$ and $B$ be two atomic
formulas.  Then, finite success is captured by proving the sequent
$\longrightarrow A$, finite failure is captured by proving the sequent
$A\longrightarrow$, and simulation is captured by proving the sequent
$A\longrightarrow B$.

\paragraph{The $\nabla$ quantifier}
In order to treat specifications using higher-order abstract syntax
properly, it appears that a new quantifier, called $\nabla$, is
necessary.  If finite success is all that is needed, the $\nabla$ can
be replaced with the universal quantifier.  When finite failure is
involved, however, the $\nabla$ quantifier plays an independent role.
See \cite{miller05tocl,tiu04phd,tiu05concur} for more on this
quantifier.  It is worth pointing out that we know of no examples
involving $\nabla$ that do not also involve hoas.

\bibliography{userguide}

\end{document}
