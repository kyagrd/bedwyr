\documentclass{article}
\bibliographystyle{alpha}
\usepackage{url}
\newcommand{\lp}{$\lambda$Prolog}

\title{{\Huge Bedwyr} \\ User Guide
   \thanks{This document still needs a lot of improvements.}}
\author{David Baelde, Andrew Gacek, Dale Miller, Gopalan Nadathur}

\begin{document}
\maketitle

\tableofcontents

\paragraph{Why this name?}
In the legend of King Arthur and the round table, several knights
shared in the search for the holy grail.  The name of one of them,
Parsifal, is used for an INRIA team associated with the ``Slimmer''
effort.  Bedwyr was another one of those knights.  Wikipedia (using
the spelling ``Bedivere'') mentions that Bedwyr appears in {\em Monty
Python and the Holy Grail} where he is ``portrayed as a master of the
extremely odd logic in the ancient times, whom occasionally blunders."
Bedwyr is a re-implementation and rethinking of an earlier system
called Level 0/1 written by Alwen Tiu and described in
\cite{tiu05eshol}.  For more information, see
\url{http://www.lix.polytechnique.fr/parsifal/} and
\url{http://slimmer.gforge.inria.fr/}.


% ============================================================================
\newpage
\section{Get Bedwyr}
\label{sec:install}

You can get Bedwyr from Slimmer's INRIA Gforge project page:
\url{http://gforge.inria.fr/projects/slimmer}.
There you can download tarballs or get the development version using SVN
| instructions are provided on the project page.  The development of
Bedwyr is meant to be an open source project.  If you are keen
to work on the source code and/or examples, please contact
one of the ``Project Admins'' of the project (as listed at the above url).

\subsection{Distribution layout}

The Bedwyr distribution is organized as follows:

\begin{tabular}{rl}
  \texttt{/src}      & Source code \\
  \texttt{/doc}      &  Documentation | you're reading it \\
  \texttt{/examples} &  Examples | reading them helps
\end{tabular}

\subsection{Build}

Bedwyr's only dependency is the OCaml compiler suite.
Then, the procedure is quite simple.

\begin{verbatim}
# ./configure
# make
\end{verbatim}

You'll get the bedwyr executable in \texttt{src/bedwyr}.

\subsection{Test}

\begin{verbatim}
Testing the core library:
# make -C src test
More tests, including examples in Bedwyr:
# make test
\end{verbatim}

\subsection{Line editing}

By default, Bedwyr is built using the nativecode compiler \texttt{ocamlopt},
since it is much faster. If you don't have it or don't want it (e.g.
for easier debugging) use \texttt{./configure --disable-nativecode}.

Bedwyr has no line editing facilities at all. We recommend using \texttt{ledit}
for a nicer experience. Get it (from your usual package manager of at
(\url{ftp://ftp.inria.fr/INRIA/cristal/Daniel.de_Rauglaudre/Tools})
and simply run \texttt{ledit src/bedwyr}.

\subsection{Emacs mode}

Assuming Bedwyr sits in your \verb.~/bedwyr. directory,
you can use the Emacs mode for Bedwyr by adding these two lines to your
\verb,~/.emacs, file:
\begin{verbatim}
(load "~/bedwyr/contrib/bedwyr.el")
(setq bedwyr-program "~/bedwyr/src/bedwyr")
;; Of course you can change both locations to wherever you want.
\end{verbatim}

Then you should be able to load any \verb:.def: file
and have syntax highlighting and some rough auto-indenting.
Also if you do \verb.C-c C-c. it will start Bedwyr
and load the current file you are working on.

% ============================================================================
%\newpage
\section{User interface}
\label{sec:interface}

The concrete syntax of formulas in Bedwyr resemble that used by
$\lambda$Prolog in, say, the Teyjus implementation
\cite{nadathur99cade}.  While both systems implement aspects of
higher-order logic programming, they are rather different systems.
The most striking difference between these systems is that
$\lambda$Prolog accepts the ``open-world assumption'': thus, any
conclusions drawn in (the logic of) $\lambda$Prolog will hold in any
extension of the underlying logic programming language.  Bedwyr on the
contrary accepts the ``closed-world assumption'': the notion of
programs are replaced by {\em definitions} that capture the
``if-and-only-if'' closure of logic programs.  This change allows
Bedwyr give a computational interpretation to finite failure and to
allow it do deduction that encodes model checking.

\subsection{Syntax}

Bedwyr uses HOAS (Higher-Order Abstract Syntax), which means that
formulas of the Linc logic and of the object logics are represented
using $\lambda$-terms. Term normalization ($\beta$-reduction) is
implicit and the equality of terms is given by
$\alpha\beta\eta$-conversion.

The grammar for formulas and terms is given in Figure~\ref{concrete}.
The abstraction over variable \verb.x. in \verb.term. is denoted by
\verb.x\term. | which is read as $\lambda x. term$. On top of that we
build formulas: e.g. we write \verb.pi x\ x=x.  (that is
$pi\;(\lambda{}x.(=\;x\;x))$) to represent $\forall x. x=x$.  The
scope of the infix $\lambda$-abstraction extends to the right as far
as possible: the term \verb.(x\ y\ f y x)). is parenthesized as 
\verb.(x\ (y\ ((f y) x))).

\begin{figure}
\[\begin{array}{rclp{5cm}}
form &::=& form \texttt{,}  form & conjunction \\
     & | & form \texttt{;}  form & disjunction \\
     & | & form \texttt{=>} form & implication \\
     & | & \verb.pi x\.    form  & universal quantification over $x$ \\
     & | & \verb.sigma x\. form  & existential quantification over $x$ \\
     & | & \verb.nabla x\. form  & generic quantification over $x$ \\
     & | & atomic & definition \\
     & | & term \verb.=. term & equality \\
term &::=& id & identifiers are non-empty sequences of \verb.[A-Za-z0-9/_']. \\
     & | & term \; term+ & application \\
     & | & id \verb.\. term & abstraction \\
     & | & term \; infix \; term & infix operators are
             \verb.+., \verb.-., \verb.*., \verb.->. and \verb.<-.. \\
     & | & \verb.(. term \verb.). & \\
atomic &::=& id \; term* & a possibly empty application with a constant head \\
\end{array}\]
\caption{Grammar for formulas and terms..}
\label{concrete}
\end{figure}

\subsection{Running Bedwyr}

Bedwyr has two modes: one for extending definitions and one for querying.
Definitions should be put in a file, as a set of clauses.
\[ clause ::= atomic \;\verb.:=.\; term \verb|.| \]
Such files are usually named with a \verb|.def| extension, you can find several
in the \verb.examples. directory of the Bedwyr distribution.

Queries are then asked against a given set of definitions.
Any well-formed formula is a query.

In queries, variables starting with an uppercase character (\verb.A-Z_.)
are implicitely quantified existentially, and their instantiations in solutions
are displayed.

In definitions, uppercase variables are implicitely universally quantified.

You can run Bedwyr in interactive mode by simply calling \texttt{src/bedwyr}.
You'll then get the Bedwyr prompt. In the following example we load a set of 
definitions and check a theorem about it: $\lambda x.x\;x$ has no simple type.

\begin{verbatim}
dbaelde@poum bedwyr % src/bedwyr
[...welcome message...]
?= #include "examples/lambda.def".
?= (sigma T\ wt nil (abs x\ app x x) T) => false.
Yes.
More [y] ? y
No more solutions.
?= pi x\ X x = x x.
Solution found:
 X = (x1\x1 x1)
More [y] ? y
No more solutions.
?= 
\end{verbatim}

A simpler way to load definition files is to pass them directly on the
command-line (call \verb|src/bedwyr examples/lambda.def|).
Other options are detailed in \verb.src/bedwyr --help..

% ============================================================================
%\newpage
\section{How to use Bedwyr}
\label{sec:howto}

A better undestanding of the tool is probably needed to get your work
done. 

\subsection{Proof-search within LINC}

LINC is a logic developed over the past few years.  The acronym, which
stands for ``lambda, induction, nabla, and coinduction'', lists the
main novel components of the logic.  In particular, $\lambda$-terms
are supported directly (and, hence, the $\lambda$-tree syntax approach
to higher-order abstract syntax is supported \cite{miller00cl}).
Induction and coinduction are also available.  The nabla $\nabla$
quantifier has be added to this logic in order to increase the
expressiveness of programs using hoas in negated situations.  The
proof theory of LINC is given in \cite{miller05tocl,tiu04phd}.

Bedwyr is a proof search engine for a small fragment of the LINC
logic.  In principle, Bedwyr uses two provers.  Prover 1 is similar to
a depth-first interpreter used in in $\lambda$Prolog.  The main
difference is in the proof of an implication.  
To prove an implication $A\Rightarrow B$, prover 1  calls prover 0
to enumerates all possible solutions
$\{\theta_i\;\vert\;i=1,\ldots,n\}$ for $A$, 
and then prover 1 tries to prove $B\theta_1\wedge\dots\wedge B\theta_N$.
If $A$ has no solution (that is, if $n=0$), the implication is true.
The substitutions generated by prover 1 are for ``logic variables'' in
the sense that is usual for logic programming implementations.  On the
other hand, the substitutions generated by prover 0 are for
eigenvariables. 

Two runtime errors can occur during proof search in Bedwyr.  The first
is when either prover encounters a unification problem that is not a 
higher-order pattern unification: full higher-order unification is not
implemented (as is done in $\lambda$Prolog).  The second error can
occur when a logic variable from prover 1 appears on the left of an
implication: prover 0 does not know what to do with such variables.

Examples will help to understand the second one:
\begin{verbatim}
?= X = 1 => X = 1.
Error: logic variable on the left
?= X=1, pi x\ x = X => x = X.
Solution found:
 X = 1
More [y] ? y
No more solutions.
?= 
\end{verbatim}
The first query requires radically different tools than those we use |
namely, disunification. (The crypic message about ``on the left''
refers to the left of the sequent arrow in the proof theory of LINC.)
The query actually has infinitely many solutions: any term other than
$1$ can be used to instantiate $X$.  In the second query works since
\verb.X. is instantiated at the time the implication is processed.

\subsection{Tabling}

Until now, all definitions (inductive, coinductive or non-recursive)
are treated the same way, loops can occur in the proof-search, and Bedwyr
won't avoid them. Also, Bedwyr can do the same search several times without
noticing. To solve that, we use tabling.

Although quite weak, tabling in Bedwyr is already a great improvement.
It is still under work.

For tabled definitions, being inductive of coinductive matters, and this 
matters only for tabled definitions.
Tabling is thus enabled by prepending the \texttt{inductive} or
\texttt{coinductive} keyword to \emph{every} clause of the definition |
even if the definition is non-recursive.

For now, tabling only applies to goals which do not contain logic variables.
Then, loops are successes for coinductive definitions,
and failures for inductive ones.


\section{The logic behind Bedwyr}
\label{logic}

The logic behind Bedwyr is an extension to a higher-order version of
intuitionistic logic.  Below we provide a high-level overview of the
logical aspects of Bedwyr that differentiate it from (the logics
underlying) \lp\ and Prolog.  More explicit information on this system
can be found in \cite{tiu05eshol}: n.b., the name ``Level 0/1'' in
that paper has now been replace by Bedwyr.


\paragraph{Built-in treatment of bindings}
Function variables are allowed and $\lambda$-abstractions are
primitive, and these are supported by the implementation of
``higher-order pattern unification'' (also called
$L_\lambda$-unification) \cite{miller91jlc}.  This kind of unification
appears to be the weakest extension to first-order unification that
treats bindings as a primitive.  A number of ``proof search'' systems
implement this kind of unification (eg, Twelf, Teyjus, Coq, and
Minlog).  Full $\beta$-conversion is implemented by Bedwyr as well.
As a result, {\em higher-order abstract syntax} is fully supported.
\lp\ similarly implements all these features, although \lp\ implements
full higher-order unification (that is, it is not restricted to the
$L_\lambda$ subset).  Another different with \lp\ is that Bedwyr does
not have a built-in notion of types, while \lp\ is simply typed.

\begin{figure}
\begin{verbatim}
% The predicate a holds for 3, 5, and 2.
a (s (s (s z))).
a (s (s (s (s (s z))))).
a (s (s z)).

% The less-than-or-equal relation
leq z N.
leq (s N) (s M) := leq N M.

% Compute the maximum of a
maxa N := a N, pi x\ a x => leq x N.
\end{verbatim}
\caption{Computing the maximum of a defined predicate.}
\label{maxa}
\end{figure}

\paragraph{Syntax and semantics of clauses}
Clauses in Bedwyr resemble those in \lp, but the underlying proof
search semantics of those clauses can differ significantly.  For example,
consider the Bedwyr program in Figure~\ref{maxa}.  These clauses are
identical to those in \lp\ except for the use of \verb+:=+ instead of
\verb+:-+.  Actually the ``proof search semantics'' for all but the
last clause above is the same in Bedwyr and \lp\ (and, in this case,
Prolog too).  The last clause, however, has an implication \verb+=>+
in the goal, something also allowed in \lp.  During proof search,
however, this occurrence of the implication in \lp\ causes the current
program to be extended with an atomic fact of the form \verb+(a c)+,
where {\tt c} is a new eigenvariable of the proof search.  In reality,
\lp\ uses the ``open-world assumption'': it adds a new item {\tt c}
and a new fact about it {\tt (a c)}.  In such a new world, however, the 
{\tt leq} relation to does not have any information about this
``non-standard'' number {\tt c}.  In constract to this, Bedwyr will
take the assumption  {\tt (a c)} and ask ``Given the assumption that 
{\tt (a c)} is true, how could it have been proved?''  The nature
answer to this is that that assumption could have been proved if {\tt
c} was either 3 or 5 or 2.  Thus, this analysis will cause a case
analysis: in particular, the query {\tt (maxa N)} will cause the
following goals to be considered:
\begin{verbatim}
        (a N)     (leq 3 N)    (leq 5 N)    (leq 2 N)
\end{verbatim}
The usual approach to unification and depth-first proof search will
now produce the proper maximum value.

\bigskip
There are two orthogonal extensions to higher-order intuitionistic
logic that have been incorporated into Bedwyr.   We describe them next.

\paragraph{Symmetry of finite success and finite failure}
The underlying logic of {\em fixed points} (also known as {\em
definitions})
\cite{girard92mail,schroeder-Heister93lics,mcdowell03tcs,momigliano03types}
contains an inference rule that allows for failure in unification
(and, hence, in simple proof search) to be turned into a success.
Thus, simple forms of ``negation-as-failure'' can be naturally
captured in Bedwyr and the underlying logic.  It is also possible to
describe both {\em may} and {\em must} behaviors in process calculi.
For example, not only can one code reachability in process calculus
but bisimulation is also possible.  One way to view this enhancement
to proof search is the following: Let $A$ and $B$ be two atomic
formulas.  Then, finite success is captured by proving the sequent
$\longrightarrow A$, finite failure is captured by proving the sequent
$A\longrightarrow$, and simulation is captured by proving the sequent
$A\longrightarrow B$.

\paragraph{The $\nabla$ quantifier}
In order to treat specifications using higher-order abstract syntax
properly, it appears that a new quantifier, called $\nabla$, is
necessary.  If finite success is all that is needed, the $\nabla$ can
be replaced with the universal quantifier.  When finite failure is
involved, however, the $\nabla$ quantifier plays an independent role.
See \cite{miller05tocl,tiu04phd,tiu05concur} for more on this
quantifier.  It is worth pointing out that we know of no examples
involving $\nabla$ that do not also involve hoas.

\section{Examples of Bedwyr code}

\begin{flushright}
Few things are harder to put up with than\\
the annoyance of a good example.\\
    -- Mark Twain
\end{flushright}

The distribution of Bedwyr comes with several examples of its use.
These examples can be divided classified roughly as follows.

\begin{description}
\item[Basic examples] These examples are small and illustrate some
  simple aspects of the system.

\item[Model checking] Some simple model-checking-style examples are
  provided. 

\item[Games] Bedwyr allows for a simple approach to explore for
  winning strategies in some simple games, such as tic-tac-toe.

\item[$\lambda$-calculus] Various relations and properties of the
  $\lambda$-calculus are developed in some definition files.

\item[Simulation and bisimulation] These relationships between
  processes where an important class of examples for which the theory
  behind Bedwyr was targeted.  Examples of checking simulation is done
  for abstract transition systems, value-passing CCS, and the
  $\pi$-calculus.  The $\pi$-calculus examples are of particular note:
  all side-conditions for defining the operational semantics and
  bisimulation are handled directly and declaratively by the logic
  underlying Bedwyr.  

\end{description}

%\bibliography{userguide}
\bibliography{../../../../../pap/references/master}


\end{document}
