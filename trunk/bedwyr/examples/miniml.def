% Mini-ML, evaluation, type checking and type inference.
% Author: David Baelde
%
% Our "Mini-ML" has let-polymorphism and patterns over pairs.
% This is an unfinished development, it would need to be type-checked and
% cleaned up. Type inference of the match construct is not yet written.
%
% vi: foldmethod=marker
%
% *** Base Types ***
% int   : bty
% bool  : bty
%
% *** Types ***
% tycst : bty -> ty
% tyvar : nm -> ty
% tyabs : (ty -> ty) -> ty
% arrow : ty -> ty -> ty
% times : ty -> ty -> ty
%
% *** Values ***
% cst   : nm -> tm
% var   : nm -> tm
% abs   : (tm -> tm) -> tm
% app   : tm -> tm -> tm
% let   : tm -> (tm -> tm) -> tm
% cons  : tm -> tm -> tm
% match : (pt*tm) list -> tm
%
% *** Patterns ***
% ptcons  : pt -> pt -> pt
% ptcst   : nm -> pt
% hole    : pt

% ----- Basic list manipulations

% Membership
mem X (cons X L).
mem X (cons Y L) := mem X L.

% Concatenation
concat nil L L.
concat (cons X T) L (cons X O) := concat T L O.

% [remove X LX L] iff [LX] is [L] where [X] has been inserted somewhere;
% note that [LX=L] is impossible here.
remove X (cons X L) L.
remove X (cons Y L) (cons Y L') := (Y=X => false) /\ remove X L L'.

% remove_all removes several (or none) occurences of an item in a list
remove_all X (cons X L) L' := remove_all X L L'.
remove_all X (cons Y L) (cons Y L') := (Y=X => false) /\ remove_all X L L'.
remove_all X nil nil.

% [minus A B S] iff S = A\B
minus L nil L.
minus L (cons X M) L' := remove_all X L L'' /\ minus L'' M L'.

% {{{
% ----- Weak call-by-value reduction

eval G (cst C) (cst C).
eval G (var X) M := mem (assoc X M) G.
eval G (abs F) (abs F).
eval G (app M N) V := eval G M (abs F) /\ eval G (F N) V.
eval G (let D B) V := eval G D VD /\
                      nabla x, eval (cons (assoc x VD) G) (B (var x)) V.
eval G (cons M N) (cons VM VN) := eval G M VM /\ eval G N VN.
eval G (match X CL) V := mem (assoc C B) CL /\ extract C X B B' /\ eval G B' V.

% [extract P M B] filters the term M through the pattern P and applies
% the extracted sub-terms to the body B, yielding B'.
extract hole M B (app B M).
extract (ptcons P Q) (cons M N) B B'' := extract P M B B' /\ extract Q N B' B''.
extract (ptcst C) (cst C) B B.

% ----- Testing the evaluation

test 0 (abs x\ match x
          (cons (assoc (ptcons hole hole) (abs a\ abs b\ a)) nil)).
test 1 (app F (cons (cst true) (cst false))) := test 0 F.
test 2 (let FST
         (fst\ let (app fst (cons (cst true) (cst false)))
                (x\ app fst (cons x (cst false))))) := test 0 FST.

#assert (forall x, test 1 x => forall y, eval nil x y => y = cst true).
#assert (forall x, test 2 x => forall y, eval nil x y => y = cst true).

% ----- Type-checking

cst_typeof 0 int.
cst_typeof (s X) int := cst_typeof X int.
cst_typeof true bool.
cst_typeof false bool.

typeof G (cst C) T := cst_typeof C T.
typeof G (var X) T := mem (assoc X T) G.
typeof G (abs F) (arrow T1 T2) :=
  % TODO apply x or var x ???
  nabla x, typeof (cons (assoc x T1) G) (F (var x)) T2.
typeof G (app M N) T := typeof G M (arrow T1 T) /\ typeof G N T1.
typeof G (let D B) T := typeof G D TD /\
                        print (type D TD) /\
                        nabla x, typeof (cons (assoc x TD) G) (B x) T.
typeof G (cons M N) (times TM TN) := typeof G M TM /\ typeof G N TN.
typeof G (match X CL) T :=
  typeof G X TX /\
  forall pat body, mem (assoc pat body) CL =>
    extract_typeof (cons (assoc pat TX) nil) G body T.
% The last clause can make the spec loop...
% it is not suitable for inference, any failed attempt will loop.
% The problem is that the spec has to make some guesses even on ground queries,
% so it loops there too, sometimes.
% (V=abs F) limits the damage a bit...
typeof G V (tyabs T) :=
  false /\
  V = abs F /\
  nabla x, typeof G V (T x).

extract_typeof (cons (assoc hole TH) L) G (abs B) T :=
  % TODO should we apply [x] or [var x] ?
  % [var x] causes a not-llambda more often, possibly
  nabla x, extract_typeof L (cons (assoc x TH) G) (B (var x)) T.
extract_typeof (cons (assoc (ptcst X) TX) L) G B T :=
  cst_typeof X TX /\ extract_typeof L G B T.
extract_typeof (cons (assoc (ptcons P Q) (times TP TQ)) L) G B T :=
  extract_typeof (cons (assoc P TP) (cons (assoc Q TQ) L)) G B T.
extract_typeof nil G B T := typeof G B T.

#assert (extract_typeof (cons (assoc (ptcons (ptcst true) hole)
                                     (times bool bool))
                         nil)
                        nil (abs x\x) bool).
#assert (typeof nil
                (match (cons (cst true) (cst false))
                  (cons (assoc (ptcons (ptcst true) hole) (abs x\ x))
                   nil))
                bool).

#assert (forall x, test 0 x => typeof nil x (arrow (times int bool) int)).
#assert (forall x, test 1 x => typeof nil x bool).

% This is derivable if you enable the last (looping) clause to typeof...
% #assert (forall x, test 0 x =>
%          typeof nil x (tyabs x\ tyabs y\ arrow (times x y) x)).

% }}}

% This one requires the polymorphic let
% #assert (forall x, test 2 x => typeof nil x bool).

% ----- Type inference
% Now we have to handle unification by ourselves,
% and generalize when possible...

% [subst T X V T'] expresses "T'=T[V/X]"
% It should work on types, type environments, type equations...

% It would be nice to say (nabla x, subst (F (var x)) X V (F' (var x)))
% but it's not Llambda... hence the list of bound variables.
subst BV A X V A := mem A BV.
subst BV (tyabs F) X V (tyabs F') :=
  nabla x, subst (cons x BV) (F x) X V (F' x).

subst BV (tyvar X) X V V.
subst BV (tyvar Y) X V (tyvar Y) := X=Y => false.

subst BV (tycst C) X V (tycst C).
subst BV (times A B) X V (times A' B') :=
  subst BV A X V A' /\
  subst BV B X V B'.
subst BV (arrow A B) X V (arrow A' B') :=
  subst BV A X V A' /\
  subst BV B X V B'.
subst BV nil X V nil.
subst BV (cons H L) X V (cons H' L') :=
  subst BV H X V H' /\
  subst BV L X V L'.
subst BV (assoc N B) X V (assoc N B') :=
  subst BV B X V B'.
subst BV (H+L) X V (H'+L') :=
  subst BV H X V H' /\
  subst BV L X V L'.
subst BV (A=B) X V (A'=B') :=
  subst BV A X V A' /\
  subst BV B X V B'.
subst BV (instantiate (A=B)) X V (instantiate (A'=B')) :=
  subst BV A X V A' /\
  subst BV B X V B'.
subst BV (type G M T) X V (type G' M T') :=
  subst BV G X V G' /\
  subst BV T X V T'.
subst BV (generalize G T Y) X V (generalize G' T' Y) :=
  subst BV G X V G' /\
  subst BV T X V T'.
subst BV (result T) X V (result T') :=
  subst BV T X V T'.

occurs X (tyvar X).
occurs X (arrow M N) := occurs X M \/ occurs X N.
occurs X (times M N) := occurs X M \/ occurs X N.
occurs X (tyabs M) := nabla x, occurs X (M x).

% List of free type variables in a (list of) types.
freetyvars (tyvar T) (cons T nil).
freetyvars (tycst C) nil.
freetyvars (arrow A B) L := freetyvars A LA /\ freetyvars B LB /\ concat LA LB L.
freetyvars (times A B) L := freetyvars A LA /\ freetyvars B LB /\ concat LA LB L.
freetyvars (tyabs F) L :=
  nabla x, exists LX,
    freetyvars (F (tyvar x)) LX /\ minus LX (cons x nil) L.

#assert (freetyvars
 (tyabs x\ tyabs y\ arrow (tyvar z) (arrow x (tyvar t)))
 (cons z (cons t nil))).

freetyvars nil nil.
freetyvars (cons A B) L := freetyvars A LA /\ freetyvars B LB /\ concat LA LB L.
freetyvars (assoc X T) L := freetyvars T L.

% Return the mgu for a list of constraints, which are either:
%  * equations over types:                         (T1=T2)
%  * equations between a type T and a schemata S:  (instantiate (S=T))
%  * typing judgements:                            (type G M T)
%  * generalization statements:                    (generalize G T X)

infer (abs L) (abs S) := nabla x, infer (L (tyvar x)) (S x).
% infer nil nil.
infer (result X) (result X).

% >>>>>>>>> Treat type unifications
% This never generates new (generic) variables.
% TODO occur-check (btw, is it needed in the absence of recursion ?)
infer ((tyvar V = T)+L) S := subst nil L V T L' /\ infer L' S.
infer ((T = tyvar V)+L) S :=
  (forall t, T = tyvar t => false) /\ % only for avoiding multiple successes
  subst nil L V T L' /\ infer L' S.
infer ((tycst C = tycst C)+L) S := infer L S.
infer ((times L1 L2 = times R1 R2)+L) S := infer ((L1=R1)+((L2=R2)+L)) S.
infer ((arrow L1 L2 = arrow R1 R2)+L) S := infer ((L1=R1)+((L2=R2)+L)) S.

% Before actually unifying types, type schemata should be instantiated
% with new existential variables.
infer ((instantiate (tyabs A = B))+L) (abs S) :=
  nabla x, infer ((instantiate (A (tyvar x) = B))+L) (S x).
infer ((instantiate (A=B))+L) S :=
  (forall x, tyabs x = A => false) /\ infer ((A=B)+L) S.

% >>>>>>>>> Treat typing judgements

infer ((type G (cst C) T)+L) S := cst_typeof C TC /\ infer ((T = tycst TC)+L) S.
infer ((type G (var V) T)+L) S :=
  mem (assoc V TV) G /\ infer ((instantiate (TV=T))+L) S.
infer ((type G (app M N) T)+L) (abs S) :=
  nabla t, infer ((type G N (tyvar t))+
                 ((type G M (arrow (tyvar t) T))+L))
                 (S t).
infer ((type G (abs M) T)+L) (abs t1\ abs t2\ S t1 t2) :=
  nabla t1 t2 x,
    infer ((T = arrow (tyvar t1) (tyvar t2))+
          ((type (cons (assoc x (tyvar t1)) G) (M (var x)) (tyvar t2))+L))
          (S t1 t2).
infer ((type G (cons A B) T)+L) (abs t1\ abs t2\ S t1 t2) :=
  nabla t1 t2,
    infer ((T = times (tyvar t1) (tyvar t2))+
          ((type G A (tyvar t1))+
          ((type G B (tyvar t2))+L)))
          (S t1 t2).
infer ((type G (let D B) T)+L) (abs t\ abs tgen\ S t tgen) :=
  nabla t tgen x,
    infer ((type G D (tyvar t))+
          ((generalize G (tyvar t) tgen)+
          ((type (cons (assoc x (tyvar tgen)) G) (B (var x)) T)+L)))
          (S t tgen).

% >>>>>>>>> Type generalization

infer ((generalize G T X)+L) S :=
  freetyvars T FVT /\
  freetyvars G FVG /\
  minus FVT FVG GV /\
  abstract_over GV T TG /\
  subst nil L X TG L' /\
  infer L' S.

abstract_over nil T T.
abstract_over (cons X VARS) T TG :=
  abstract_over VARS T T' /\
  (((occurs X T' => false) /\ TG=T') \/
   (occurs X T' /\ (nabla x, subst nil T' X x (T'' x)) /\ TG = tyabs T'')).

#assert (occurs x (arrow (tyvar x) (tycst bool))).
#assert (occurs y (arrow (tyvar x) (tycst bool)) => false).
#assert (abstract_over (cons x (cons y nil))
                       (arrow (tyvar x) (arrow (tyvar y) (tyvar x)))
                       (tyabs x\ tyabs y\ arrow x (arrow y x))).
#assert (abstract_over (cons x nil)
                       (arrow (tyvar x) (tyvar y))
                       (tyabs x\ arrow x (tyvar y))).

% Remove useless (existential) abstractions over the result.
gc (result X) X.
gc (abs I) O :=
  nabla x,
    gc (I x) (I' x) /\
    ((occurs x (I' x) /\ O = abs I') \/
     ((occurs x (I' x) => false) /\ O = I' x)).

itest N T S :=
  test_term N T /\ infer (abs x\ (type nil T x) + result x) S' /\
  gc S' S /\
  % Now evaluate the term, infer its type again and check consistency.
  eval nil T T' /\ infer (abs x\ (type nil T' x) + result x) S'' /\
  gc S'' S.

test_term 0 (cons (cst true) (cst false)).
test_term 1 (app (abs x\ x) (cst true)).
test_term 2 (let (cst true) (x\x)).
test_term 3 (let (abs x\ x) (x\x)).
test_term 4 (let (abs x\ abs y\ x) k\
              let (cst true) t\
               let (cst false) f\
                cons (app (app k t) f) (app (app k f) t)).
test_term 5 (let (abs x\ abs y\ x) k\
              let (cst true) t\
               let (cst 0) z\
                cons (app (app k t) z) (app (app k z) t)).

#assert (itest 0 N (times (tycst bool) (tycst bool))).
#assert (itest 1 N (tycst bool)).
#assert (itest 2 N (tycst bool)).
#assert (itest 3 N (abs x\ arrow (tyvar x) (tyvar x))).
#assert (itest 4 N (times (tycst bool) (tycst bool))).
#assert (itest 5 N (times (tycst bool) (tycst int))).
