%% A simple interpreter for the minimal logic of hereditary Harrop
%% formulas.

%% To use this intrepreter, you need to 
%%   #include "prv.def".
%% Then you need to pick a name of a binary predicate to use to store
%% clauses: first argument is the head and the second is the body.
%% Third, for every predicate, say, q, of the object-logic, insert the
%% declaration
%%     atom (q X Y Z).   <- the arity may vary, of course.
%% Fourth, call the goal  
%%     prv Prog Goal.
%% in order to attempt the proof of the Goal from the logic program 
%% encoded in Prog.

% Object logic is freely generated from 
%   tt, and, <- , -> , forall, exists

prv Prog B := seq Prog tt B.

% ?- seq Prog List Goal.
% Attempts to prove the Goal from the assumptions in List and 
% the logic programming clauses described by Prog. 

% Do right rules first.
seq Prog L tt.
seq Prog L (and B C)  := seq Prog L B, seq Prog L C.
seq Prog L (G <- D)   := seq Prog (and D L) G.
seq Prog L (D -> G)   := seq Prog (and D L) G.
seq Prog L (forall B) := nabla x\ seq Prog L (B x).
seq Prog L (exists B) := sigma x\ seq Prog L (B x).

% Pick a formula on which to backchain.
seq Prog L A := atom A, (bc Prog L L A; (Prog A Body, seq Prog L Body)).

% Backchaining is done in a focused fashion.
bc Prog L A A.
bc Prog L (and X Y)  A := bc Prog L X A ; bc Prog L Y A.
bc Prog L (G <- D)   A := bc Prog L G A, seq Prog L D.
bc Prog L (D -> G)   A := bc Prog L G A, seq Prog L D.
bc Prog L (forall D) A := sigma t\ bc Prog L (D t) A.

% Simple union of two binary relations.  These can be used to 
% join together two logic programming specifications.

orelse P Q X Y := P X Y ; Q X Y.

%% Examples:

% Appending of two lists
atom (append X Y Z).
exprog (append nil L L) tt.
exprog (append (cons X L) K (cons X M)) (append L K M).

% Specification of simply typing inference for untyped lambda-calculus.
atom (typeof X Y).
infer (typeof (app M N) B)
      (exists A\ and (typeof M (arrow A B)) (typeof N A)).
infer (typeof (abs R) (arrow A B))
      (forall x\ (typeof x A) -> (typeof (R x) B)).

% If you want to form the union of these two "logic programs", 
% use either
%    (orelse exprog infer)
% or the lambda-expression
%    (x\y\ exprog x y ; infer x y)
% as the first argument of prv and seq.
