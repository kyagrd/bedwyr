% An example from Kaustuv, with some modifications.

Kind nt     type.
Type z      nt.
Type s      nt -> nt.

Kind bool   type.
Type tt,ff  bool.

Kind exp type -> type.
Type nat_exp  nt  -> exp nt.

Type bool_exp bool -> exp bool.
Type if_exp   exp bool -> exp A -> exp A -> exp A.

Define eval : exp A -> A -> prop by
  eval (nat_exp N) N ;
  eval (bool_exp B) B ;
  eval (if_exp I T E) V := (eval I tt /\ eval T V) \/ (eval I ff /\ eval E V).

Kind list   type -> type.
Type nil    list A.
Type :::    A -> list A -> list A.

% The polymorphic member predicate is as usual.
Define member : A -> list A -> prop by
  member X (X ::: L) ;
  member X (Y ::: L) := member X L.

% Example queries:
%
%   ?= member 1 (1 ::: nil) /\ member "a" ("a" ::: nil).
%   Yes.
%   More [y] ?
%   No more solutions.
%   ?= member 1 (1 ::: "a" ::: nil).
%   At line 2, characters 17-19:
%   Typing error: this expression has type string but is used as
%   nat.
%   ?= forall (x : exp), member x (x ::: X).
%   At line 1, character 9:
%   Kinding error: the type constructor exp has kind
%   * -> * but is used as *.
%   ?= 

% These are just to test the parser and the kind/type checking.
Kind map    type -> type -> type.
Type empty  map K D.
Type add    K -> D -> map K D -> map K D.
