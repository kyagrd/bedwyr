% Specification of late pi-calculus and strong bisimulation
% 
% Please refer to the following paper for background:
%
% Alwen Tiu and Dale Miller. A proof search specification of 
% the pi-calculus. Proceedings of FGUC04. 
% Available from http://www.loria.fr/~tiu

% bound input
onep (in X M) (dn X) M.

% free output
one (out X Y P) (up X Y) P.

% tau 
one  (taup P) tau P.

% match prefix
one  (match X X P) A Q := one P A Q.
onep (match X X P) A M := onep P A M.

% sum
one  (plus P Q) A R := one  P A R.
one  (plus P Q) A R := one  Q A R.
onep (plus P Q) A M := onep P A M.
onep (plus P Q) A M := onep Q A M.

% par
one  (par P Q) A (par P1 Q) := one P A P1.
one  (par P Q) A (par P Q1) := one Q A Q1.
onep (par P Q) A (x\par (M x) Q) := onep P A M.
onep (par P Q) A (x\par P (N x)) := onep Q A N.

% restriction
one  (nu x\P x) A (nu x\Q x)      := nabla x\ one  (P x) A (Q x).
onep (nu x\P x) A (y\ nu x\Q x y) := nabla x\ onep (P x) A (y\ Q x y).

% open 
onep (nu x\M x) (up X) N := nabla y\ one (M y) (up X y) (N y).

% close
one (par P Q) tau (nu y\ par (M y) (N y)) :=
  sigma X\ onep P (dn X) M & onep Q (up X) N.
one (par P Q) tau (nu y\ par (M y) (N y)) :=
  sigma X\ onep P (up X) M & onep Q (dn X) N.

% comm
one (par P Q) tau (par R T) :=
  sigma X\ sigma Y\ sigma M\ onep P (dn X) M & one Q (up X Y) T & (R = (M Y)).
one (par P Q) tau (par R T) :=
  sigma X\ sigma Y\ sigma M\ onep Q (dn X) M & one P (up X Y) R & (T = (M Y)).

% Rep-act
one  (bang P) A (par P1 (bang P)) := one P A P1.
onep (bang P) X (y\ par (M y) (bang P)) := onep P X M.

% Rep-com
one (bang P) tau (par (par R T) (bang P)) :=
  sigma X\ sigma Y\ sigma M\ onep P (dn X) M & one P (up X Y) R & (T = (M Y)).

% Rep-close
one (bang P) tau (par (nu y\ par (M y) (N y)) (bang P)) := 
  sigma X\ onep P (up X) M & onep P (dn X) N.

     
% Simulation and bisimulation

sim P Q := 
	(pi A\ pi P1\ one P A P1 => sigma Q1\ one Q A Q1 & sim P1 Q1) &
	(pi X\ pi M\ onep P (dn X) M => sigma N\ onep Q (dn X) N & 
					pi w\ sim (M w) (N w)) &
	(pi X\ pi M\ onep P (up X) M => sigma N\ onep Q (up X) N &
					nabla w\ sim (M w) (N w)).

bisim P Q :=
	(pi A\ pi P1\ one P A P1 => sigma Q1\ one Q A Q1 & bisim P1 Q1) &
	(pi X\ pi M\ onep P (dn X) M => sigma N\ onep Q (dn X) N & 
					pi w\ bisim (M w) (N w)) &
	(pi X\ pi M\ onep P (up X) M => sigma N\ onep Q (up X) N &
					nabla w\ bisim (M w) (N w)) &
	(pi A\ pi Q1\ one Q A Q1 => sigma P1\ one P A P1 & bisim Q1 P1) &
	(pi X\ pi N\ onep Q (dn X) N => sigma M\ onep P (dn X) M & 
					pi w\ bisim (N w) (M w)) &
	(pi X\ pi N\ onep Q (up X) N => sigma M\ onep P (up X) M &
					nabla w\ bisim (N w) (M w)).

% A few example processes -- see the paper for a few checks on them ===========

example 0  (nu x\ match x a (taup z)).
example 1  (par (in x y\z) (out x a z)).
example 2  (plus (in x y\out x a) (out x a (in x y\z))).
example 3  (in x u\ (plus (taup (taup z)) (taup z))).
example 4  (in x u\ (plus (taup (taup z))
                    (plus (taup z)
                          (taup (match u y (taup z)))))).
example 5  (nu a\ (par (in x y\z) (out x a z))).
example 6  (nu a\ (plus (in x y\out x a) (out x a (in x y\z)))).
example 7  (taup z).
example 8  (nu x\ (par (in x y\z) (out x a z))).
example 9  (nu x\ out a x z).
example 10 (par (in x y\ z) (nu y\ out x y z)).
example 11 (in x u\ nu y\ ((plus (taup (taup z))
                           (plus (taup z)
                                 (taup (match u y (taup z))))))).
example 12 (bang P) := example 1 P.

% Weak bisimulation ===========================================================

taus P QQ := one P tau Q, taus Q QQ.
taus P P.

maxtaus P QQ := one P tau Q, maxtaus Q QQ.
maxtaus P P  := pi Q\ one P tau Q => false.

weak_one Q (up X Y) P := taus Q QQ, one QQ A PP, taus PP P.
weak_one Q tau QQ     := taus Q QQ.

weak_onep Q (up X) P :=
  taus Q QQ, onep QQ (up X) PP, nabla x\ taus (PP x) (P x).
weak_onep Q (dn X) P :=
  taus Q QQ, onep QQ (dn X) PP, nabla x\ taus (PP x) (P x). % pi -> not llam

weak_sim P Q :=
  pi A\ pi X\ pi M\
    (one  P A M      => sigma N\ weak_one  Q A N,
                                 weak_sim M N),
    (onep P (dn X) M => sigma N\ weak_onep Q (dn X) N,
                          pi w\ weak_sim (M w) (N w)),
    (onep P (up X) M => sigma N\ weak_onep Q (up X) N,
                          nabla w\ weak_sim (M w) (N w)).

weak_bisim P Q :=
	(pi A\ pi P1\ one P A P1 =>
           sigma Q1\ weak_one Q A Q1 & weak_bisim P1 Q1) &

	(pi X\ pi M\ onep P (dn X) M => sigma N\ weak_onep Q (dn X) N & 
					pi w\ weak_bisim (M w) (N w)) &

	(pi X\ pi M\ onep P (up X) M => sigma N\ weak_onep Q (up X) N &
					nabla w\ weak_bisim (M w) (N w)) &

	(pi A\ pi Q1\ one Q A Q1 =>
           sigma P1\ weak_one P A P1 & weak_bisim Q1 P1) &

	(pi X\ pi N\ onep Q (dn X) N => sigma M\ weak_onep P (dn X) M & 
					pi w\ weak_bisim (N w) (M w)) &

	(pi X\ pi N\ onep Q (up X) N => sigma M\ weak_onep P (up X) M &
					nabla w\ weak_bisim (N w) (M w)).

% Computing weak traces (for debugging and efficiency evaluation)

_weak_trace P (do A T) := one P A Q, (A = tau => false),
                          weak_trace Q T.
_weak_trace P (do A T) := onep P A Q,
                          nabla x\ weak_trace (Q x) (T x).
_weak_trace P nil      := pi A\ pi Q\ (one P A Q ; onep P A Q) => false.
weak_trace P T         := maxtaus P PP, _weak_trace PP T.

% Remark: maxtaus doesn't deal with interleaving and generate redundancy.
% TIME/poum: 928ms for the first solution, +1370ms for the second one, etc.
% Remark: it is SLOW...
trtest 0 T := weak_trace (par (par (taup z) (taup z))
                              (par (taup z) (out c c z))) T.

% The following is a kind of simplified inlined version of the (trtest 0)
% which is already unreasonably long to compute
% TIME/poum: 879ms for the first solution, 1200ms for the second, etc.
intest 0 T := P = (par (par (taup z) (taup z))
                       (par (taup z) (out c c z))),
              maxtaus P PP, one PP A QQ, maxtaus QQ Q,
              (pi X\ pi Y\  one Q X Y => false),
              (pi X\ pi Y\ onep Q X Y => false),
              (pi X\ pi Y\ (one Q X Y ; onep Q X Y) => false).

% TIME/poum: 1158ms
trtest 1 T := weak_trace (nat (s zz) c) T.

% TIME/poum: 23.969s
trtest 2 T :=
  weak_trace (nu x\ nu y\ par (par (nat (s zz) x) (nat zz y)) (add x y c)) T.

% Remark: it is easy to fall outside llambda for a bad reason:
% nabla x\ pi h\ one (nu y\ out h z z) (A h) Q.
% Remove the useless nabla and it works again (TIME/poum=14ms)...

% Natural numbers in pi, using recursive agents -------------------------------

one  P A PP := agent P Body, one  Body A PP.
onep P A PP := agent P Body, onep Body A PP.

agent (zero C)    (in C s\ in C n\ out n nil z).
agent (succ P C)  (in C s\ in C n\ out s P z).
agent (add P Q R) (nu s\ nu n\ out P s (out P n
                    (in R ss\ in R nn\
                      (plus (in s k\ nu kk\ (par (out ss kk z) (add k Q kk)))
                            (in n nil\ out Q ss (out Q nn z)))))).
 
agent (nat (s N) C) (in C s\ in C zz\ nu n\ par (out s n z) (nat N n)).
agent (nat zz    C) (zero C).

agent (explicit_2 C) (in C s\ in C zz\ nu un\
                        par (out s un z)
                            (in un s\ in un zz\(nu zero\ 
                               (par (out s zero z)
                                    (in zero s\ in zero zz\ out zz nil z))))).
agent (explicit_1 C)      (in C s\ in C zz\
                               (nu zero\ par (out s zero z)
                                    (in zero s\ in zero zz\ out zz nil z))).

% Tests about simulations (the third one has several solutions)
stest 0 := weak_sim (nat (s zz) c) (nat (s zz) c).         % TIME/poum=1213ms
stest 1 := weak_sim (nat (s (s zz)) c) (nat (s (s zz)) c). % TIME/poum=3026ms
stest 2 := weak_sim (nat (s zz) c)
                    (nu x\ nu y\ par (par (nat zz x) (nat (s zz) y))
                                     (add x y c)).         % TIME/poum=5753ms

% Tests about bisimulations
natest 0 := weak_bisim (nu u\ nu d\ (par (nat zz u)
                                    (par (nat zz d)
                                         (add u d t))))
                       (nat zz t).                         % TIME/poum=45.8s
natest 1 := weak_bisim (nu u\ nu d\ (par (nat zz u)
                                    (par (nat (s zz) d)
                                         (add u d t))))
                       (nat (s zz) t).                     % TIME/poum=532s
% passed !?
natest 2 := weak_bisim (nu u\ nu d\ (par (nat (s (s zz)) d)
                                    (par (nat (s (s (s zz))) u)
                                         (add u d t))))
                       (nat (s (s (s (s (s zz))))) t).

notest 0 := weak_bisim (nu u\ nu d\ (par (nat (s zz) d)
                                    (par (nat (s zz) u)
                                         (add u d t))))
                       (nat (s zz) t).
