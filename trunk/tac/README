===============================================================================

Tac

===============================================================================

Tac System:

  Tac is made up of several subprojects, each in their own directory.  They
  are:
    taci:
      The command-line interface.

    logics_gen:
      A code generator that eases the addition of new logics to taci.

    StickyTaci:
      A relatively simple C#/WinForms interface to taci.  Currently
      StickyTaci only works under Windows XP.  It can be compiled in
      Linux using Mono, but the resulting executable does not run correctly
      due to incompatibilities between Mono's implementation of WinForms and
      Micorosoft's.

    Stekki:
      A rough OCaml/Tk interface to taci.  Though it is simple it is still
      nicer to work with than taci.  Currently Stekki only works under Linux.
      It can be compiled in Windows XP, but the resulting executable does not
      run correctly due to the way it interacts with taci using Unix pipes.

    ndcore:
      A mostly-functional term library.  The ndcore library is contained
      within the Bedwyr project.
      
    tools:
      A few tools for manipulating proofs.

Building Tac:

  See "/tac/INSTALL" for information on building Tac on Windows and Linux.

Using Tac:

  Taci is a command-line tool that allows you to interactively build proofs in
  various logics. You can get the list of available logics using --logics:

    tac $ taci/taci --logics

  Propositional logic is a very simple classical propositional logic with only
  atoms; it's not very interesting. Firstorder, muLJ and their variations
  are first-order logics, featuring higher-order terms, nabla and fixed points.
  The muLJ* logics are intuitionistic while firstorder* are classical. The
  *-nonstrict variations are slightly sloppier than LINC when checking the axiom
  rule: they do not check for generic context equality, but since variables are
  represented by indices which cannot be renumbered it's still fairly far from
  LG.

  Let's start taci on muLJ. You should get something like:

    tac $ taci/taci --logic muLJ

    Mu-LJ with Strict Nabla

  Try the following:

    [tac <muLJ>]- #define "nat x := (x=o);(sigma y\ (x=(s y),(nat y)))".
    Definition: inductive (nat x\ ((x = o); sigma y\ ((x = (s y)), nat y))).
    [tac <muLJ>]- #theorem my_theorem "pi x\ nat x => nat (s x)".

    --------------------------
    pi x\ (nat x => nat (s x))
    [tac <muLJ>]- pi_r.

    --------------------
    (nat x => nat (s x))

  Then you can type in "imp_r." to introduce the implication.
  Then, type "#undo." twice, and you should come back at the first step. Type
  "simplify." and the universal quantification as well as the implication will
  get introduced in one step. You can now unfold nat on the right ("mu_r"),
  choose the right of the disjunction ("right"), introduce the existential and
  split the conjunction ("then(sigma_r,and_r)"). You get two goals. You can
  finish the first one using "eq_r", the second one using "axiom".

  Exit using "#exit."

  You can find more definitions and proof scripts in "/tac/examples". The example
  files are no  more than a sequence of taci inputs. They can be conveniently used
  from the graphical interfaces, which allow loading/saving and undo/redo in a more
  natural way.
