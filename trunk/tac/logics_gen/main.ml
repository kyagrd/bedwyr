(*****************************************************************************
* Logics_gen                                                                 *
* Copyright (C) 2007-2008 Zach Snow                                          *
*                                                                            *
* This program is free software; you can redistribute it and/or modify       *
* it under the terms of the GNU General Public License as published by       *
* the Free Software Foundation; either version 2 of the License, or          *
* (at your option) any later version.                                        *
*                                                                            *
* This program is distributed in the hope that it will be useful,            *
* but WITHOUT ANY WARRANTY; without even the implied warranty of             *
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
* GNU General Public License for more details.                               *
*                                                                            *
* You should have received a copy of the GNU General Public License          *
* along with this code; if not, write to the Free Software Foundation,       *
* Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA               *
*****************************************************************************)
let inFilename = ref ""
let outModuleName = ref ""

let version = "1.0.0"
let printVersion () =
  (print_endline ("logics_gen version " ^ version ^ ".");
  exit 0)

(**********************************************************************
*parseArgs:
* Handles parsing of command line options; both --input and --output
* are required, the other options exit after printing information.
**********************************************************************)
let rec printHelp () = (Arg.usage speclist usage; exit 0)
and speclist = [("-help", Arg.Unit(printHelp), "");
                ("--help", Arg.Unit(printHelp), "print usage information");
                ("--input", Arg.Set_string(inFilename), "input file");
                ("--output", Arg.Set_string(outModuleName), "output module");
                ("-v", Arg.Unit(printVersion), "print version information");
                ("--version", Arg.Unit(printVersion), "print version information")]
and usage = "Usage: logics_gen --input \"input filename\" --output \"output filename\" \n\nOptions:"
let parseArgs output =
    (Arg.parse speclist (fun s -> ()) usage)

let currentId = ref 0
let generate () =
  let s = "Gen_" ^ (string_of_int (!currentId)) in
  let () = currentId := !currentId + 1 in
  s

(**********************************************************************
*parse:
* Parse an input file into a list of outputs and logics.
**********************************************************************)
let parse infile =
  let inchannel = open_in infile in
  let lexbuf = Lexing.from_channel inchannel in
  try
    let result = (Parser.toplevel_file Lexer.command lexbuf) in
    let (os,ls) = result in
    if (List.length os = 0) then
      (print_endline "Error: no outputs specified.";
      None)
    else if  (List.length ls = 0) then
      (print_endline "Error: no logics specified.";
      None)
    else
      Some result
  with
    Parsing.Parse_error -> (None)

(**********************************************************************
*outputModule:
* Given a list of outputs and a list of logics, basically computes the
* cartesian product of the two lists.  The result is the code for the
* mli and ml file corresponding to instantiating every combination of
* logic and output and putting the relevant functions of these modules
* into a table.
**********************************************************************)
let outputModule outputs logics =
  let interpMake = "Interpreter.Make" in
  let interfaceMake = "Interface.Make" in
  let outputName o = "O" ^ o in
  let makeLogic (Absyn.Output(oname, outputmod)) (Absyn.Logic(logicname,logicmod)) =
    let outputname = outputName oname in
    let arg n = "(" ^ n ^ ")" in
    let name = generate () in
    let interpname = name ^ "Interpreter" in
    let interfacename = name ^ "Interface" in
    
    let header =
      "  let module " ^ name ^ " = " ^ logicmod ^ (arg outputname) ^ " in\n" ^
      "  let module " ^ interpname ^ " = " ^ interpMake ^ (arg outputname) ^ (arg name) ^ " in\n" ^
      "  let module " ^ interfacename ^ " = " ^ interfaceMake ^ (arg interpname) ^ " in\n\n"
    in
    
    let table =
      "(\"" ^ logicname ^ "\", (" ^ name ^ ".name, " ^ interfacename ^ ".interpret))"
    in
    (header, table)
  in
  
  let makeOutput logics output =
    (output, (List.map (makeLogic output) logics))
  in
  
  let outputMLI=
    "(* This file was generated by logics_gen, part of the Tac system.  *)\n" ^
    "val tables : (string * (string * (string * ((string * string) list -> unit))) list) list\n"
  in
  
  let outputTableName name =
    name ^ "Table"
  in

  let outputMLHeader ((Absyn.Output(name,omod)), logics) =
    let outputLogicHeader (header,_) =
      header
    in
    
    let outputLogicTable (_,table) =
      table
    in
    
    let outputTable logics = 
      "  [" ^ (String.concat ";\n  " (List.map outputLogicTable logics)) ^ "]"
    in
    
    let outtable = outputTableName name in
    "let " ^ outtable ^ " =\n" ^
    "  let module " ^ (outputName name) ^ " = " ^ omod ^ " in\n\n" ^
    (String.concat "\n" (List.map outputLogicHeader logics)) ^ "\n" ^
    (outputTable logics) ^ "\n\n"
  in
  
  let outputMLTable outputs =
    let outputTable (Absyn.Output(name,_)) =
      "(\"" ^ name ^ "\", " ^ (outputTableName name) ^ ")"
    in
    "let tables = [" ^ (String.concat "; " (List.map outputTable outputs)) ^ "]\n"
  in
  
  let outtable = (List.map (makeOutput logics) outputs) in
  let mli = outputMLI in
  let ml = (String.concat "\n\n" (List.map outputMLHeader outtable)) ^ (outputMLTable outputs) in
  let ml' = "(* This file was generated by logics_gen, part of the Tac system.  *)\n" ^ ml in
  (mli,ml')
  
let main () =
  let () = parseArgs () in
  
  if !inFilename = "" then
    (print_endline "Error: no input file specified.";
    (-1))
  else if !outModuleName = "" then
    (print_endline "Error: no output file specified.";
    (-1))
  else
    let result = parse !inFilename in
    match result with
      Some(outputs, logics) ->
        (try
          let (mli,ml) = (outputModule outputs logics) in
          let mlioutfile = open_out (!outModuleName ^ ".mli") in
          let () = output_string mlioutfile mli in
          let () = close_out mlioutfile in
          let mloutfile = open_out (!outModuleName ^ ".ml") in
          let () = output_string mloutfile ml in
          let () = close_out mloutfile in
          (print_endline "Done.";
          0)
        with
          _ -> (print_endline "Error: unhandled exception."; (-1)))
    | None ->
        (print_endline "Error: unable to parse input.";
        (-1))

(*  Entrypoint. *)
let () = exit (main ())
