

                      Minimal generic quantification in Taci

                                 David Baelde

Contents:
  I. Commented list of examples
 II. How to use a very experimental tool

I. Commented list of examples
=============================

Examples of interest here:

 * examples/ho_simple.muLJ.tac:
     Simple examples to get used to the system. One might at first be surprised
     by the invariants used there, but they eventually make sense. Better: they 
     are automatically generated by the "prove" tactic, which is not specially 
     designed for nabla but makes use of general techniques for fixed points.

 * examples/copy.muLJ.tac:
     A simple striking example, where the induction is used to establish an 
     unusual property of the generic context in that case: two variables can be 
     merged. This leads to a very concise proof.

 * examples/lift-oddity.muLJ.tac:
     The unfortunate aspect of the lifting approach: it does not commute with 
     unfolding. This means that the correspondency between the original and the
     abstracted-out nabla is only up-to name re-ordering -- which is logically 
     sound.

 * examples/lambda/lemmas.muLJ.tac:
     Some lemmas about simply typed lambda calculus, as specified in 
     examples/lambda/definitions.def. They are mostly automatically proved.
     Notice here that not only are the simple weakening/strengthening lemmas
     automatically derived, their enriched version (bind_ww, bind_www) are
     also easily proved automatically.

 * examples/lambda/typedet.muLJ.tac:
     A proof of type determinacy for the "traditional" specification of simply 
     typed lambda calculus found in examples/lambda/definitions.def.
     It makes use of an unusual strong invariant.

 * examples/lambda/subred.muLJ.tac:
     Subject reduction for simply typed lambda calculus as specified in 
     examples/lambda/definitions.defs.

 * examples/lambda/named-style-failure.muLJ.tac:
     Proofs of type determinacy and almost subject reduction for an alternative 
     specification of simply typed lambda calculus. This is an experiment with 
     an unusual style, which mostly shows its weaknesses for now.

II. How to use lifting in taci
==============================

The "abstract" tactic implements lifting. It still has a few unfriendly
issues:

 * Lifting is not automatically done as in the theoretical presentation of the 
   logic. It has to be done explicitely by calling the tactic "abstract".
   It, however, done implicitly by the "prove" and "apply" tactics.

 * The lift_* predicate names do not exist: these names are displayed for 
   convenience, but you can't type them in. The system would understand that as 
   an atom. If you want to refer to a lifted version of a predicate, type in 
   some nabla quantifications, and abstract the result explicitly.

 * The lift_* predicate names matter, in that equality of fixed points (on 
   which the initial rule is built) relies on names and does not compare the 
   fixed points' bodies. It's the users' duty to not introduce a predicate that 
   would conflict with these.

Keep in mind other general difficulties of our approach, that are
sometimes visible in our current implementation:

 * Taci works at the very low level of sequent calculus rules. This can often 
   be hidden by using compound tactics like simplify, async or prove. But 
   sometimes, you might have to do some low-level work by hand.
   The good side of this is that taci actually builds a sequent calculus
   proof from your input, providing a witness for the success.
 
 * Most other issues have disappeared, hopefully. But don't hesitate
   to report bugs and oddities if you see any: this is still a beta version.
