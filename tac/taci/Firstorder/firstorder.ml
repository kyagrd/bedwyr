(**********************************************************************
* Taci                                                                *
* Copyright (C) 2007 Zach Snow, David Baelde                          *
*                                                                     *
* This program is free software; you can redistribute it and/or modify*
* it under the terms of the GNU General Public License as published by*
* the Free Software Foundation; either version 2 of the License, or   *
* (at your option) any later version.                                 *
*                                                                     *
* This program is distributed in the hope that it will be useful,     *
* but WITHOUT ANY WARRANTY; without even the implied warranty of      *
* MERCHANTABILITY or FITNESS FOR A PARTICUFOAR PURPOSE.  See the      *
* GNU General Public License for more details.                        *
*                                                                     *
* You should have received a copy of the GNU General Public License   *
* along with this code; if not, write to the Free Software Foundation,*
* Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA        *
**********************************************************************)
let () = Properties.setBool "firstorder.proofsearchdebug" true
let () = Properties.setBool "firstorder.debug" true

(**********************************************************************
*ParamSig:
* Acts as a parameter to Firstorder in order to change properties of
* the logic generated by Firstorder.
**********************************************************************)
module type ParamSig =
sig
  (** The print name of the logic. *)
  val name : string

  (** Determines whether or not strict nabla comparisons are used in the
    * axiom rule. *)
  val strictNabla : bool
  
  (** Indicates whether the logic is intuitionistic instead of classical. *)
  val intuitionistic : bool
end

(**********************************************************************
*Firstorder:
* Implements a simple first order logic.  The logic includes equality
* and fixed points, with a definition-like facility to handle them.
**********************************************************************)
module Firstorder (Param : ParamSig) (O : Output.Output) : Logic.Logic =
struct
  module FOA = Firstorderabsyn
  exception NonMonotonic

  let name = Param.name
  let info = Param.name ^ "\n"
  let start = info
  
  (********************************************************************
  *Formula:
  * Represent formulae in sequents.  Formulae consist of a local
  * context level and an abstract syntax formula.
  ********************************************************************)
  type formula = Formula of (int * (FOA.annotation FOA.polarized))

  let string_of_polarity = function FOA.Positive -> "+" | FOA.Negative -> "-"
  let string_of_freezing = function FOA.Frozen -> "*" | FOA.Unfrozen -> ""
  let string_of_control =
    function FOA.Normal -> " " | FOA.Focused -> "# " | FOA.Delayed -> "? "

  let string_of_annotation ann formula =
    (string_of_control ann.FOA.control) ^
    (string_of_polarity ann.FOA.polarity) ^
    formula ^
    (string_of_freezing ann.FOA.freezing)

  let string_of_formula (Formula(local,(a,t))) =
    let generic = Term.get_dummy_names ~start:1 local "n" in
    let result = (FOA.string_of_formula ~generic).FOA.formf t in
      List.iter Term.free generic ;
      (String.concat "," generic) ^ ">> " ^ (string_of_annotation a result)

  let string_of_formula_ast (Formula(local,(a,t))) =
    let generic = Term.get_dummy_names ~start:1 local "n" in
    let result = (FOA.string_of_formula_ast ~generic).FOA.formf t in
      List.iter Term.free generic ;
      (String.concat "," generic) ^ ">> " ^ (string_of_annotation a result)

  let escapeTerm = Str.global_replace (Str.regexp "=>") "=&gt;"

  let xml_of_formula (Formula(local,(a,t))) = 
    let generic = Term.get_dummy_names ~start:1 local "n" in
    let result = escapeTerm ((FOA.string_of_formula ~generic).FOA.formf t) in
      List.iter Term.free generic ;
      Printf.sprintf "<formula>%s%s</formula>"
         (if generic = [] then "" else
           "<generic>" ^ String.concat "," generic ^ "</generic>")
        (string_of_annotation a result)
  
  let getFormulaFormula    (Formula(_,(_,f))) = f
  let getFormulaAnnotation (Formula(_,(a,_))) = a
  let getFormulaLevel      (Formula(i,(_,_))) = i
  let makeFormula t = Formula(0, t)
  
  (********************************************************************
  *Sequent:
  * A sequent has a left and right side, each a list of formulas, along
  * with an index approximating its signature (set of eigenvariables).
  ********************************************************************)
  type sequent = {
    lvl : int ;
    lhs : formula list ;
    rhs : formula list ;
    bound : int option
  }

  let updateBound = function
    | {bound = None} -> None
    | {bound = Some b} -> Some (b-1)

  let string_of_sequent seq =
    let top       = String.concat "\n" (List.map string_of_formula seq.lhs) in
    let bottom    = String.concat "\n" (List.map string_of_formula seq.rhs) in
    let separator = String.make (max (min (String.length bottom) 72) 16) '-' in
      Printf.sprintf "%s\n%d: %s\n%s" top seq.lvl separator bottom

  let ppxml_sequent fmt seq =
    let print_side side forms =
      Format.fprintf fmt "<%s>@," side ;
      List.iter (fun f -> Format.fprintf fmt "%s@," (xml_of_formula f)) forms ;
      Format.fprintf fmt "</%s>" side
    in
      Format.fprintf fmt "@[<><sequent><level>%d</level>@,@[<hov 2>" seq.lvl ;
      print_side "lhs" seq.lhs ;
      Format.fprintf fmt "@," ;
      print_side "rhs" seq.rhs ;
      Format.fprintf fmt "@]</sequent>@]"

  let xml_of_sequent seq =
    ppxml_sequent Format.str_formatter seq ; Format.flush_str_formatter ()

  let string_of_sequent_rhs seq =
    let bottom    = String.concat "\n" (List.map string_of_formula seq.rhs) in
    let separator = String.make (max (min (String.length bottom) 72) 16) '-' in
      Printf.sprintf "%d: %s\n%s" seq.lvl separator bottom

  let out_of_bound = function
    | None -> false
    | Some b -> b < 0

  (********************************************************************
  *Proof:
  ********************************************************************)
  type proof = {
    rule : string;
    formula : formula option;
    sequent : sequent;
    params : (string * string) list;
    bindings : Term.term list;
    subs : proof list
  }

  type lemma = string * formula * proof
  
  (********************************************************************
  *Session:
  * A session is:
  *   tactical table
  *   definition table
  *   sequents
  *   proof builder
  *   undo info
  *   redo info
  *   lemmas
  ********************************************************************)  
  type session = {
    tactics :
      (session, (sequent, proof) Logic.tactic) Logic.tactical Logic.table ;
    definitions : (FOA.annotation FOA.definition) Logic.table ;
    sequents : sequent list ; (* current goals *)
    builder : proof Logic.proofbuilder ;
    state : Term.state ;
    diff : Term.subst ;
    initial_namespace : Term.namespace ;
    proof_namespace   : Term.namespace ;
    theorem_name : string option ;
    theorem : (FOA.annotation FOA.polarized) option ;
    lemmas : lemma list
  }

  let dummy_session = {
    tactics = Logic.Table.empty ; definitions = Logic.Table.empty ;
    sequents = [] ; builder = (fun _ -> assert false) ;
    state = Term.save_state () ; diff = Term.get_subst (Term.save_state ()) ;
    initial_namespace = Term.save_namespace () ;
    proof_namespace = Term.save_namespace () ;
    theorem_name = None ;
    theorem = None ;
    lemmas = []
  }

  let sequents session = session.sequents
  let validSequent session = [] <> session.sequents

  let tacticals session = session.tactics
  let defineTactical name tac session =
    let ts = session.tactics in
    let ts' = Logic.Table.add name tac ts in
      { session with tactics = ts' }

  let proof session = session.builder

  let undo session =
    Term.restore_state session.state ;
    Term.restore_namespace session.proof_namespace ;
    session

  let redo session =
    (* The idea would be to use the diff field to redo,
     * but this is actually unused and not implemented. *)
    assert false

  (** Updating to new sequents and proof builders.
    * This has to come with the storage of the current state,
    * used when coming back to that point by undoing. *)
  let update sequents builder session =
    let state = Term.save_state () in
    let subst = Term.get_subst state in
      { session with state = state ; diff = subst ;
                     proof_namespace = Term.save_namespace () ;
                     sequents = sequents ; builder = builder }

  let rec string_of_proof proof =
    let s = Printf.sprintf "<rule><name>%s</name>\n" proof.rule in
    let p =
      List.map
        (fun (k,v) -> Printf.sprintf "<key>%s</key><value>%s</value>\n" k v)
        proof.params
    in
    let s = List.fold_left (^) s p in
    let s =
      s ^ xml_of_sequent proof.sequent
    in
    let s = match proof.formula with
      | None -> s
      | Some f -> s ^ xml_of_formula f
    in
    let s =
      s ^ "<bound>" ^
      String.concat " " (List.map Pprint.term_to_string proof.bindings)
      ^ "</bound>"
    in
    let proofs = List.map string_of_proof proof.subs in
      (* Allow the re-use of variables' names in other branches. *)
      (* List.iter
        (fun b ->
           if match Term.observe b with Term.Var _ -> true | _ -> false then
             Term.free (Term.get_name b)
           (* else we should be smart and free some subvars but not all *))
        proof.bindings ; *)
      List.iter (fun b -> Term.free (Term.get_name b))
        (Term.get_vars (fun _ -> true) proof.bindings) ;
      s ^ "<sub>" ^ List.fold_left (^) "" proofs ^ "</sub>\n</rule>\n"

  let string_of_proofs session =
    Term.restore_namespace session.proof_namespace ;
    let proofs = List.map string_of_proof (session.builder []) in
      String.concat "" proofs

  (** This is called by the interface to print the currently open leafs.
    * The sequent is printed from within a namespace which has only the
    * constants defined in the theorem's statement (one doesn't want to observe
    * the effects of invisible logic or eigen-variables) and the namespace
    * is left in the state after that printing, so that the next input
    * can rely on what has been displayed. *)
  let string_of_sequents session =
    let sequents = session.sequents in
      (* Term.restore_namespace session.proof_namespace  ; *)
      match sequents with
        | [] -> ""
        | mainseq::seqs ->
            if [] <> seqs then
              (string_of_sequent mainseq)
              ^ "\n\n" ^
              (String.concat "\n\n" (List.map string_of_sequent_rhs seqs))
              ^ "\n"
            else
              (string_of_sequent mainseq) ^ "\n"

  (********************************************************************
  *incl:
  * Given a list of files, include all definitions in them.  This is
  * not implemented.
  ********************************************************************)
  let incl files session =
    O.error "'#include.' not implemented.\n";
    session

  (********************************************************************
  *parseTerm:
  * Parses the argument into a term using the ocamlyacc grammar (see
  * firstorderparser.mly).  If successful, returns Some with the parsed
  * term, otherwise it returns None.
  ********************************************************************)
  let parseTerm t =
    try
      let term =
        Firstorderparser.toplevel_term
          Firstorderlexer.token (Lexing.from_string t)
      in
        Some term
    with
      | FOA.SyntaxError(s) ->
          O.error (s ^ ".\n");
          None

  let generateSymbol =
    let currentId = ref (-1) in
      fun () ->
        incr currentId ;
        ("_" ^ (string_of_int !currentId))

  (********************************************************************
  *replaceApplications:
  * Replaces applications in a formula with the correct definition,
  * if one exists.  If the application doesn't have the correct number
  * of arguments (relative to the body of the definition) then new
  * arguments are created to bring the number up to the correct amount,
  * and abstractions are inserted.  If the atom being replaced is under
  * any abstractions, the body of the definition that is being inserted
  * must be abstracted the same number of times as the atom is under
  * abstractions.
  ********************************************************************)
  let replaceApplications defs =
    (******************************************************************
    *makeArgs:
    * Generates a list of new names of length i.  This is only used
    * if the incorrect number of arguments were applied to a definition,
    * for example if using the body of definition as an invariant.
    ******************************************************************)
    let rec makeArgs i =
      if i = 0 then
        []
      else
        (generateSymbol ()) :: makeArgs (i - 1)
    in
    
    (******************************************************************
    *abstractReplacement:
    * Abstracts the body of the definition so that it is under the
    * same number of abstractions as the atom being replaced was.
    ******************************************************************)
    let abstractReplacement lambdas f =
      List.fold_left (fun f _ -> (FOA.abstractDummyWithoutLambdas ()).FOA.predf f) f lambdas
    in
    
    (******************************************************************
    *makeAbstractions:
    * Used to abstract the body of a definition over the new arguments;
    * used in the case that too few arguments are passed to the
    * definition.
    ******************************************************************)
    let rec makeAbstractions args formula =
      match args with
        [] -> formula
      | a::aa -> (FOA.abstractWithoutLambdas a ()).FOA.formf (makeAbstractions aa formula)
    in

    let tf t = t in
    let rec ff lambdas =   
      {(FOA.mapPatternToFormula (fun n l -> n::l) ff tf lambdas) with 
        FOA.predp = fun f args ->
          match f with
            FOA.AtomicPattern(head) ->
              let def = Logic.find head defs in
              if (Option.isSome def) then
                let def = (Option.get def) in
                let arity = FOA.getDefinitionArity def in
                let body = FOA.predicateofDefinition def in
                  if (arity = List.length args) then  (*  Correct number of arguments.  *)
                    FOA.ApplicationFormula(abstractReplacement lambdas body, args)
                  else if arity > List.length args then (*  Too few arguments; eta-expansion.  *)
                    let argnames = makeArgs (arity - (List.length args)) in
                    let args' = args @ (List.map (Term.atom) argnames) in
                    (makeAbstractions argnames (FOA.ApplicationFormula((abstractReplacement lambdas body),args')))
                  else             
                    raise (FOA.SemanticError("'" ^ head ^ "' applied to too many arguments"))
              else
                FOA.ApplicationFormula(FOA.AtomicFormula(head),args)
          |_ -> assert false}
    in
    ff []

  (********************************************************************
  * abs_of_pred:
  * eta-expand (mu B) which is a predicate into (x..\ mu B x) which is
  * an abstraction.
  ********************************************************************)
  let abs_of_pred arity pol pred =
    let args' =
      Listutils.mapi
        (fun _ -> Term.fresh ~name:"*eta*" ~lts:0 ~ts:0 ~tag:Term.Constant)
        arity
    in
    let f' = FOA.AbstractionBody(pol,FOA.ApplicationFormula(pred, args')) in
    List.fold_right (fun t -> (FOA.abstractVar t).FOA.abstf) args' f'

  (********************************************************************
  *parsePattern:
  * Parses the argument into a pattern.  If successful, returns Some
  * with the parsed pattern, otherwise it returns None.
  ********************************************************************)
  let parsePattern t =
    try
      Some
       (Firstorderparser.toplevel_pattern
         Firstorderlexer.token (Lexing.from_string t))
    with
        FOA.SyntaxError(s) ->
          O.error (s ^ ".\n");
          None
      | FOA.SemanticError(s) ->
          O.error (s ^ ".\n");
          None
      | Parsing.Parse_error ->
          O.error "Syntax error.\n";
          None

  (********************************************************************
  *parseFormula:
  * Parses the argument into a formula.  If successful, returns Some
  * with the parsed formula, otherwise it returns None.
  ********************************************************************)
  let parseFormula defs t =        
    try
      let formula =
        Firstorderparser.toplevel_pattern
          Firstorderlexer.token (Lexing.from_string t)
      in
      let formula = (replaceApplications defs).FOA.polp formula in
      let () =
        O.debug ("Firstorder.parseFormula: formula: " ^
                 ((FOA.string_of_formula ~generic:[]).FOA.polf formula) ^ "\n")
      in
      let () =
        O.debug ("Firstorder.parseFormula: formula ast: " ^
                 ((FOA.string_of_formula_ast ~generic:[]).FOA.polf formula) ^ "\n")
      in
      Some formula
    with
        FOA.SyntaxError(s) ->
          (O.error (s ^ ".\n");
          None)
      | FOA.SemanticError(s) ->
          (O.error (s ^ ".\n");
          None)
      | Parsing.Parse_error ->
          (O.error "Syntax error.\n";
          None)

  (********************************************************************
  *parseInvariant
  * Parses the argument into an invariant.  If successful, returns Some
  * with the parsed invariant, otherwise it returns None.  Note that
  * this does not guarantee an invariant of a particular arity (i.e.,
  * the arity could be 0).
  ********************************************************************)
  let parseInvariant defs t =        
    try
      let invariant =
        Firstorderparser.toplevel_invariant
          Firstorderlexer.token (Lexing.from_string t)
      in
      let invariant' = (replaceApplications defs).FOA.abstp invariant in
      let () =
        O.debug ("Firstorder.parseInvariant: invariant: " ^
                 ((FOA.string_of_formula ~generic:[]).FOA.abstf invariant') ^ "\n")
      in
      let () =
        O.debug ("Firstorder.parseInvariant: invariant ast: " ^
                 ((FOA.string_of_formula_ast ~generic:[]).FOA.abstf invariant') ^ "\n")
      in
      Some invariant'
    with
        FOA.SyntaxError(s) ->
          (O.error (s ^ ".\n");
          None)
      | FOA.SemanticError(s) ->
          (O.error (s ^ ".\n");
          None)
      | Parsing.Parse_error ->
          (O.error "Syntax error.\n";
          None)
  (********************************************************************
  *parseDefinition:
  * Parses the argument into a definition.  If successful, returns Some
  * with the parsed definition, otherwise it returns None.
  ********************************************************************)
  let parseDefinition defs t =        
    try
      let FOA.PreDefinition(name,args,body,ind) = Firstorderparser.toplevel_definition Firstorderlexer.token (Lexing.from_string t) in
      let body = (replaceApplications defs).FOA.abstp body in
      let () =
        O.debug ("Firstorder.parseDefinition: predefinition ast:" ^
                 name ^ " " ^ ((FOA.string_of_formula_ast ~generic:[]).FOA.abstf body) ^
                 ".\n")
      in
      let () =
        O.debug ("Firstorder.parseDefinition: predefinition: " ^
                 name ^ " " ^ ((FOA.string_of_formula ~generic:[]).FOA.abstf body) ^
                 ".\n")
      in
      Some (FOA.Definition(name,args,body,ind))
    with
        FOA.SyntaxError(s) ->
          (O.error (s ^ ".\n");
          None)
      | FOA.SemanticError(s) ->
          (O.error (s ^ ".\n");
          None)
      | Parsing.Parse_error ->
          (O.error "Syntax error.\n";
          None)

  (********************************************************************
  *lemmas:
  * Called by the interpreter to print the current set of lemmas.
  * This just prints the names of the lemmas.
  ********************************************************************)
  let lemmas session =
    let output =
    "Lemmas:\n" ^
    (String.concat "\n" (List.map (fun (s,_,_) -> "  " ^ s) session.lemmas)) ^
    "\n"
    in
    O.output output;
    session

  (********************************************************************
  *prove:
  * Parses the argument into a formula, and then prepares the session to
  * prove the formula.  It saves the namespaces so that after proving
  * the theorem constant names won't remain "used up".  It also sets
  * the session sequents to be exactly one sequent with the parsed
  * formula on the right.
  ********************************************************************)
  let prove name t session =
    Term.restore_namespace session.initial_namespace ;
    let f = parseFormula session.definitions t in
    let proofNamespace = Term.save_namespace () in
      match f with
        | Some f ->
            { session with
                  proof_namespace = proofNamespace ;
                  builder = Logic.idProofBuilder ;
                  sequents = [{ bound = None ;
                                lvl=0 ; lhs=[] ; rhs=[makeFormula f] }] ;
                  theorem_name = Some name;
                  theorem = Some f}
        | None -> session

  (********************************************************************
  *theoremName:
  * Returns the current theorem name, if it exists.
  ********************************************************************)
  let theoremName session =
    if Option.isSome session.theorem_name then
      Option.get session.theorem_name
    else
      assert false

  (********************************************************************
  *proved:
  * Called when a theorem has been proven.
  ********************************************************************)
  let proved session =
    match (session.builder []) with
        [proof] ->
        let lemmas' =
          (Option.get session.theorem_name,
            makeFormula (Option.get session.theorem),
            proof) ::
          session.lemmas
        in
        {session with lemmas = lemmas'}
      | _ ->
        failwith ("invalid proof of theorem '" ^ (Option.get session.theorem_name) ^ "'")

  (********************************************************************
  *definitions:
  * Given a list of strings representing possibly mutually-recursive
  * definitions, parses the definitions and adds them to the definition
  * table.
  ********************************************************************)
  let definitions defstrings session =
    (******************************************************************
    *processPreDefinitions:
    * Processes a list of mutually recursive predefinitions into
    * a list of definitions.
    ******************************************************************)
    let processPreDefinitions predefs =
      (****************************************************************
      *checkMonotonicity:
      * Determines whether a definition is monotonic.  A definition is
      * monotonic if none of its DB indices occur under an odd number
      * of negations.
      ****************************************************************)
      let checkMonotonicity body =
        let tf t = t in

  let rec ff (db,neg) =
    let ff = FOA.mapFormula2 (fun name (db,neg) -> (db+1,neg)) 
      (function FOA.Imp -> fun (db,neg) -> ((db,neg+1),(db,neg)) |_ -> fun x -> (x,x)) 
      ff tf (db,neg) in
      {ff with 
         FOA.predf = fun f -> match f with
       FOA.DBFormula(_,_,db') ->              
         if (db = db') && (neg mod 2) <> 0 then
           raise NonMonotonic
         else
           ff.FOA.predf f
     |_ -> ff.FOA.predf f}
        in

        try
          (ignore ((ff (0,0)).FOA.abstf body);
          true)
        with
          NonMonotonic -> false
      in
      
      (****************************************************************
      *makeFixpoint:
      * Makes a mu or nu formula based on the combinator type.
      ****************************************************************)
      let makeFixpoint ind name argnames body = 
  FOA.FixpointFormula(ind,name,argnames,body) in
      
      (****************************************************************
      *abstractDefinition:
      * Abstracts a definition.  Iterates over a definition body.
      * If it hits an application whose name is in the abstractions
      * list, it inserts the correct DB index.  If it hits an application
      * whose head is not in the abstractions list (but is in then pre-
      * definitions list), it adds the name to the abstractions list 
      * and abstracts the body of the pre-definition.
      ****************************************************************)
      let abstractDefinition abstractions f =
        (**************************************************************
        *getDB:
        * Get the DB index of a name.
        **************************************************************)
        let getDB name abs =
          let rec get name abs =
            match abs with
              [] -> None
            | a::abs' ->
                if a = name then
                  Some 0
                else
                  let r = (get name abs') in
                  if Option.isSome r then
                    Some (1 + (Option.get r))
                  else
                    None
          in
          let i = (get name abs) in
          i
        in
        
        (**************************************************************
        *findDefinition:
        * Finds a pre-definition in the pre-definition list.
        **************************************************************)
        let findDefinition name predefs =
          try
            let find name (FOA.Definition(name',ids,formula,ind)) =
              name' = name
            in
            Some (List.find (find name) predefs)
          with
            Not_found -> None
        in
        
        
        let tf t = t in  
        let id1 _ x = x in
        let id2 _ x = x,x in
        let rec ff abstractions  =
          let ff' = FOA.mapFormula2 id1 id2 ff tf abstractions in
          {ff' with
            FOA.predf = fun f args -> match f with
              FOA.AtomicFormula(head) ->
                  let db = getDB head abstractions in
                  if Option.isSome db then
                    FOA.ApplicationFormula
                      (FOA.DBFormula(0,head, Option.get db), args)
                  else
                    let f =
                      let def = findDefinition head predefs in
                      if Option.isSome def then
                        let FOA.Definition(_,argnames,f',ind) = (Option.get def) in
                        makeFixpoint ind head argnames ((ff (head::abstractions)).FOA.abstf f')
                      else
                        f
                      in
                        FOA.ApplicationFormula(f,args)
            | _ -> ff'.FOA.predf f args}
        in
        ((ff abstractions).FOA.abstf f)
      in

      (****************************************************************
      *processPreDefinition:
      * Mu/Nu-abstracts the body of the predefinition, and wraps the body
      * in a Mu/Nu formula.
      ****************************************************************)
      let processPreDefinition (FOA.Definition(name, ids, formula, ind)) =
        let formula' = abstractDefinition [name] formula in
        
        let result = FOA.Definition(name, ids, formula', ind) in
        if (checkMonotonicity formula') then
          Some(result)
        else
          (O.output ("Warning: " ^ name ^ ": non-monotonic definition.\n");
          Some(result))
      in
      (List.map processPreDefinition predefs)
    in
    
    (******************************************************************
    *addDefinitions:
    * Given a list of definitions and a table, adds the definitions
    * to the table, but doesn't allow for redefinitions.
    ******************************************************************)
    let rec addDefinitions defs table =
      match defs with
        [] -> table
      | (FOA.Definition(name,arity,formula,ind) as def)::ds ->
          if (Logic.contains name table) then
            (O.error ("'" ^ name ^ "' already defined.\n");
            table)
          else
            let () =
              O.debug ("Firstorder.definitions: definition ast: " ^
                       ((FOA.string_of_formula_ast ~generic:[]).FOA.abstf formula) ^ ".\n")
            in
            let () =
              O.output ("Definition: " ^ (FOA.string_of_definition def) ^ ".\n")
            in
            Logic.Table.add name def (addDefinitions ds table)
    in
        
    let predefs = List.map (parseDefinition session.definitions) defstrings in
    if (List.exists (Option.isNone) predefs) then
      (O.error "definitions contain errors.\n";
      session)
    else
      let defs = processPreDefinitions (List.map (Option.get) predefs) in
      if (List.exists (Option.isNone) defs) then
        (O.error ("definitions contain errors.\n");
        session)
      else
        let defs' = (List.map (Option.get) defs) in
        let defs'' = (addDefinitions defs' session.definitions) in
          { session with definitions = defs'' ;
              (* Always remember constants used in the new definitions. *)
              initial_namespace = Term.save_namespace () }

  (********************************************************************
  *copyFormula:
  * Copies a formula's eigen variables. Used before performing eqL.
  * TODO isn't it enough to work on FOA.formulas ?
  ********************************************************************)
  let copyFormula ?(copier=(Term.copy_eigen ())) (Formula(i,f)) =
    let copyTerm t = copier t in
    let rec copyFormula () = FOA.mapFormula copyFormula copyTerm in
    (Formula(i,(copyFormula ()).FOA.polf f))

  (********************************************************************
  *makeExistentialVar/makeUniversalVar/makeNablaVar:
  * Makes a new Term var (see ndcore/term.mli) of the approriate type
  * and returns it along with the updated local context and sequent level.
  ********************************************************************)
  let makeExistentialVar hint lvl lts =
    let hint = String.capitalize hint in
    let var = Term.fresh ~name:hint ~lts:0 ~ts:lvl ~tag:Term.Logic in
    let rec raise_over x n =
      if n = 0 then x else
        Term.app (raise_over x (n-1)) [Term.nabla n]
    in
    let var = raise_over var lts in
    (lvl, var)

  let makeUniversalVar hint lvl lts =
    let lvl = lvl+1 in
    let var = Term.fresh ~name:hint ~lts:0 ~ts:lvl ~tag:Term.Eigen in
    let rec raise_over x n =
      if n = 0 then x else
        Term.app (raise_over x (n-1)) [Term.nabla n]
    in
    let var = raise_over var lts in
    (lvl, var)

  let makeNablaVar lvl i =
    (lvl, i + 1, Term.nabla (i + 1))

  (********************************************************************
  *Tacticals:
  ********************************************************************)
  module FirstorderSig =
  struct
    type logic_session = session
    type logic_sequent = sequent
    type logic_proof = proof
  end
  module G = Logic.GenericTacticals (FirstorderSig) (O)

  (********************************************************************
  *makeProofBuilder ruleName ~b:bound_vars ~p:rule_params ~f:formula seq:
  * Makes a proof builder for a simple inference rule.  Given the name
  * of the inference rule ('rule'), constructs a function that takes a
  * list of the proofs (strings) of the arguments (arg1...argN) to the
  * inference rule and returns a proof of the rule that can be printed
  * in XML form easily.
  ********************************************************************)
  let makeProofBuilder name ?(b=[]) ?(p=[]) ?f seq = fun proofs ->
    { rule = name ; params = p ; bindings = b ; formula = f ; sequent = seq ;
      subs = proofs }

  (********************************************************************
  *findFormula:
  * Given a template and a list of formulas F, returns the first formula
  * that matches the template along with its context in F.
  ********************************************************************)
  let findFormula pattern formulas =
    let rec find front formulas =
      match formulas with
        [] ->
          let () = O.debug "Firstorder.findFormula: not found.\n" in
          None
      | (Formula(_,formula) as f)::fs ->
          if FOA.matchFormula pattern formula then
            let () =
              O.debug ("Firstorder.findFormula: found: " ^
                       (string_of_formula f ^ ".\n"))
            in
              Some(f, List.rev front, fs)
          else
            find (f::front) fs
    in
      find [] formulas

  (********************************************************************
  *matchLeft, matchRight:
  * Given a pattern and a sequent, finds the first element on the left
  * (or right) that matches the pattern, and returns a tuple with:
  *   the matching formula
  *   the before and after of the left or right
  *   the whole left
  *   the whole right
  ********************************************************************)
  let matchLeft pattern after sequent =
    let lhs = match after with Some a -> a | None -> sequent.lhs in
    let rhs = sequent.rhs in
    let result = findFormula pattern lhs in
    match result with
      Some(f,before,after) -> Some(f,before,after,lhs,rhs)
    | None -> None

  let matchRight pattern after sequent =
    let lhs = sequent.lhs in
    let rhs = match after with Some a -> a | None -> sequent.rhs in
    let result = findFormula pattern rhs in
    match result with
      Some(f,before,after) -> Some(f,before,after,lhs,rhs)
    | None -> None

  (********************************************************************
  *makeTactical:
  * Given a matcher and a tactic, creates a tactical that applies
  * the given tactic to the first formula in the sequent that matches
  * the tactic.  If the application fails, it finds the next formula.
  * If the application succeedes, the whole tactical succeeds. If none
  * match, it fails.
  ********************************************************************)
  let makeTactical name matcher tactic session =
    let tactic' = fun sequent sc fc ->
      let sc' ?b formula k s =
        sc s (makeProofBuilder name ~f:formula sequent) k
      in
      let rec fc' left right () =
        match (matcher right sequent) with
          Some(f, left', right', lhs, rhs) ->
            let left'' = left @ left' in
            let zip l = (left'' @ l @ right') in
            let fc'' () =
              fc' (left'' @ [f]) (Some right') ()
            in
              tactic session sequent f zip lhs rhs (sc' f) fc''
        | None ->
            fc ()
      in
        fc' [] None ()
    in
      G.makeTactical tactic'

  (********************************************************************
  *makeGeneralTactical:
  * Given the name of a tactic, a matcher constructor (either matchLeft or
  * matchRight), a default template for use if none is specified, and
  * a tactic, finds a formula to operate on using the matcher and applies
  * the tactic.
  *
  * The tactic passed to makeGeneralTactical should be a function that
  * takes the session, sequent, the matched formula, a zipper, the left
  * and right sides in their entirety, a success continuation that takes
  * a continue continuation (see logic.mli) and a list of new sequents,
  * and a failure continuation (see logic.mli).
  ********************************************************************)
  let makeGeneralTactical name (matchbuilder, default) tactic =
    fun session args ->
      (*  If no default template was specified and there is no argument
          template then bail. *)
      if default = "" && Listutils.empty args then
        (G.invalidArguments (name ^ ": incorrect number of arguments."))
      else
      
      let defaultPattern = parsePattern default in
      
      if Option.isSome defaultPattern then
        let defaultPattern = Option.get defaultPattern in
        match args with
            [] ->
              (makeTactical name (matchbuilder defaultPattern) tactic session)
          | Absyn.String(s)::[] ->
              let pattern = parsePattern s in
              if (Option.isSome pattern) then
                let pattern = Option.get pattern in
                if not (FOA.matchPattern defaultPattern pattern) then
                  G.invalidArguments (name ^ ": pattern does not match default pattern")
                else
                  makeTactical name (matchbuilder pattern) tactic session
              else
                (G.invalidArguments (name ^ ": invalid pattern"))
          | _ -> (G.invalidArguments (name ^ ": incorrect number of arguments"))
      else
        (G.invalidArguments (name ^ ": invalid default pattern."))

  
  (********************************************************************
  *makeSimpleTactical:
  * Given the name of a tactic, a matcher constructor (either matchLeft or
  * matchRight), a default template for use if none is specified, and
  * a tactic, finds a formula to operate on using the matcher and applies
  * the tactic.
  *
  * The tactic passed to makeSimpleTactical should be a function that
  * takes the session, sequent, the matched formula, a zipper, the left
  * and right sides in their entirety, a success continuation that takes
  * a list of new sequents, and a failure continuation (see logic.mli).
  *
  * This function should be used only for simple inference rules as it
  * interacts subtly with backtracking by not allowing for a modified
  * continue continuation as makeGeneralTactical does.
  ********************************************************************)
  let makeSimpleTactical name (matchbuilder, defaulttemplate) tactic =
    let tactic' session seq f zip lhs rhs sc fc =
      tactic session seq f zip lhs rhs (sc fc) fc
    in
    makeGeneralTactical name (matchbuilder, defaulttemplate) tactic'
  
  (** {1 Rules of the logic} *)

  (** Utility for the atomic initial rule, looking for (p params) in some side
    * of a sequent. *)
  let atomicInit i p params sc fc =
    let rec attempts = function
      | [] -> fc ()
      | Formula(i',(_,FOA.ApplicationFormula(FOA.AtomicFormula p',params')))
        ::formulas ->
          if p=p' && (i=i' || not Param.strictNabla) then
            begin match FOA.unifyList FOA.rightUnify params params' with
              | FOA.UnifySucceeded bind ->
                  sc (fun () -> FOA.undoUnify bind ; attempts formulas)
              | FOA.UnifyFailed ->
                  attempts formulas
              | FOA.UnifyError s ->
                  O.error (s ^ ".\n");
                  attempts formulas
            end
          else
            attempts formulas
      | _::formulas -> attempts formulas
    in
      attempts

  (* This is currently rather weak. Comparing the bodies will eventually be
   * needed, but implies using Term.eq for the leafs. *)
  let fixpointEq p p' = match p,p' with
    | FOA.FixpointFormula (f,name,_,_), FOA.FixpointFormula (f',name',_,_) ->
        f = f' && name = name'
    | _ -> false

  let fixpointInit i p params sc fc =
    let rec attempts = function
      | [] -> fc ()
      | Formula(i',(_,FOA.ApplicationFormula(p',params')))::formulas ->
          if fixpointEq p p' && (i=i' || not Param.strictNabla) then
            begin match FOA.unifyList FOA.rightUnify params params' with
              | FOA.UnifySucceeded bind ->
                  sc (fun () -> FOA.undoUnify bind ; attempts formulas)
              | FOA.UnifyFailed ->
                  attempts formulas
              | FOA.UnifyError s ->
                  O.error (s ^ ".\n");
                  attempts formulas
            end
          else
            attempts formulas
      | _::formulas -> attempts formulas
    in
    attempts

  (********************************************************************
  *unfoldFixpoint:
  ********************************************************************)
  let unfoldFixpoint rulename pol pred arity args mkseq sc fc =
    let body =
      match pred with
        | FOA.FixpointFormula (_,_,_,body) -> body
        | _ -> assert false
    in
    match (* body (mu body) *)
      (FOA.applyFixpoint (abs_of_pred arity pol pred)).FOA.abstf body      
    with
     | Some p' ->
         begin match FOA.fullApply args p' with
           | Some mu' -> (* body (mu body) args *)
               sc rulename (mkseq mu')
           | _ ->
               O.impossible
                 "unable to apply arguments to fixpoint formula.\n" ;
               fc ()
         end
     | None ->
         O.impossible "definition has incorrect arity.\n" ;
         fc ()

  (** Given a body [b], and a (co)invariant [s] as a string, and parameters [t],
    * computes [s t], [s t'] and [b s t']. *)
  let fixpoint_St_St'_BSt' ~session ~lvl ~i ~body ~argnames ~s ~t =
    let rec makeArgs lvl i = function
      | [] -> (lvl, [])
      | a::aa ->
          let (lvl', a') = makeUniversalVar a lvl i in
          let (lvl'', aa') = makeArgs lvl' i aa in
            (lvl'',  a'::aa')
    in
    let (lvl',t') = makeArgs lvl i argnames in
      begin match
        FOA.fullApply t s, FOA.fullApply t' s,
        (FOA.applyFixpoint s).FOA.abstf body
      with
        | Some st, Some st', Some bs ->
            begin match FOA.fullApply t' bs with
              | Some bst' -> Some (st,lvl',st',bst')
              | None ->
                  O.impossible
                    "unable to apply arguments to B(S).\n";
                  None
            end
        | _ ->
            O.error "invariant has incorrect arity.\n";
            None
      end

  (********************************************************************
  *unfoldingProgresses:
  * Given a list of definition arguments (which consist of argument
  * names and booleans indicating whether the definition makes progress
  * on that argument) and a list of actual arguments (terms), returns
  * whether or not a rigid term is passed as an argument on which the
  * definition progresses.
  ********************************************************************)
  let unfoldingProgresses =
    let rec rigid t = match Term.observe (Norm.hnorm t) with
      | Term.Lam (_,t) -> rigid t
      | Term.App (t,_) -> rigid t
      | Term.Var v when v.Term.tag = Term.Constant -> true
      | _ -> false
    in
    List.exists2 (fun (_,b) a -> b = FOA.Progressing && rigid a)

  type internal_sc =
    ?k:(unit -> unit) -> ?b:(Term.term list) -> string -> sequent list -> unit

  (** [intro] will be our do-it-all tactic: it takes a matcher, and applies
    * a rule with a matched formula as the active one.
    *
    * The only problem with that approach is that sometimes, there are several
    * choices for the same formula, e.g. with an additive disjunction or a fixed
    * point. The [arg] is there to specify these choices ("left"/"right").
    *
    * The focusing strategy will have to call it by passing a matcher that looks
    * for a focused or asynchronous, unfrozen formula. It will never pass any
    * [arg]. An example consequence is that [intro] should try both branches of
    * an additive disjunction if no [arg] is passed.
    *
    * The [intro] tactic will be conveniently wrapped in several specialized
    * tactics for the user, using [arg] to force choices. *)
  let intro side matcher session arg =
    (*  Propagate the focused flag from f to its subformulas by modifying the
        zip function to do so on each zipped formula. *)
    let convertZip zip f l =
      (*  propagate: copy the focused flag correctly. *)
      let propagate (Formula(i,(a,sf))) =
        let ann =
          if (fst f).FOA.control = FOA.Focused && a.FOA.control <> FOA.Delayed then
            { a with FOA.control=FOA.Focused }
          else
            a
        in
        Formula(i,(ann, sf))
      in
      zip (List.map propagate l)
    in

    (* Apply a rule with its active formula on the left hand-side. *)
    let left seq (Formula(i,f)) zip (sc:internal_sc) fc =
      let zip = convertZip zip f in
      match f with
        | _,FOA.BinaryFormula (conn,l,r) ->
            begin match conn with
              | FOA.And ->
                  sc "and_l"
                    [{ seq with lhs = zip [Formula(i,l);Formula(i,r)] }]
              | FOA.Or ->
                  sc "or_l" [
                    { seq with lhs = zip [Formula(i,l)] };
                    { seq with lhs = zip [Formula(i,r)] }
                  ]
              | FOA.Imp ->
                  sc "imp_l" [
                    { seq with lhs = zip [] ; rhs =
                        if Param.intuitionistic then
                          [Formula(i,l)]
                        else
                          Formula(i,l)::seq.rhs } ;
                    { seq with lhs = zip [Formula(i,r)] }
                  ]
            end
        | _,FOA.QuantifiedFormula (FOA.Pi,
              (FOA.AbstractionFormula(hint,FOA.AbstractionBody _) as f)) ->
            let (lvl',var) = makeExistentialVar hint seq.lvl i in
              begin match FOA.fullApply [var] f with
                | Some f' ->
                    sc "pi_l" ~b:[var]
                      [{ seq with lvl=lvl' ; lhs = zip [Formula(i,f')] }]
                | _ -> fc ()
              end
        | _,FOA.QuantifiedFormula (FOA.Sigma,
              (FOA.AbstractionFormula(hint,FOA.AbstractionBody _) as f)) ->
            let (lvl',var) = makeUniversalVar hint seq.lvl i in
              begin match FOA.fullApply [var] f with
                | Some f' ->
                    sc "sigma_l" ~b:[var]
                      [{ seq with lvl=lvl' ; lhs = zip [Formula(i,f')] }]
                | _ -> fc ()
              end
        | _,FOA.QuantifiedFormula (FOA.Nabla,
              (FOA.AbstractionFormula(hint,FOA.AbstractionBody _) as f)) ->
            let (lvl',i',var) = makeNablaVar seq.lvl i in
              begin match FOA.fullApply [var] f with
                | Some f' ->
                    sc "nabla_l"
                      [{ seq with lvl=lvl' ; lhs = zip [Formula(i',f')] }]
                | _ -> fc ()
              end
        | _,FOA.QuantifiedFormula _ -> assert false
        | _,FOA.EqualityFormula _ ->
            (* Copy the equality, then possibly instantiate its variables,
             * these instantiations will be taken into account when copying
             * the rest of the sequent. *)
            let copier = Term.copy_eigen () in
            let copy = List.map (copyFormula ~copier) in
              begin match copyFormula ~copier (Formula(i,f)) with
                | Formula(_,(_,FOA.EqualityFormula(t1,t2))) ->
                    begin match FOA.leftUnify t1 t2 with
                      | FOA.UnifyFailed ->
                          (* TODO check side effect *)
                          sc "eq_l" []
                      | FOA.UnifySucceeded bind ->
                          let fc () = FOA.undoUnify bind ; fc () in
                            sc "eq_l" ~k:fc [{seq with lhs = copy (zip []) ;
                                                       rhs = copy seq.rhs }]
                      | FOA.UnifyError s ->
                          O.error (s ^ ".\n");
                          fc ()
                    end
                | _ -> assert false
              end
        | pol,FOA.ApplicationFormula (p,args) ->
            let arity = List.length args in
            let unfoldFixpoint ruleName name args body argnames sc fc =
              (* TODO
               * The "rigidity" test should only be used on particular
               * arguments of particular fixed points, not blindly as here.
               * This is already needed to handle "leq". *)
              let bound =
                if unfoldingProgresses argnames args then
                  seq.bound
                else
                  updateBound seq
              in
              let mkseq f =
                [{ seq with bound = bound ;
                            lhs = zip [Formula(i,f)] }]
              in
                if out_of_bound bound then fc () else
                  unfoldFixpoint ruleName pol p arity args mkseq sc fc
            in
            begin match p with
              | FOA.FixpointFormula (FOA.CoInductive,name,argnames,body) ->
                  assert (arity = List.length argnames) ;
                  (* This is synchronous. *)
                  begin match arg with
                    | Some "unfold" ->
                        unfoldFixpoint "nu_l" name args body argnames sc fc
                    | Some "init" ->
                        fixpointInit i p args
                          (fun k -> sc "init_nu" [] ~k)
                          fc seq.rhs
                    | None ->
                        fixpointInit i p args
                          (fun k -> sc "init_nu" [] ~k)
                          (fun () ->
                             unfoldFixpoint "nu_l"
                               name args body argnames sc fc)
                          seq.rhs
                    | s -> assert false
                  end
              | FOA.FixpointFormula (FOA.Inductive,name,argnames,body) ->
                  let onlynames = List.map fst argnames in
                  assert (arity = List.length argnames) ;
                  (* This is asynchronous.
                   * If [arg] is "unfold", do mu_l, otherwise treat it as an
                   * invariant, otherwise infer an invariant. *)
                  begin match arg with
                    | Some "unfold" ->
                        unfoldFixpoint "mu_l" name args body argnames sc fc
                    | Some s ->
                        let s = parseInvariant session.definitions s in
                        if Option.isSome s then
                          let s = Option.get s in
                          (* TODO bound check *)
                          begin match
                            fixpoint_St_St'_BSt'
                              ~session ~lvl:seq.lvl ~i
                              ~body ~argnames:onlynames ~s ~t:args
                          with
                            | Some (st,lvl',st',bst') ->
                                let st   = Formula (i,st) in
                                let st'  = Formula (0,st') in
                                let bst' = Formula (0,bst') in
                                  sc "induction" [
                                    { seq with lhs = zip [st] } ;
                                    { seq with lvl = lvl' ;
                                               lhs = [bst'] ; rhs = [st'] }
                                  ]
                            | None -> fc ()
                          end
                        else
                          fc () (*  TODO: needs error message?  *)
                    | None ->
                        let fresh n =
                          Term.fresh ~name:n ~ts:0 ~lts:0 ~tag:Term.Eigen
                        in
                        let rhs =
                          (* ... |- H1,..,Hn becomes H1\/..\/Hn *)
                          (* TODO don't ignore generic context *)
                          let rec s = function
                            | [] -> assert false
                            | [Formula(_,f)] -> f
                            | (Formula(_,pf))::l ->
                                { FOA.defaultAnnotation
                                  with FOA.polarity = FOA.Negative },
                                FOA.BinaryFormula (FOA.Or, pf, s l)
                          in s seq.rhs
                        in
                        let lrhs =
                          (* H1, ..., Hn |- rhs becomes H1 => .. => Hn => rhs *)
                          let rec s = function
                            | [] -> rhs
                            | Formula(_,f)::l ->
                               { FOA.defaultAnnotation with
                                   FOA.polarity = FOA.Negative },
                               FOA.BinaryFormula (FOA.Imp, f, s l)
                          in
                          s (zip [(*TODO frozen version of what we induct on*)])
                        in
                        let fv,elrhs =
                          (* Essentially form
                           * fv1\..fvn\ fv1=arg1 => .. fvn=argn => lrhs *)
                          let rec e lan la =
                            match lan,la with
                              | [],[] -> [],lrhs 
                              | an::lan,a::la ->
                                  let lv,f = e lan la in
                                  let v = fresh an in
                                    v::lv,
                                    FOA.negativeFormula
                                      (FOA.BinaryFormula
                                         (FOA.Imp,
                                          FOA.positiveFormula
                                            (FOA.EqualityFormula (v,a)),
                                          f))
                              |_ -> assert false
                          in
                            e onlynames (List.rev args)
                        in
                        (* Abstract universally over eigenvariables. *)
                        let getenv =
                          Term.eigen_vars ((FOA.termsPolarized lrhs)@args)
                        in
                        let aelrhs =
                          List.fold_left
                            (fun f v ->
                               FOA.negativeFormula
                                 (FOA.QuantifiedFormula
                                    (FOA.Pi, (FOA.abstractVar v).FOA.polf f)))
                            elrhs getenv
                        in
                        (* Abstract out the fv1..fvn. *)
                        let invariant =
                          List.fold_left
                            (fun f v -> (FOA.abstractVar v).FOA.abstf f)
                            (FOA.AbstractionBody aelrhs)
                            fv
                        in
                        let _,lvl',st',bst' =
                          Option.get (fixpoint_St_St'_BSt'
                                        ~session ~lvl:seq.lvl ~i ~body
                                        ~argnames:onlynames
                                        ~s:invariant ~t:args)
                        in
                        let bound = updateBound seq in
                          if out_of_bound bound then fc () else
                            sc "induction"
                              [{ bound = bound ; lvl = lvl' ;
                                 rhs = [Formula(0,bst')] ;
                                 lhs = [Formula(0,st')] }]
                  end
              | FOA.AtomicFormula p ->
                  if p = "false" then sc "false" [] else (* TODO boooh *)
                    atomicInit i p args (fun k -> sc "init" [] ~k) fc seq.rhs
              | FOA.DBFormula _ -> assert false
            end
    in

    (* Apply a rule with its active formula on the right hand-side. *)
    let right seq (Formula(i,f)) zip (sc:internal_sc) fc =
      let zip = convertZip zip f in
      match f with
        | _,FOA.BinaryFormula (conn,l,r) ->
            begin match conn with
              | FOA.Or ->
                  if not Param.intuitionistic then
                    sc "or_r"
                      [{ seq with rhs = zip [Formula(i,l);Formula(i,r)] }]
                  else
                    let left  = { seq with rhs = [Formula(i,l)] } in
                    let right = { seq with rhs = [Formula(i,r)] } in
                      begin match arg with
                        | Some s when s <> "" ->
                            if s.[0] = 'l' then
                              sc "left" [left]
                            else
                              sc "right" [right]
                        | _ ->
                            sc "left" [left] ~k:(fun () -> sc "right" [right])
                      end
              | FOA.And ->
                  sc "and_r" [
                    { seq with rhs = zip [Formula(i,l)] };
                    { seq with rhs = zip [Formula(i,r)] }
                  ]
              | FOA.Imp ->
                  sc "imp_r" [ { seq with lhs = Formula(i,l)::seq.lhs ;
                                          rhs = zip [Formula(i,r)] } ]
            end
        | _,FOA.QuantifiedFormula (FOA.Pi,
              (FOA.AbstractionFormula(hint,FOA.AbstractionBody _) as f)) ->
            let (lvl',var) = makeUniversalVar hint seq.lvl i in
              begin match FOA.fullApply [var] f with
                | Some f' ->
                    sc "pi_r" ~b:[var]
                      [{ seq with lvl=lvl' ; rhs = zip [Formula(i,f')] }]
                | _ -> fc ()
              end
        | _,FOA.QuantifiedFormula (FOA.Sigma,
              (FOA.AbstractionFormula(hint,FOA.AbstractionBody _) as f)) ->
            let (lvl',var) = makeExistentialVar hint seq.lvl i in
              begin match FOA.fullApply [var] f with
                | Some f' ->
                    sc "sigma_r" ~b:[var]
                      [{ seq with lvl=lvl' ; rhs = zip [Formula(i,f')] }]
                | _ -> fc ()
              end
        | _,FOA.QuantifiedFormula (FOA.Nabla,
              (FOA.AbstractionFormula(hint,FOA.AbstractionBody _) as f)) ->
            let (lvl',i',var) = makeNablaVar seq.lvl i in
              begin match FOA.fullApply [var] f with
                | Some f' ->
                    sc "nabla_r"
                      [{ seq with lvl=lvl' ; rhs = zip [Formula(i',f')] }]
                | _ -> fc ()
              end
        | _,FOA.QuantifiedFormula _ -> assert false
        | _,FOA.EqualityFormula (t1,t2) ->
            begin match FOA.rightUnify t1 t2 with
              | FOA.UnifySucceeded(bind) ->
                  let fc' () = FOA.undoUnify bind ; fc () in
                    sc "eq_r" ~k:fc' []
              | FOA.UnifyFailed -> fc ()
              | FOA.UnifyError(s) ->
                  O.error (s ^ ".\n"); (* TODO that's annoying ? *)
                  fc ()
            end
        | pol,FOA.ApplicationFormula (p,args) ->
            let arity = List.length args in
            let unfoldFixpoint ruleName name args body argnames sc fc =
              let bound =
                if unfoldingProgresses argnames args then
                  seq.bound
                else
                  updateBound seq
              in
              let mkseq f =
                [{ seq with bound = bound ;
                            rhs = zip [Formula(i,f)] }]
              in
                if out_of_bound bound then fc () else
                  unfoldFixpoint ruleName pol p arity args mkseq sc fc
            in
            begin match p with
              | FOA.FixpointFormula (FOA.Inductive,name,argnames,body) ->
                  assert (arity = List.length argnames) ;
                  (* This is synchronous. *)
                  begin match arg with
                    | Some "unfold" ->
                        unfoldFixpoint "mu_r" name args body argnames sc fc
                    | Some "init" ->
                        fixpointInit i p args
                          (fun k -> sc "init_mu" [] ~k)
                          fc seq.lhs
                    | None ->
                        fixpointInit i p args
                          (fun k -> sc "init_mu" [] ~k)
                          (fun () ->
                             unfoldFixpoint "mu_r"
                               name args body argnames sc fc)
                          seq.lhs
                    | s -> O.error "Invalid parameter." ; fc ()
                  end
              | FOA.FixpointFormula (FOA.CoInductive,name,argnames,body) ->
                  let onlynames = List.map fst argnames in
                  assert (arity = List.length argnames) ;
                  (* This is asynchronous.
                   * If [arg] is "unfold", do nu_r, otherwise treat it as an
                   * invariant, otherwise infer an invariant. *)
                  begin match arg with
                    | Some "unfold" ->
                        unfoldFixpoint "nu_r" name args body argnames sc fc
                    | Some s ->
                        let s = parseInvariant session.definitions s in
                        if Option.isSome s then
                          (* TODO bound check *)
                          let s = Option.get s in
                          begin match
                            fixpoint_St_St'_BSt'
                              ~session ~lvl:seq.lvl ~i
                              ~body ~argnames:onlynames ~s ~t:args
                          with
                            | Some (st,lvl',st',bst') ->
                                let st   = Formula (i,st) in
                                let st'  = Formula (0,st') in
                                let bst' = Formula (0,bst') in
                                  sc "induction" [
                                    { seq with rhs = zip [st] } ;
                                    { seq with lvl = lvl' ;
                                               lhs = [st'] ; rhs = [bst'] }
                                  ]
                            | None -> fc ()
                          end
                        else
                          fc () (*  TODO: needs error message?  *)
                    | None ->
                        let fresh n =
                          Term.fresh ~name:n ~ts:0 ~lts:0 ~tag:Term.Eigen
                        in
                        let rhs =
                          (* ... |- H1,..,Hn becomes H1\/..\/Hn *)
                          (* TODO don't ignore generic context *)
                          let rec s = function
                            | [] -> assert false
                            | [Formula(_,f)] -> f
                            | (Formula(_,pf))::l ->
                                { FOA.defaultAnnotation
                                  with FOA.polarity = FOA.Negative },
                                FOA.BinaryFormula (FOA.Or, pf, s l)
                          in
                          s (zip [(*TODO frozen version of what we induct on*)])
                        in
                        let lrhs = (* TODO probably wrong, use /\ instead *)
                          (* H1, ..., Hn |- rhs becomes H1 => .. => Hn => rhs *)
                          let rec s = function
                            | [] -> rhs
                            | Formula(_,f)::l ->
                               { FOA.defaultAnnotation with
                                   FOA.polarity = FOA.Negative },
                               FOA.BinaryFormula (FOA.Imp, f, s l)
                          in
                          s seq.lhs
                        in
                        let fv,elrhs =
                          (* Essentially form
                           * fv1\..fvn\ fv1=arg1 /\ .. fvn=argn /\ lrhs *)
                          let rec e lan la =
                            match lan,la with
                              | [],[] -> [],lrhs 
                              | an::lan,a::la ->
                                  let lv,f = e lan la in
                                  let v = fresh an in
                                    v::lv,
                                    FOA.positiveFormula
                                      (FOA.BinaryFormula
                                         (FOA.And,
                                          FOA.positiveFormula
                                            (FOA.EqualityFormula (v,a)),
                                          f))
                              |_ -> assert false
                          in
                            e onlynames (List.rev args)
                        in
                        (* Abstract universally over eigenvariables. *)
                        let getenv =
                          Term.eigen_vars ((FOA.termsPolarized lrhs)@args)
                        in
                        let aelrhs =
                          List.fold_left
                            (fun f v ->
                               FOA.negativeFormula
                                 (FOA.QuantifiedFormula
                                    (FOA.Pi, (FOA.abstractVar v).FOA.polf f)))
                            elrhs getenv
                        in
                        (* Abstract out the fv1..fvn. *)
                        let invariant =
                          List.fold_left
                            (fun f v -> (FOA.abstractVar v).FOA.abstf f)
                            (FOA.AbstractionBody aelrhs)
                            fv
                        in
                        let _,lvl',st',bst' =
                          Option.get (fixpoint_St_St'_BSt'
                                        ~session ~lvl:seq.lvl ~i ~body
                                        ~argnames:onlynames
                                        ~s:invariant ~t:args)
                        in
                        let bound = updateBound seq in
                          if out_of_bound bound then fc () else
                            sc "coinduction"
                              [{ bound = bound ; lvl = lvl' ;
                                 lhs = [Formula(0,bst')] ;
                                 rhs = [Formula(0,st')] }]
                  end
              | FOA.AtomicFormula p ->
                  if p = "true" then sc "true" [] else (* TODO boooh *)
                  atomicInit i p args (fun k -> sc "init" [] ~k) fc seq.lhs
              | FOA.DBFormula _ -> assert false
            end
    in

    (* Wrap up: try to find a matched formula, apply a rule on it. *)
    let tactic formTac get_hs = fun sequent sc fc ->
      let rec parse before after =
        match matcher after with
          | None -> fc ()
          | Some (f,before',after) ->
              let before = before @ before' in
              let zip l = before @ l @ after in
              let parse_more () = parse (before @ [f]) after in
                formTac
                  sequent f zip
                  (fun ?(k=parse_more) ?b name sequents ->
                     sc sequents (makeProofBuilder name ?b ~f sequent) k)
                  parse_more
      in
      parse [] (get_hs sequent)
    in
    let left  = tactic left  (fun s -> s.lhs) in
    let right = tactic right (fun s -> s.rhs) in
    match side with
      | `Any -> G.orElseTactical (G.makeTactical left) (G.makeTactical right)
      | `Left -> G.makeTactical left
      | `Right -> G.makeTactical right

  (** Utility for creating matchers easily. TODO get rid of that, and only
    * use patterns. *)
  let make_matcher test formulas =
    let rec aux acc = function
      | f::tl -> if test f then Some (f,List.rev acc,tl) else aux (f::acc) tl
      | [] -> None
    in
    aux [] formulas

  (* Easy wrapper for tactics without arguments. *)
  let specialize ?arg side default_matcher session args =
    match args with
      | [Absyn.String s] ->
          begin match parsePattern s with
            | Some pattern ->
                intro
                  side (findFormula pattern)
                  session arg
            | None ->
                O.error "invalid pattern" ; fun s sc fc -> fc ()
          end
      | [] -> intro side default_matcher session arg
      | _ ->
          O.error "too many arguments" ; fun s sc fc -> fc ()

  (* Even more wrapping: pass a pattern instead of a matcher.. *)
  let patternTac ?arg side defaultPattern session args =
    match parsePattern defaultPattern with
      | Some (pattern) ->
          specialize ?arg side (findFormula pattern) session args
      | None -> assert false

  (* {1 Specialized basic manual tactics} *)

  let orLeft  = patternTac `Right "_;_" ~arg:"left"
  let orRight = patternTac `Right "_;_" ~arg:"right"
  let orR   = patternTac `Right "_;_" (* tries both in intuitionistic mode *)
  let orL   = patternTac `Left  "_;_"

  let andL = patternTac `Left  "_,_"
  let andR = patternTac `Right "_,_"
  let impL = patternTac `Left  "_=>_"
  let impR = patternTac `Right "_=>_"
  let eqL  = patternTac `Left  "_=_"
  let eqR  = patternTac `Right "_=_"
  let piL  = patternTac `Left  "pi _"
  let piR  = patternTac `Right "pi _"
  let sigmaL = patternTac `Left  "sigma _"
  let sigmaR = patternTac `Right "sigma _"
  let nablaL = patternTac `Left  "nabla _"
  let nablaR = patternTac `Right "nabla _"
  let trueR  = patternTac `Right "true"
  let falseL = patternTac `Left  "false"
  let muL = patternTac `Left  "mu _" ~arg:"unfold"
  let muR = patternTac `Right "mu _" ~arg:"unfold"
  let nuL = patternTac `Left  "nu _" ~arg:"unfold"
  let nuR = patternTac `Right "nu _" ~arg:"unfold"

  let inductionTactical session = function
    | [] -> patternTac `Left "mu _" session []
    | [Absyn.String i] -> patternTac `Left "mu _" ~arg:i session []
    | [Absyn.String i; Absyn.String p] -> patternTac `Left p ~arg:i session []
    | _ -> (fun _ _ fc -> O.error "Invalid arguments.\n" ; fc ())
  let coinductionTactical session = function
    | [] -> patternTac `Right "nu _" ~arg:"" session []
    | [Absyn.String i] -> patternTac `Right "nu _" ~arg:i session []
    | [Absyn.String i; Absyn.String p] -> patternTac `Right p ~arg:i session []
    | _ -> (fun _ _ fc -> O.error "Invalid arguments.\n" ; fc ())

  let axiom_atom =
    specialize `Right
      (make_matcher
         (function
            | Formula(_,(_,FOA.ApplicationFormula ((FOA.AtomicFormula _),_))) ->
                true
            | _ -> false))
  let axiom_mu =
    specialize `Right
      (make_matcher
         (function
            | Formula(_,
                (_,FOA.ApplicationFormula
                    ((FOA.FixpointFormula (FOA.Inductive,_,_,_)),_))) -> true
            | _ -> false))
      ~arg:"init"
  let axiom_nu =
    specialize `Left
      (make_matcher
         (function
            | Formula(_,
                (_,FOA.ApplicationFormula
                    ((FOA.FixpointFormula (FOA.CoInductive,_,_,_)),_))) -> true
            | _ -> false))
      ~arg:"init"
  let axiom s a =
    G.orElseTactical (axiom_atom s a)
      (G.orElseTactical (axiom_mu s a) (axiom_nu s a))

  (** {1 Structural rules} *)

  let contractL =
    let tactic session seq f zip lhs rhs sc fc =
      sc [{seq with lhs = zip [f;f]}]
    in
      makeSimpleTactical "contract_l" (matchLeft, "_") tactic

  let contractR =
    let tactic session seq f zip lhs rhs sc fc =
      sc [{seq with rhs = zip [f;f]}]
    in
      makeSimpleTactical "contract_r" (matchRight, "_") tactic

  let weakL =
    let tactic session seq f zip lhs rhs sc fc =
      sc [{ seq with lhs = zip [] }]
    in
      makeSimpleTactical "weak_l" (matchLeft, "_") tactic

  let weakR =
    let tactic session seq f zip lhs rhs sc fc =
      sc [{ seq with rhs = zip [] }]
    in
      makeSimpleTactical "weak_r" (matchRight, "_") tactic

  let weakTactical session args =
    G.orElseTactical (weakL session args) (weakR session args)

  let contractTactical session args =
    G.orElseTactical (contractL session args) (contractR session args)

  (********************************************************************
  *rotateL, rotateR:
  * Rotate the current sequents to the left or right to change the
  * 'active' sequent (as most rules work on the first sequent only).
  * These don't really have a meaning in the logic.
  ********************************************************************)
  let rotateL session params seqs success failure =
    match seqs with
      | { lhs = [] } :: _ -> failure ()
      | ({ lhs = l::ltl } as seq)::tl ->
          success [{ seq with lhs = ltl@[l] }] tl (fun p -> p) failure
      | [] -> assert false

  let rotateR session params seqs success failure =
    match seqs with
      | ({ rhs = [] })::_ -> failure ()
      | ({ rhs = l::rtl } as seq)::tl ->
          success [{ seq with rhs = rtl@[l] }] tl (fun p -> p) failure
      | [] -> assert false

  (** {1 Meta-rules} *)

  (** Force unification between two terms. *)
  let forceTactical session args =
    match args with
      | Absyn.String(seqstring)::Absyn.String(term)::[] ->
            let seqterm = parseTerm seqstring in
            let unterm = parseTerm term in
            if Option.isSome seqterm && Option.isSome unterm then
              let seqterm = Option.get seqterm in
              let unterm = Option.get unterm in
              (* pretactic: simply unifies the two terms. *)
              let pretactic = fun seq sc fc ->
                match FOA.rightUnify seqterm unterm with
                    FOA.UnifySucceeded(s) ->
                      let fc' () =
                        (FOA.undoUnify s;
                        fc ())
                      in
                      let pb = List.hd in
                      sc [seq] pb fc'
                  | FOA.UnifyFailed -> fc ()
                  | FOA.UnifyError(s) ->
                      (O.error (s ^ ".\n");
                      fc ())
              in
              G.makeTactical pretactic
            
            else
              (if Option.isNone seqterm then O.error "invalid sequent term.\n"
              else ();
              if Option.isNone unterm then O.error "invalid unification term.\n"
              else ();
              G.failureTactical)
      | _ -> (G.invalidArguments "unify")

  (** The cut rule.
    * This implementation is not satisfying for a classical logic. *)
  let cutTactical session args =
    match args with
      | Absyn.String(s)::[] ->
          let f = parseFormula session.definitions s in
            begin match f with
              | None -> O.error "unable to parse lemma.\n" ; G.failureTactical
              | Some f ->
                  let pretactic = fun sequent sc fc ->
                    let f' = Formula (0,f) in
                    (* TODO classical cut *)
                    let s1 = { sequent with rhs = [f'] } in
                    let s2 = { sequent with lhs = sequent.lhs @ [f'] } in
                    let pb = makeProofBuilder "cut" ~p:["formula",s] sequent in
                      sc [s1; s2] pb fc
                  in
                    G.makeTactical pretactic
            end
      | _ -> G.invalidArguments "cut"

  (** {1 Simplifying strategy}
    * Apply all non-branching invertible rules.
    * Handling units (true/false) requires to work on atoms on both sides. *)
  let simplify_matcher_l = (* TODO use annotations more ? *)
    make_matcher
      (fun (Formula(i,(_,f))) ->
         match f with
           | FOA.BinaryFormula (FOA.And,_,_)
           | FOA.QuantifiedFormula ((FOA.Nabla|FOA.Sigma),_)
           | FOA.EqualityFormula _
           | FOA.ApplicationFormula ((FOA.AtomicFormula _),_) -> true
           | _ -> false)

  let simplify_matcher_r =
    make_matcher
      (fun (Formula(i,(_,f))) ->
         match f with
           | FOA.QuantifiedFormula ((FOA.Nabla|FOA.Pi),_)
           | FOA.BinaryFormula (FOA.Imp,_,_)
           | FOA.EqualityFormula _
           | FOA.ApplicationFormula ((FOA.AtomicFormula _),_) -> true
           | FOA.BinaryFormula (FOA.Or,_,_) -> not Param.intuitionistic
           | _ -> false)

  let simplifyTactical session args = match args with
    | [] ->
        G.repeatTactical
          (G.orElseTactical
            (intro `Left  simplify_matcher_l session None)
            (intro `Right simplify_matcher_r session None))
    | _ -> G.invalidArguments "simplify"

  (** {1 Nabla elimination}
    * The abstract tactic implements the reduction of nabla to liftings. *)
  let abstractTactical session args =
    let rec n_downto_1 = function
      | 0 -> []
      | n -> n :: n_downto_1 (n-1)
    in
    let abstract seq =
      (* Compute the nabla-normal form of every formula in the sequent.
       * it may be more convenient to be able to target a specific one. *)
      let abstract (Formula(i,form)) =
        let tv = List.map Term.nabla (n_downto_1 i) in
        let form = (FOA.eliminateNablas tv).FOA.polf form in
          Formula(0,form)
      in
        { seq with lhs = List.map abstract seq.lhs ;
                   rhs = List.map abstract seq.rhs }
    in
    fun seqs sc fc ->
      match seqs with
        | s::tl -> sc [abstract s] tl (fun proofs -> proofs) fc
        | _ -> fc ()

  (********************************************************************
  *applyTactical:
  * Searches the list of lemmas and adds the lemma of the given name
  * to the hypotheses.  Additionally modifies the proof builder to insert
  * the proof of the lemma in the appropriate place.
  ********************************************************************)
  let applyTactical session args = match args with
      Absyn.String(s)::[] ->
        (try
          let (_,formula,proof) = List.find (fun (s',_,_) -> s = s') session.lemmas in
          let pretactic = fun sequent sc fc ->
            let seq = { sequent with lhs = sequent.lhs @ [formula] } in
            let pb = fun proofs ->
              { rule = "apply" ;
              params = ["lemma", s] ;
              bindings = [] ;
              formula = Some formula ;
              sequent = seq ;
              subs = proof::proofs }
            in
            sc [seq] pb fc
          in
            G.makeTactical pretactic
        with
          Not_found -> (O.error "undefined lemma.\n" ; G.failureTactical))
    | _ -> G.invalidArguments "apply"

  (** {1 Debugging}
    * The examine tactic is useful for debugging. *)
  let examineTactical session args = match args with
    | [] ->
        fun sequents sc fc ->
          let seq = List.hd sequents in
          let lhs =
            String.concat "\n  " (List.map string_of_formula_ast seq.lhs)
          in
          let rhs =
            String.concat "\n  " (List.map string_of_formula_ast seq.rhs)
          in
            O.output
              (Printf.sprintf
                 "Sequent AST:\n  %s\n----------------------------\n  %s\n"
                 lhs rhs) ;
            sc [] sequents Logic.idProofBuilder fc
    | _ -> G.invalidArguments "examine"

  let examinePatternTactical session args = match args with
    | [Absyn.String(s)] ->
        let p = parsePattern s in
        if Option.isNone p then
          G.invalidArguments "examine"
        else
          fun sequents sc fc ->
            O.output ("Pattern: " ^ (FOA.string_of_pattern_ast (Option.get p)) ^ ".\n");
            sc [] sequents Logic.idProofBuilder fc
    | _ -> G.invalidArguments "examine"
  (** {1 Focusing strategy} *)

  (********************************************************************
  *cutThenTactical, cutRepeatTactical:
  * Similar to then and repeat, but backtracking only happens over the
  * whole tactical, not over individual tactics within the tactical.
  * The restorer is needed to handle the 'big' backtrack at the end, as
  * the regular functionality (handled by success and failure
  * continuations) isn't invoked.  The point of these tacticals is
  * purely efficiency concerns.
  ********************************************************************)
  let cutThenTactical, cutRepeatTactical =
    let restorer () =
      let s = Term.save_state () in
      fun () -> Term.restore_state s
    in
      G.cutThenTactical restorer,
      G.cutRepeatTactical restorer

  (** AtomicFormula includes the units (true/false).
    * The Negative polarity is actually never used, and the whole polarity
    * design is too weak as the polarity is set only at toplevel and not on
    * subformulas.
    * Hence, the "polarity" of mu/nu is currently fixed to resp. pos/neg. *)
  
  (** The focused proof-search strategy makes use of building blocks
    * which process one sequent at a time, glued together using Then (and an
    * underlying Iterate) in order to get a tactic processing several goals in
    * parallel.
    * The problem is that this model hides some information. The asynchronous
    * phase, in presence of fixed points, can produce several alternative lists
    * of subgoals, which might easily have the first goal in common.
    * Using iterate, if you notice that the first goal is impossible, you can
    * just ask async for more data, and get the second alternative, which might
    * have the same impossible first goal.
    * An example of that is (nat x => nat y): the first possibility is to freeze
    * (nat x), all the others produce a subgoal (x=0 => nat y) which is
    * impossible.
    * A better strategy would be to start the focusing phase as soon as one goal
    * is produced and fail earlier (at the level of the first choice to unfold
    * nat). TODO remove this comment I think I fixed this -- david *)

  (** In automatic mode, intro doesn't really need a session. *)
  let automaticIntro side matcher = intro side matcher dummy_session None

  let fixpoint = function
    | FOA.ApplicationFormula ((FOA.FixpointFormula _),_) -> true
    | _ -> false

  (** The decide rule focuses on a synchronous formula.
    * This tactic takes a single sequent and its successes are single sequents
    * too.
    * The freeze tactic works the same way, even though it has nothing to do
    * with decide. *)
  let focus,focusRight,freezeLeft =
    let matcher fl = make_matcher (fun (Formula(i,f)) -> fl f) in
    let focus (Formula(i,(a,f))) =
      Formula (i,({a with FOA.control=FOA.Focused},f))
    in
    let freeze (Formula(i,(a,f))) =
      Formula (i,({a with FOA.freezing=FOA.Frozen},f))
    in

    (* Find a formula on the right satisfying fr,
     * succeed with the sequent resulting of the application of focus to it.
     * On failure, if b, keep searching on the left with tac_l and fl. *)
    let rec tac_r before after seq sc fc focus fl fr b =
      match matcher fr after with
        | Some (f,before',after) ->
            let before = before @ before' in
              if Properties.getBool "firstorder.proofsearchdebug" then
                Format.printf "%s@[<hov 2>Focus right@ %s@]\n%!"
                  (String.make
                     (match seq.bound with Some b -> max 0 b | None -> 0)
                     ' ')
                  (string_of_formula f) ;
              sc
                { seq with rhs = before @ [ focus f ] @ after }
                (fun () -> tac_r (before@[f]) after seq sc fc focus fl fr b)
        | None ->
            if b then
              tac_l [] seq.lhs seq sc fc focus fl fr false
            else
              fc ()

    and tac_l before after seq sc fc focus fl fr b =
      match matcher fl after with
        | Some (f,before',after) ->
            let before = before @ before' in
            if Properties.getBool "firstorder.proofsearchdebug" then
              Format.printf "%s@[<hov 2>Focus left@ %s@]\n%!"
                (String.make
                   (match seq.bound with Some b -> max 0 b | None -> 0)
                   ' ')
                (string_of_formula f) ;
            sc
              { seq with lhs = before @ [ focus f ] @ after }
              (fun () -> tac_l (before@[f]) after seq sc fc focus fl fr b)
        | None ->
            if b then
              tac_r [] seq.rhs seq sc fc focus fl fr false
            else
              fc ()
    in
    (*  focus *)
    (fun seq sc fc ->
       tac_l
         [] seq.lhs seq sc fc focus
         (fun (a,_) -> a.FOA.control<>FOA.Focused &&
                       a.FOA.polarity=FOA.Negative)
         (fun (a,_) -> a.FOA.control<>FOA.Focused &&
                       a.FOA.polarity=FOA.Positive)
         true),
    (*  focusRight  *)
    (fun seq sc fc ->
       tac_r
         [] seq.rhs seq sc fc focus
         (fun (a,_) -> a.FOA.control<>FOA.Focused &&
                       a.FOA.polarity=FOA.Negative)
         (fun (a,_) -> a.FOA.control<>FOA.Focused &&
                       a.FOA.polarity=FOA.Positive)
         true),
    (*  freezeLeft  *)
    (fun seq sc fc ->
       tac_l
         [] seq.lhs seq sc fc freeze
         (fun (a,f) -> a.FOA.freezing=FOA.Unfrozen && fixpoint f)
         (fun (a,f) -> a.FOA.freezing=FOA.Unfrozen && fixpoint f)
         true)


  (** The reaction rule removes the focus from an asynchronous formula. *)
  let unfocus =
    let matcher_l =
      make_matcher
        (fun (Formula(i,(a,f))) ->
           a.FOA.control=FOA.Focused && a.FOA.polarity=FOA.Positive)
    in
    let matcher_r =
      make_matcher
        (fun (Formula(i,(a,f))) ->
           a.FOA.control=FOA.Focused && a.FOA.polarity=FOA.Negative)
    in
    let unfocus (Formula(i,(a,f))) =
      Formula (i,({ a with FOA.control = FOA.Normal },f))
    in
      (fun seq ->
         match matcher_l seq.lhs with
           | Some (f,before,after) ->
               if Properties.getBool "firstorder.proofsearchdebug" then
               Printf.printf "%sRelease left %s\n%!"
                 (String.make
                    (match seq.bound with Some b -> max 0 b | None -> 0) ' ')
                 (string_of_formula f)
                 (* (xml_of_sequent seq) *);
               Some { seq with lhs = before @ [ unfocus f ] @ after }
           | None ->
               begin match matcher_r seq.rhs with
                 | Some (f,before,after) ->
                     if Properties.getBool "firstorder.proofsearchdebug" then
                     Printf.printf "%sRelease right %s\n%!"
                       (String.make
                          (match seq.bound with Some b -> max 0 b | None -> 0)
                          ' ')
                       (string_of_formula f)
                       (* (xml_of_sequent seq) *) ;
                     Some { seq with rhs = before @ [ unfocus f ] @ after }
                 | None -> None
               end)

    (** "Finite" async connectives can be introduced eagerly without backtrack.
      * For the fixed points (mu on the left, nu on the right) there is a choice
      * of "opening" or "freezing", over which backtrack should be possible.
      * However we treat specially fixed points for which unfolding progresses,
      * since their unfolding is not a commitment and cannot yield loops. *)
    let finite =
      cutRepeatTactical
        (G.orElseListTactical
           [ automaticIntro `Left
               (make_matcher
                 (fun (Formula(i,(a,f))) ->
                    not (fixpoint f || a.FOA.polarity=FOA.Negative))) ;
             automaticIntro `Right
               (make_matcher
                 (fun (Formula(i,(a,f))) ->
                    not (fixpoint f || a.FOA.polarity=FOA.Positive))) ;
             intro `Left
               (make_matcher (function
                                | Formula(i,(a,
                                    FOA.ApplicationFormula(
                                      FOA.FixpointFormula(
                                        FOA.Inductive,_,argnames,_),args))) ->
                                    a.FOA.freezing = FOA.Unfrozen &&
                                    unfoldingProgresses argnames args
                                | _ -> false))
               dummy_session (Some "unfold") ;
             automaticIntro `Right
               (make_matcher (function
                                | Formula(i,(a,
                                    FOA.ApplicationFormula(
                                      FOA.FixpointFormula(
                                        FOA.CoInductive,_,argnames,_),args))) ->
                                    a.FOA.freezing = FOA.Unfrozen &&
                                    unfoldingProgresses argnames args
                                | _ -> false)) ])
                                
    (* TODO note that the treatment of fixed points is not based on polarities
     * but the roles of mu/nu are hardcoded. *)

    (** Matchers for fixed points without a progressing unfolding. *)

    let left_no_progress =
      make_matcher
        (fun (Formula(i,(a,f))) ->
           match f with
             | FOA.ApplicationFormula
                (FOA.FixpointFormula (FOA.Inductive,_,argnames,_), args) ->
                a.FOA.freezing = FOA.Unfrozen &&
                not (unfoldingProgresses argnames args)
             | _ -> false)
    let right_no_progress =
      make_matcher
        (fun (Formula(i,(a,f))) ->
           match f with
             | FOA.ApplicationFormula
                (FOA.FixpointFormula (FOA.CoInductive,_,argnames,_), args) ->
                a.FOA.freezing = FOA.Unfrozen &&
                not (unfoldingProgresses argnames args)
             | _ -> false)

    (** Apply a rule on the focused formula if it is synchronous. *)
    let sync_step =
      G.orElseTactical
        (automaticIntro `Left
          (make_matcher
             (fun (Formula(i,(a,f))) ->
               a.FOA.control=FOA.Focused && a.FOA.polarity=FOA.Negative)))
        (automaticIntro `Right
          (make_matcher
             (fun (Formula(i,(a,f))) ->
               a.FOA.control=FOA.Focused && a.FOA.polarity=FOA.Positive)))

  (** Focused proof-search, starting with the async phase. *)
  let rec full_async s sc fc =
    cutThenTactical finite freeze s sc fc

  (* Freeze the first available asynchronous fixed point,
   * takes care of unfoldings and re-calling full_async when needed. *)
  and freeze sequents sc fc =
    let async = cutThenTactical finite freeze in
    let seq = match sequents with [seq] -> seq | _ -> assert false in
      match left_no_progress seq.lhs with
       | Some (Formula(i,(a,f)), before, after) ->
           (* We can do induction, and unfolding doesn't progress.
            * So we'll only try freezing, then induction.
            * Unfolding might sometimes yield simpler proofs,
            * but trying it everytime seems costly... *)
           G.orElseTactical
             (fun _ ->
                if Properties.getBool "firstorder.proofsearchdebug" then
                  Format.printf "%s@[<hov 2>Freeze@ %s@]\n%!"
                    (String.make
                       (match seq.bound with Some b -> max 0 b | None -> 0)
                       ' ')
                    (string_of_formula (Formula(i,(FOA.freeze a,f))));
                freeze
                  [{seq with lhs =
                               before@[Formula(i,(FOA.freeze a,f))]@after }])
             (cutThenTactical
                (* The cut is needed here so that auto_intro doesn't try
                 * to induct on another Mu on the left. *)
                (fun _ ->
                   if Properties.getBool "firstorder.proofsearchdebug" then
                     Format.printf "%s@[<hov 2>Induction@ %s@]\n%!"
                       (String.make
                          (match seq.bound with Some b -> max 0 b | None -> 0)
                          ' ')
                       (string_of_formula (Formula(i,(a,f)))) ;
                   automaticIntro `Left left_no_progress [seq])
                async)
             [(*no args*)] sc fc
       | None ->
           begin match right_no_progress seq.rhs with
             | Some (Formula(i,(a,f)), before, after) ->
                 G.orElseTactical
                   (fun _ ->
                      freeze
                        [{seq with
                          rhs = before@[Formula(i,(FOA.freeze a,f))]@after }])
                   (cutThenTactical
                     (fun _ ->
                        automaticIntro `Right right_no_progress [seq])
                     async)
                   [(*no args*)] sc fc
             | None ->
                 (* Don't wait to collect all results of the async phase,
                  * check each immediately. *)
                 fullSync seq sc fc
           end

  (** Complete focused proof-search starting with a decide rule. *)
  and fullSync seq sc fc =
    focus seq
      (fun seq k -> sync [seq] sc k)
      fc

  and sync seqs sc fc =
    assert (List.length seqs = 1) ;
    sync_step seqs
      (fun n o b k ->
         G.iterateTactical sync (n@o)          (* succeeds on n@o=[] *)
           (fun n' o' b' k' ->
              assert (n'=[] && o'=[]) ;        (* sync is a complete tactic *)
              sc [] [] (fun l -> b (b' l)) k') (* expect l = [] *)
           k)
      (fun () ->
         match unfocus (List.hd seqs) with
           | Some seq -> full_async [seq] sc fc
           | None -> fc ())

  let setBound session args seqs sc fc =
    let n = match args with [Absyn.String n] -> int_of_string n | _ -> 3 in
    match seqs with
     | ({bound=_} as seq)::tl ->
         sc [{seq with bound = Some n}] tl (fun proofs -> proofs) fc
     | [] -> fc ()

  (********************************************************************
  *proveTactical:
  * The frontend to automatic proof search. Simply sets the bound
  * using the given arguments and commences search.
  ********************************************************************)
  let proveTactical session args =
    (* Set a bound to the number of unfoldings,
     * which by the way restricts our attention to the first sequent.
     * There is no need to force full_async to complete, since it never returns
     * partial successes by design. *)
    G.thenTactical (setBound session args) full_async

  (********************************************************************
  *admitTactical:
  * A tactical that proves everything! It just kills the current
  * sequent; only useful when testing or experimenting, or when you
  * know that the current sequent can be proved and you don't want
  * to bother.
  ********************************************************************)
  let admitTactical session args = match args with
        [] ->
          (G.admitTactical (fun seq ->
            {rule="admit"; 
            formula=None;
            sequent=seq;
            params=[];
            bindings=[];
            subs=[]}))
      | _ -> G.invalidArguments "admit"

  (********************************************************************
  ********************************************************************)
  let pervasiveTacticals =
    let (++) t (a,b) = Logic.Table.add a b t in
    let (||) a b =
      fun session args -> G.orElseTactical (a session args) (b session args)
    in

    let ts =
      G.tacticals
        ++ ("admit", admitTactical)

        ++ ("and", andL||andR)
        ++ ("and_l", andL)
        ++ ("and_r", andR)

        ++ ("apply", applyTactical)
        
        ++ ("imp", impL||impR)
        ++ ("imp_l", impL)
        ++ ("imp_r", impR)

        ++ ("pi", piL||piR)
        ++ ("pi_l", piL)
        ++ ("pi_r", piR)

        ++ ("sigma", sigmaL||sigmaR)
        ++ ("sigma_l", sigmaL)
        ++ ("sigma_r", sigmaR)

        ++ ("nabla", nablaL||nablaR)
        ++ ("nabla_l", nablaL)
        ++ ("nabla_r", nablaR)

        ++ ("eq", eqL||eqR)
        ++ ("eq_l", eqL)
        ++ ("eq_r", eqR)

        ++ ("axiom", axiom)

        ++ ("mu_l", muL)
        ++ ("mu_r", muR)
        ++ ("nu_l", nuL)
        ++ ("nu_r", nuR)
        ++ ("induction", inductionTactical)
        ++ ("coinduction", coinductionTactical)

        ++ ("examine", examineTactical)
        ++ ("examine_pattern", examinePatternTactical)

        ++ ("simplify", simplifyTactical)

        ++ ("true", trueR)
        ++ ("false", falseL)
        ++ ("trivial", trueR||falseL)

        ++ ("weak_l", weakL)
        ++ ("contract_l", contractL)

        ++ ("cut", cutTactical)
        ++ ("force", forceTactical)
        ++ ("prove", proveTactical)
        ++ ("async", fun _ _ -> finite)
        ++ ("focus",
            fun _ _ ->
              G.makeTactical
                (fun seq sc fc -> focus seq (fun s k -> sc [s] List.hd k) fc))
        ++ ("focus_r",
            fun _ _ ->
              G.makeTactical
                  (fun seq sc fc ->
                     focusRight seq (fun s k -> sc [s] List.hd k) fc))
        ++ ("freeze",
            fun _ _ ->
              G.makeTactical
                (fun seq sc fc -> freezeLeft seq (fun s k -> sc [s] List.hd k) fc))
        ++ ("unfocus",
              fun _ _ ->
                G.makeTactical
                  (fun seq sc fc ->
                     match unfocus seq with
                       | Some s -> sc [s] List.hd fc
                       | None -> fc ()))
        ++ ("sync", fun _ _ -> sync_step) 
        ++ ("set_ound", setBound)

        ++ ("abstract", abstractTactical)
    in

    (* Which structural rules to admit. *)
    let ts =
      let ts =
        if Param.intuitionistic then
          ts
        else
          ts
            ++ ("weak_r", weakR)
            ++ ("contract_r", contractR)
            ++ ("rotate_r", rotateR)
      in
        ts
          ++ ("weak_l", weakL)
          ++ ("contract_l", contractL)
          ++ ("rotate_l", rotateL)
    in

    (* Which disjunction tactics are meaningful. *)
    let ts =
      let ts =
        if Param.intuitionistic then
          ts
            ++ ("left", orLeft)
            ++ ("right", orRight)
        else
          ts
            ++ ("or_r", orR)
            ++ ("or", orL||orR)
      in
        ts ++ ("or_l", orL)
    in
    ts

  (** The empty session starts with the expected empty list of sequents
    * and initial list of tacticals, as well as an empty definition table.
    * Additionally it includes the identity proof builder for simplicity
    * (instead of, say, an option), as well as undo, redo, and namespace
    * info. *)
  let emptySession =
    let state = Term.save_state () in
    let ns = Term.save_namespace () in
      { tactics = pervasiveTacticals ; definitions = Logic.Table.empty ;
        sequents = [] ; builder = Logic.idProofBuilder ;
        state = state ; diff = Term.get_subst state ;
        initial_namespace = ns ; proof_namespace = ns;
        theorem_name = None;
        theorem = None;
        lemmas = []}

  (********************************************************************
  *reset:
  * Provides a new sequent.  This amounts to returning the empty
  * sequent.
  ********************************************************************)
  let reset =
    let initialNamespace = Term.save_namespace () in
      fun () ->
        Term.restore_namespace initialNamespace ;
        emptySession

end

module Firstordernonstrict =
  Firstorder (struct
    let name = "First Order Classical Logic with Non-Strict Nabla"
    let strictNabla = false
    let intuitionistic = false
  end)

module Firstorderstrict =
  Firstorder (struct
    let name = "First Order Classical Logic with Strict Nabla"
    let strictNabla = true
    let intuitionistic = false
  end)

module MuLJstrict =
  Firstorder (struct
    let name = "Mu-LJ with Strict Nabla"
    let strictNabla = true
    let intuitionistic = true
  end)

module MuLJnonstrict =
  Firstorder (struct
    let name = "Mu-LJ with Non-Strict Nabla"
    let strictNabla = false
    let intuitionistic = true
  end)
