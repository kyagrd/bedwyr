(**********************************************************************
* Taci                                                                *
* Copyright (C) 2007 Zach Snow, David Baelde                          *
*                                                                     *
* This program is free software; you can redistribute it and/or modify*
* it under the terms of the GNU General Public License as published by*
* the Free Software Foundation; either version 2 of the License, or   *
* (at your option) any later version.                                 *
*                                                                     *
* This program is distributed in the hope that it will be useful,     *
* but WITHOUT ANY WARRANTY; without even the implied warranty of      *
* MERCHANTABILITY or FITNESS FOR A PARTICUFOAR PURPOSE.  See the      *
* GNU General Public License for more details.                        *
*                                                                     *
* You should have received a copy of the GNU General Public License   *
* along with this code; if not, write to the Free Software Foundation,*
* Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA        *
**********************************************************************)

let debug = false

(**********************************************************************
*NablaSig:
* Acts as a parameter to Firstorder in order to change properties of
* the logic generated by Firstorder.
**********************************************************************)
module type ParamSig =
sig
  (** The print name of the logic. *)
  val name : string

  (** Determines whether or not strict nabla comparisons are used in the
    * axiom rule. *)
  val strictNabla : bool
  
  (** Indicates whether the logic is intuitionistic instead of classical. *)
  val intuitionistic : bool
end

(**********************************************************************
*Firstorder:
* Implements a simple first order logic.  The logic includes equality
* and fixed points, with a definition-like facility to handle them.
**********************************************************************)
module Firstorder (Param : ParamSig) (O : Output.Output) : Logic.Logic =
struct
  module FOA = Firstorderabsyn
  exception NonMonotonic


  let name = Param.name
  let info = Param.name ^ "\n"
  let start = info
  
  (********************************************************************
  *Formula:
  * Represent formulae in sequents, with a local context, a marker
  * indicating focusedness, and a polarity.  The polarity is only
  * relevant for atoms.
  ********************************************************************)
  type marktype =
      Focused
    | Nonfocused
    | Frozen

  type polarity =
      Positive
    | Negative

  (** A formula has a local level, and an annotation. *)
  type formula = Formula of (int * (marktype * polarity) * FOA.formula)

  let string_of_formula (Formula(local,_,t)) =
    let generic = Term.get_dummy_names ~start:1 local "n" in
    let result = FOA.string_of_formula ~generic t in
      List.iter Term.free generic ;
      (String.concat "," generic) ^ ">> " ^ result

  let string_of_formula_ast (Formula(local,(m,_),t)) =
    let generic = Term.get_dummy_names ~start:1 local "n" in
    let result = FOA.string_of_formula_ast ~generic t in
      List.iter Term.free generic ;
      (String.concat "," generic) ^ ">> " ^
      if m = Focused then
        "[" ^ result ^ "]"
      else
        result

  let xml_of_formula (Formula(local,(m,p),t)) = 
    let generic = Term.get_dummy_names ~start:1 local "n" in
    let result = FOA.string_of_formula ~generic t in
    let quasi_atomic = function
      | FOA.ApplicationFormula _ | FOA.AtomicFormula _ -> true | _ -> false
    in
      (* TODO turn => into =&gt; *)
      List.iter Term.free generic ;
      Printf.sprintf "<formula%s%s>%s%s</formula>"
        (match m with
           | Nonfocused -> ""
           | Focused -> " mark=\"focused\"" | Frozen -> " mark=\"frozen\"")
        (if not (quasi_atomic t) then "" else
           Printf.sprintf
             " polarity=\"%s\""
             (if p=Positive then "positive" else "negative"))
        (if generic = [] then "" else
           "<generic>" ^ String.concat "," generic ^ "</generic>")
        result

  let getFormulaFormula  (Formula(_,(_,_),f)) = f
  let getFormulaMarker   (Formula(_,(m,_),_)) = m
  let getFormulaPolarity (Formula(_,(_,p),_)) = p
  let getFormulaLevel    (Formula(i,(_,_),_)) = i
  let makeFormula t = Formula(0, (Nonfocused,Positive), t)

  let string_of_definition def = FOA.string_of_definition def
  
  (********************************************************************
  *Sequent:
  * A sequent has a left and right side, each a list of formulas, along
  * with an index approximating its signature (set of eigenvariables).
  ********************************************************************)
  type sequent = {
    lvl : int ;
    lhs : formula list ;
    rhs : formula list ;
    bound : int option
  }

  let update_bound = function
    | {bound = None} -> None
    | {bound = Some b} -> Some (b-1)

  let string_of_sequent seq =
    let top       = String.concat "\n" (List.map string_of_formula seq.lhs) in
    let bottom    = String.concat "\n" (List.map string_of_formula seq.rhs) in
    let separator = String.make (max (min (String.length bottom) 72) 16) '-' in
      Printf.sprintf "%s\n%d: %s\n%s" top seq.lvl separator bottom

  let ppxml_sequent fmt seq =
    let print_side side forms =
      Format.fprintf fmt "<%s>@," side ;
      List.iter (fun f -> Format.fprintf fmt "%s@," (xml_of_formula f)) forms ;
      Format.fprintf fmt "</%s>" side
    in
      Format.fprintf fmt "@[<><sequent><level>%d</level>@,@[<hov 2>" seq.lvl ;
      print_side "lhs" seq.lhs ;
      Format.fprintf fmt "@," ;
      print_side "rhs" seq.rhs ;
      Format.fprintf fmt "@]</sequent>@]"

  let xml_of_sequent seq =
    ppxml_sequent Format.str_formatter seq ; Format.flush_str_formatter ()

  let string_of_sequent_rhs seq =
    let bottom    = String.concat "\n" (List.map string_of_formula seq.rhs) in
    let separator = String.make (max (min (String.length bottom) 72) 16) '-' in
      Printf.sprintf "%d: %s\n%s" seq.lvl separator bottom

  let out_of_bound = function
    | None -> false
    | Some b -> b < 0

  (********************************************************************
  *Proof:
  ********************************************************************)
  type proof = string

  (********************************************************************
  *Session:
  * A session is:
  *   tactical table
  *   definition table
  *   sequents
  *   proof builder
  *   undo info
  *   redo info
  ********************************************************************)  
  type session = {
    tactics :
      (session, (sequent, proof) Logic.tactic) Logic.tactical Logic.table ;
    definitions : FOA.definition Logic.table ;
    sequents : sequent list ; (* current goals *)
    builder : proof Logic.proofbuilder ;
    state : Term.state ;
    diff : Term.subst ;
    initial_namespace : Term.namespace ;
    proof_namespace   : Term.namespace
  }

  let dummy_session = {
    tactics = Logic.Table.empty ; definitions = Logic.Table.empty ;
    sequents = [] ; builder = (fun _ -> assert false) ;
    state = Term.save_state () ; diff = Term.get_subst (Term.save_state ()) ;
    initial_namespace = Term.save_namespace () ;
    proof_namespace = Term.save_namespace () ;
  }

  let sequents session = session.sequents
  let validSequent session = [] <> session.sequents

  let tacticals session = session.tactics
  let defineTactical name tac session =
    let ts = session.tactics in
    let ts' = Logic.Table.add name tac ts in
      { session with tactics = ts' }

  let proof session = session.builder

  let undo session =
    Term.restore_state session.state ;
    session

  let redo session =
    (* The idea would be to use the diff field to redo,
     * but this is actually unused and not implemented. *)
    assert false

  (** Updating to new sequents and proof builders.
    * This has to come with the storage of the current state,
    * used when coming back to that point by undoing. *)
  let update sequents builder session =
    let state = Term.save_state () in
    let subst = Term.get_subst state in
      { session with state = state ; diff = subst ;
                     sequents = sequents ; builder = builder }

  let string_of_proofs session =
    Term.restore_namespace session.proof_namespace ;
    let proofs = session.builder [] in
      String.concat "" proofs

  (** This is called by the interface to print the currently open leafs.
    * The sequent is printed from within a namespace which has only the
    * constants defined in the theorem's statement (one doesn't want to observe
    * the effects of invisible logic or eigen-variables) and the namespace
    * is left in the state after that printing, so that the next input
    * can rely on what has been displayed. *)
  let string_of_sequents session =
    let sequents = session.sequents in
      Term.restore_namespace session.proof_namespace ;
      match sequents with
        | [] -> ""
        | mainseq::seqs ->
            if [] <> seqs then
              (string_of_sequent mainseq)
              ^ "\n\n" ^
              (String.concat "\n\n" (List.map string_of_sequent_rhs seqs))
              ^ "\n"
            else
              (string_of_sequent mainseq) ^ "\n"

  (********************************************************************
  *incl:
  * Given a list of files, include all definitions in them.  This is
  * not implemented.
  ********************************************************************)
  let incl files session =
    O.error "'#include.' not implemented.\n";
    session

  (********************************************************************
  *parseTerm:
  * Parses the argument into a term using the ocamlyacc grammar (see
  * firstorderparser.mly).  If successful, returns Some with the parsed
  * term, otherwise it returns None.
  ********************************************************************)
  let parseTerm t =
    try
      let term =
        Firstorderparser.toplevel_term
          Firstorderlexer.token (Lexing.from_string t)
      in
        Some term
    with
      | FOA.SyntaxError(s) ->
          O.error (s ^ ".\n");
          None

  let generateSymbol =
    let currentId = ref (-1) in
      fun () ->
        incr currentId ;
        ("_" ^ (string_of_int !currentId))

  (********************************************************************
  *replaceApplications:
  * Replaces applications in a formula with the correct definition,
  * if one exists.  If the application doesn't have the correct number
  * of arguments (relative to the body of the definition) then new
  * arguments are created to bring the number up to the correct amount,
  * and abstractions are inserted.  If the atom being replaced is under
  * any abstractions, the body of the definition that is being inserted
  * must be abstracted the same number of times as the atom is under
  * abstractions.
  ********************************************************************)
  let replaceApplications defs formula =
    (******************************************************************
    *makeArgs:
    * Generates a list of new names of length i.  This is only used
    * if the incorrect number of arguments were applied to a definition,
    * for example if using the body of definition as an invariant.
    ******************************************************************)
    let rec makeArgs i =
      if i = 0 then
        []
      else
        (generateSymbol ()) :: makeArgs (i - 1)
    in
    
    (******************************************************************
    *abstractReplacement:
    * Abstracts the body of the definition so that it is under the
    * same number of abstractions as the atom being replaced was.
    ******************************************************************)
    let abstractReplacement lambdas f =
      List.fold_left (fun f _ -> FOA.abstractDummyWithoutLambdas f) f lambdas
    in
    
    (******************************************************************
    *makeAbstractions:
    * Used to abstract the body of a definition over the new arguments;
    * used in the case that too few arguments are passed to the
    * definition.
    ******************************************************************)
    let rec makeAbstractions args formula =
      match args with
        [] -> formula
      | a::aa ->  FOA.abstract a (makeAbstractions aa (formula))
    in

    let tf t = t in
    let rec ff lambdas f =
      match f with
          FOA.AtomicFormula(head,args) ->
            let def = Logic.find head defs in
            if (Option.isSome def) then
              let def = (Option.get def) in
              let arity = FOA.getDefinitionArity def in
              let body = FOA.getDefinitionBody def in
              if (arity = List.length args) then
                (FOA.ApplicationFormula(abstractReplacement lambdas body, args))
              else if arity > List.length args then
                let argnames = makeArgs (arity - (List.length args)) in
                let args' = args @ (List.map (Term.atom) argnames) in
                let f = (FOA.ApplicationFormula(abstractReplacement lambdas body, args')) in
                makeAbstractions argnames f
              else             
                raise (FOA.SemanticError("'" ^ head ^ "' applied to too many arguments"))
            else
              f
        | FOA.AbstractionFormula(n,body) ->
            FOA.AbstractionFormula(n, (ff (n::lambdas) body))
        | _ -> (FOA.mapFormula (ff lambdas) tf f)
    in
    (ff [] formula)
  
  (********************************************************************
  *processFormula:
  * Replaces applications with mu or nu formulas.
  ********************************************************************)
  let processFormula defs f =
    let f' = replaceApplications defs f in
    f'
    
  (********************************************************************
  *abstractFixpointDefinition:
  * Given a definition of the form FOA.MuFormula() or FOA.NuFormula(),
  * creates an abstracted application term that may be passed to 
  * FOA.applyFixpoint.
  ********************************************************************)
  let abstractFixpointDefinition f argnames =
    match f with
        FOA.MuFormula(_,_,body)
      | FOA.NuFormula(_,_,body) ->
          let args' = List.map
            (fun n -> Term.fresh ~name:"*" ~lts:0 ~ts:0 ~tag:Term.Constant)
            argnames in
          let f' = FOA.ApplicationFormula(f, args') in
          let f'' = (List.fold_right (FOA.abstractVar) args' f') in
          let () =
            O.debug ("Firstorder.abstractFixpointDefinition: " ^
                     (FOA.string_of_formula_ast ~generic:[] f'') ^ "\n")
          in
          f''
      | _ -> failwith "Firstorder.abstractFixpointDefinition: invalid formula."

  (********************************************************************
  *parseTemplate:
  * Parses the argument into a template.  If successful, returns Some
  * with the parsed template, otherwise it returns None.  Additionally,
  * checks to see if the passed template is surrounded in brackets.  If
  * it is, the resulting template is flagged as being "focused".
  ********************************************************************)
  let parseTemplate defs t =
    (*  focused: checks whether the template string is surrounded in
        brackets. *)
    let focused s =
      let len = String.length s in
      if len > 1 then
        s.[0] = '[' && s.[len - 1] = ']'
      else
        false
    in

    (*  strip: removes surrounding brackets.  *)
    let strip s =
      let len = String.length s in
      if len > 1 then
        String.sub s 1 (len - 2)
      else
        (O.impossible "Firstorder.parseTemplate: invalid focused template.\n";
        s)
    in

    try
      let (t, focus) =
        if focused t then
          ((strip t), Focused)
        else
          (t, Nonfocused)
      in

      let formula = Firstorderparser.toplevel_template Firstorderlexer.token (Lexing.from_string t) in
      Some (processFormula defs formula, focus)
    with
        FOA.SyntaxError(s) ->
          (O.error (s ^ ".\n");
          None)
      | FOA.SemanticError(s) ->
          (O.error (s ^ ".\n");
          None)
      | Parsing.Parse_error ->
          (O.error "Syntax error.\n";
          None)

  (********************************************************************
  *parseFormula:
  * Parses the argument into a formula.  If successful, returns Some
  * with the parsed formula, otherwise it returns None.
  ********************************************************************)
  let parseFormula defs t =        
    try
      let formula =
        Firstorderparser.toplevel_formula
          Firstorderlexer.token (Lexing.from_string t)
      in
      let () =
        O.debug ("Firstorder.parseFormula: formula: " ^
                 (FOA.string_of_formula ~generic:[] formula) ^ "\n")
      in
      let () =
        O.debug ("Firstorder.parseFormula: formula ast: " ^
                 (FOA.string_of_formula_ast ~generic:[] formula) ^ "\n")
      in
      Some (processFormula defs formula)
    with
        FOA.SyntaxError(s) ->
          (O.error (s ^ ".\n");
          None)
      | FOA.SemanticError(s) ->
          (O.error (s ^ ".\n");
          None)
      | Parsing.Parse_error ->
          (O.error "Syntax error.\n";
          None)

  (********************************************************************
  *parseDefinition:
  * Parses the argument into a definition.  If successful, returns Some
  * with the parsed definition, otherwise it returns None.
  ********************************************************************)
  let parseDefinition defs t =        
    try
      let FOA.PreDefinition(name,args,body,ind) = Firstorderparser.toplevel_definition Firstorderlexer.token (Lexing.from_string t) in
      let () =
        O.debug ("Firstorder.parseDefinition: predefinition ast:" ^
                 name ^ " " ^ (FOA.string_of_formula_ast ~generic:[] body) ^
                 ".\n")
      in
      let () =
        O.debug ("Firstorder.parseDefinition: predefinition: " ^
                 name ^ " " ^ (FOA.string_of_formula ~generic:[] body) ^
                 ".\n")
      in
      Some (FOA.PreDefinition(name,args,(replaceApplications defs body),ind))
    with
        FOA.SyntaxError(s) ->
          (O.error (s ^ ".\n");
          None)
      | FOA.SemanticError(s) ->
          (O.error (s ^ ".\n");
          None)
      | Parsing.Parse_error ->
          (O.error "Syntax error.\n";
          None)

  (********************************************************************
  *prove:
  * Parses the argument into a formula, and then prepares the session to
  * prove the formula.  It saves the namespaces so that after proving
  * the theorem constant names won't remain "used up".  It also sets
  * the session sequents to be exactly one sequent with the parsed
  * formula on the right.
  ********************************************************************)
  let prove name t session =
    Term.restore_namespace session.initial_namespace ;
    let f = parseFormula session.definitions t in
    let proofNamespace = Term.save_namespace () in
      match f with
        | Some f ->
            { session with
                  proof_namespace = proofNamespace ;
                  builder = Logic.idProofBuilder ;
                  sequents = [{ bound = None ;
                                lvl=0 ; lhs=[] ; rhs=[makeFormula f] }] }
        | None -> session

  (********************************************************************
  *definitions:
  * Given a list of strings representing possibly mutually-recursive
  * definitions, parses the definitions and adds them to the definition
  * table.
  ********************************************************************)
  let definitions defstrings session =
    (******************************************************************
    *processPreDefinitions:
    * Processes a list of mutually recursive predefinitions into
    * a list of definitions.
    ******************************************************************)
    let processPreDefinitions predefs =
      (****************************************************************
      *checkMonotonicity:
      * Determines whether a definition is monotonic.  A definition is
      * monotonic if none of its DB indices occur under an odd number
      * of negations.
      ****************************************************************)
      let checkMonotonicity body =
        let tf t = t in
        let rec ff db neg f =
          match f with
              FOA.ImplicationFormula(l,r) ->
                (ff db (neg + 1) l)
            | FOA.MuFormula(_,_,body)
            | FOA.NuFormula(_,_,body) ->
                (ff (db + 1) neg body)
            | FOA.DBFormula(_,_,db') ->
                if (db = db') && (neg mod 2) <> 0 then
                  raise NonMonotonic
                else
                  f
            | _ -> FOA.mapFormula (ff db neg) tf f
        in

        try
          (ignore (ff 0 0 body);
          true)
        with
          NonMonotonic -> false
      in
      
      (****************************************************************
      *makeFixpoint:
      * Makes a mu or nu formula based on the combinator type.
      ****************************************************************)
      let makeFixpoint ind name argnames body =
        match ind with
            FOA.Inductive ->
              FOA.MuFormula(name,argnames,body)
          | FOA.CoInductive ->
              FOA.NuFormula(name,argnames,body)
      in
      
      (****************************************************************
      *abstractDefinition:
      * Abstracts a definition.  Iterates over a definition body.
      * If it hits an application whose name is in the abstractions
      * list, it inserts the correct DB index.  If it hits an application
      * whose head is not in the abstractions list (but is in then pre-
      * definitions list), it adds the name to the abstractions list 
      * and abstracts the body of the pre-definition.
      ****************************************************************)
      let abstractDefinition abstractions f =
        (**************************************************************
        *getDB:
        * Get the DB index of a name.
        **************************************************************)
        let getDB name abs =
          let rec get name abs =
            match abs with
              [] -> None
            | a::abs' ->
                if a = name then
                  Some 0
                else
                  let r = (get name abs') in
                  if Option.isSome r then
                    Some (1 + (Option.get r))
                  else
                    None
          in
          let i = (get name abs) in
          i
        in
        
        (**************************************************************
        *findDefinition:
        * Finds a pre-definition in the pre-definition list.
        **************************************************************)
        let findDefinition name predefs =
          try
            let find name (FOA.PreDefinition(name',ids,formula,ind)) =
              name' = name
            in
            Some (List.find (find name) predefs)
          with
            Not_found -> None
        in
        
        
        let tf t = t in  
        let rec ff abstractions f =
          match f with
              FOA.AtomicFormula(head, args) ->
                let db = getDB head abstractions in
                if Option.isSome db then
                  FOA.ApplicationFormula
                    (FOA.DBFormula(0,head, Option.get db), args)
                else
                  let def = findDefinition head predefs in
                  if Option.isSome def then
                    let FOA.PreDefinition(_,argnames,f',ind) = (Option.get def) in
                    (makeFixpoint ind head argnames (ff (head::abstractions) f'))
                  else
                    f
            | _ -> (FOA.mapFormula (ff abstractions) tf f)
        in
        (ff abstractions f)
      in

      (****************************************************************
      *processPreDefinition:
      * Mu/Nu-abstracts the body of the predefinition, and wraps the body
      * in a Mu/Nu formula.
      ****************************************************************)
      let processPreDefinition (FOA.PreDefinition(name, ids, formula, ind)) =
        let formula' = abstractDefinition [name] formula in
        let formula'' = makeFixpoint ind name ids formula' in
        
        let result = FOA.Definition(name, List.length ids, formula'', ind) in
        if (checkMonotonicity formula'') then
          Some(result)
        else
          (O.output ("Warning: " ^ name ^ ": non-monotonic definition.\n");
          Some(result))
      in
      (List.map processPreDefinition predefs)
    in
    
    (******************************************************************
    *addDefinitions:
    * Given a list of definitions and a table, adds the definitions
    * to the table, but doesn't allow for redefinitions.
    ******************************************************************)
    let rec addDefinitions defs table =
      match defs with
        [] -> table
      | (FOA.Definition(name,arity,formula,ind) as def)::ds ->
          if (Logic.contains name table) then
            (O.error ("'" ^ name ^ "' already defined.\n");
            table)
          else
            let () =
              O.debug ("Firstorder.definitions: definition ast: " ^
                       (FOA.string_of_formula_ast ~generic:[] formula) ^ ".\n")
            in
            let () =
              O.output ("Definition: " ^ (string_of_definition def) ^ ".\n")
            in
            Logic.Table.add name def (addDefinitions ds table)
    in
        
    let predefs = List.map (parseDefinition session.definitions) defstrings in
    if (List.exists (Option.isNone) predefs) then
      (O.error "definitions contain errors.\n";
      session)
    else
      let defs = processPreDefinitions (List.map (Option.get) predefs) in
      if (List.exists (Option.isNone) defs) then
        (O.error ("definitions contain errors.\n");
        session)
      else
        let defs' = (List.map (Option.get) defs) in
        let defs'' = (addDefinitions defs' session.definitions) in
          { session with definitions = defs'' ;
              (* Always remember constants used in the new definitions. *)
              initial_namespace = Term.save_namespace () }

  (********************************************************************
  *copyFormula:
  * Copies a formula's eigen variables. Used before performing eqL.
  ********************************************************************)
  let copyFormula ?(copier=(Term.copy_eigen ())) (Formula(i,b,f)) =
    let copyTerm t = copier t in
    let rec copyFormula f = FOA.mapFormula copyFormula copyTerm f in
    (Formula(i,b,copyFormula f))

  (********************************************************************
  *makeExistentialVar/makeUniversalVar/makeNablaVar:
  * Makes a new Term var (see ndcore/term.mli) of the approriate type
  * and returns it along with the updated local context and sequent level.
  ********************************************************************)
  let makeExistentialVar hint lvl lts =
    let hint = String.capitalize hint in
    let var = Term.fresh ~name:hint ~lts:0 ~ts:lvl ~tag:Term.Logic in
    let rec raise_over x n =
      if n = 0 then x else
        Term.app (raise_over x (n-1)) [Term.nabla n]
    in
    let var = raise_over var lts in
    (lvl, var)

  let makeUniversalVar hint lvl lts =
    let lvl = lvl+1 in
    let var = Term.fresh ~name:hint ~lts:0 ~ts:lvl ~tag:Term.Eigen in
    let rec raise_over x n =
      if n = 0 then x else
        Term.app (raise_over x (n-1)) [Term.nabla n]
    in
    let var = raise_over var lts in
    (lvl, var)

  let makeNablaVar lvl i =
    (lvl, i + 1, Term.nabla (i + 1))

  (********************************************************************
  *Tacticals:
  ********************************************************************)
  module FirstorderSig =
  struct
    type logic_session = session
    type logic_sequent = sequent
    type logic_proof = proof
  end
  module G = Logic.GenericTacticals (FirstorderSig) (O)

  (********************************************************************
  *makeProofBuilder rule_name ~b:bound_vars ~p:rule_params ~f:formula seq:
  * Makes a proof builder for a simple inference rule.  Given the name
  * of the inference rule ('rule'), constructs a function that takes a
  * list of the proofs (strings) of the arguments (arg1...argN) to the
  * inference rule and returns a proof of the rule thusly:
  *
  *   rule<sequent>(arg1,arg2,...,argN)
  *
  * Unfortunately it doesn't do any tabbing or suchlike, so the output
  * is really ugly.
  ********************************************************************)
  (* TODO implement the ~b declaration to enhance display
   * the parallel bottom-up building of the proof is incompatible with that
   * => first build a tree, then print it using depth-first parsing,
   *    freeing the names of bound variables. *)
  let makeProofBuilder name ?(b=[]) ?(p=[]) ?f seq = fun proofs ->
    let s = Printf.sprintf "<rule><name>%s</name>\n" name in
    let p =
      List.map
        (fun (k,v) -> Printf.sprintf "<key>%s</key><value>%s</value>\n" k v)
        p
    in
    let s = List.fold_left (^) s p in
    let s =
      s ^ xml_of_sequent seq
    in
    let s = match f with
      | None -> s
      | Some f -> s ^ xml_of_formula f
    in
      s ^ "<sub>" ^ List.fold_left (^) "" proofs ^ "</sub>\n</rule>\n"

  (********************************************************************
  *findFormula:
  * Given a template and a list of formulas F, returns the first formula
  * that matches the template along with its context in F.
  ********************************************************************)
  let findFormula template marker formulas =
    O.debug ("Firstorder.findFormula: template: " ^
             (FOA.string_of_formula ~generic:[] template) ^ "\n") ;
    O.debug ("Firstorder.findFormula: template ast: " ^
             (FOA.string_of_formula_ast ~generic:[] template) ^ "\n") ;
    let rec find front formulas =
      match formulas with
        [] ->
          let () = O.debug "Firstorder.findFormula: not found.\n" in
          None
      | formula::fs ->
          let Formula(i,(marker',_),f) = formula in
          if (marker = Nonfocused || marker = marker') &&
             FOA.matchFormula template f then
            let () =
              O.debug ("Firstorder.findFormula: found: " ^
                       (string_of_formula formula) ^ ".\n")
            in
            Some(formula, List.rev front, fs)
          else
            find (formula::front) fs
    in
    find [] formulas

  (********************************************************************
  *matchLeft, matchRight:
  * Given a pattern and a sequent, finds the first element on the left
  * (or right) that matches the pattern, and returns a tuple with:
  *   the matching formula
  *   the before and after of the left or right
  *   the whole left
  *   the whole right
  ********************************************************************)
  let matchLeft pattern marker after sequent =
    O.debug
      ("Template: " ^ (FOA.string_of_formula_ast ~generic:[] pattern) ^ ".\n") ;
    let lhs = 
      if Option.isSome after then
        Option.get after
      else
        sequent.lhs
    in
    let rhs = sequent.rhs in
    let result = findFormula pattern marker lhs in
    match result with
      Some(f,before,after) -> Some(f,before,after,lhs,rhs)
    | None -> None

  let matchRight pattern marker after sequent =
    O.debug
      ("Template: " ^ (FOA.string_of_formula_ast ~generic:[] pattern) ^ ".\n") ;
    let lhs = sequent.lhs in
    let rhs =
      if Option.isSome after then
        Option.get after
      else
        sequent.rhs
    in
    let result = findFormula pattern marker rhs in
    match result with
      Some(f,before,after) -> Some(f,before,after,lhs,rhs)
    | None -> None

  (********************************************************************
  *makeTactical:
  * Given a matcher and a tactic, creates a tactical that applies
  * the given tactic to the first formula in the sequent that matches
  * the tactic.  If the application fails, it finds the next formula.
  * If the application succeedes, the whole tactical succeeds. If none
  * match, it fails.
  ********************************************************************)
  let makeTactical name matcher tactic session =
    let tactic' = fun sequent sc fc ->
      let sc' ?b formula k s =
        sc s (makeProofBuilder name ~f:formula sequent) k
      in
      let rec fc' left right () =
        match (matcher right sequent) with
          Some(f, left', right', lhs, rhs) ->
            let left'' = left @ left' in
            let zip l = (left'' @ l @ right') in
            let fc'' () =
              fc' (left'' @ [f]) (Some right') ()
            in
              tactic session sequent f zip lhs rhs (sc' f) fc''
        | None ->
            fc ()
      in
        fc' [] None ()
    in
      G.makeTactical tactic'

  (********************************************************************
  *makeGeneralTactical:
  * Given the name of a tactic, a matcher constructor (either matchLeft or
  * matchRight), a default template for use if none is specified, and
  * a tactic, finds a formula to operate on using the matcher and applies
  * the tactic.
  *
  * The tactic passed to makeGeneralTactical should be a function that
  * takes the session, sequent, the matched formula, a zipper, the left
  * and right sides in their entirety, a success continuation that takes
  * a continue continuation (see logic.mli) and a list of new sequents,
  * and a failure continuation (see logic.mli).
  ********************************************************************)
  let makeGeneralTactical name (matchbuilder, defaulttemplate) tactic =
    fun session args ->
      (*  If no default template was specified and there is no argument
          template then bail. *)
      if defaulttemplate = "" && Listutils.empty args then
        (G.invalidArguments (name ^ ": incorrect number of arguments."))
      else
      
      let defaulttemplate =
        parseTemplate session.definitions defaulttemplate in
      
      if Option.isSome defaulttemplate then
        let (defaulttemplate, focus) = Option.get defaulttemplate in
        match args with
            [] ->
              (makeTactical name (matchbuilder defaulttemplate focus) tactic session)
          | Absyn.String(s)::[] ->
              let template = parseTemplate session.definitions s in
              if (Option.isSome template) then
                let (template, focus') = Option.get template in
                if (FOA.matchFormula defaulttemplate template) && (focus = focus') then
                  (makeTactical name (matchbuilder template focus) tactic session)
                else
                  (G.invalidArguments (name ^ ": template does not match default"))
              else
                  (G.invalidArguments (name ^ ": invalid template"))
          | _ -> (G.invalidArguments (name ^ ": incorrect number of arguments"))
      else
        (G.invalidArguments (name ^ ": invalid default template."))

  
  (********************************************************************
  *makeSimpleTactical:
  * Given the name of a tactic, a matcher constructor (either matchLeft or
  * matchRight), a default template for use if none is specified, and
  * a tactic, finds a formula to operate on using the matcher and applies
  * the tactic.
  *
  * The tactic passed to makeSimpleTactical should be a function that
  * takes the session, sequent, the matched formula, a zipper, the left
  * and right sides in their entirety, a success continuation that takes
  * a list of new sequents, and a failure continuation (see logic.mli).
  *
  * This function should be used only for simple inference rules as it
  * interacts subtly with backtracking by not allowing for a modified
  * continue continuation as makeGeneralTactical does.
  ********************************************************************)
  let makeSimpleTactical name (matchbuilder, defaulttemplate) tactic =
    let tactic' session seq f zip lhs rhs sc fc =
      tactic session seq f zip lhs rhs (sc fc) fc
    in
    makeGeneralTactical name (matchbuilder, defaulttemplate) tactic'
  
  (** {1 Rules of the logic} *)

  (** Utility for the atomic initial rule, looking for (p params) in some side
    * of a sequent. *)
  let atomic_init i p params sc fc =
    let rec attempts = function
      | [] -> fc ()
      | Formula(i',b,FOA.AtomicFormula(p',params'))::formulas ->
          if p=p' && (i=i' || not Param.strictNabla) then
            begin match FOA.unifyList FOA.rightUnify params params' with
              | FOA.UnifySucceeded bind ->
                  sc (fun () -> FOA.undoUnify bind ; attempts formulas)
              | FOA.UnifyFailed ->
                  attempts formulas
              | FOA.UnifyError s ->
                  O.error (s ^ ".\n");
                  attempts formulas
            end
          else
            attempts formulas
      | _::formulas -> attempts formulas
    in
      attempts

  (* This is currently rather weak. Comparing the bodies will eventually be
   * needed, but implies using Term.eq for the leafs. *)
  let fixpoint_eq p p' = match p,p' with
    | FOA.MuFormula (name,_,_), FOA.MuFormula (name',_,_)
    | FOA.NuFormula (name,_,_), FOA.NuFormula (name',_,_) -> name = name'
    | _ -> false

  let fixpoint_init i p params sc fc =
    let rec attempts = function
      | [] -> fc ()
      | Formula(i',b,FOA.ApplicationFormula(p',params'))::formulas ->
          if fixpoint_eq p p' && (i=i' || not Param.strictNabla) then
            begin match FOA.unifyList FOA.rightUnify params params' with
              | FOA.UnifySucceeded bind ->
                  sc (fun () -> FOA.undoUnify bind ; attempts formulas)
              | FOA.UnifyFailed ->
                  attempts formulas
              | FOA.UnifyError s ->
                  O.error (s ^ ".\n");
                  attempts formulas
            end
          else
            attempts formulas
      | _::formulas -> attempts formulas
    in
      attempts

  let unfold_fixpoint rulename p args body argnames mkseq sc fc =
    match (* body (mu body) *)
      FOA.applyFixpoint
        (abstractFixpointDefinition p argnames) body
    with
     | Some p' ->
         begin match FOA.apply args p' with
           | Some mu' -> (* body (mu body) args *)
               sc rulename (mkseq mu')
           | None ->
               O.impossible
                 "unable to apply arguments to nu formula.\n" ;
               fc ()
         end
     | None ->
         O.impossible "definition has incorrect arity.\n" ;
         fc ()

  (** Given a body [b], and a (co)invariant [s] as a string, and parameters [t],
    * computes [s t], [s t'] and [b s t']. *)
  let fixpoint_St_St'_BSt' ~session ~lvl ~i ~body ~argnames ~s ~t =
    let rec makeArgs lvl i = function
      | [] -> (lvl, [])
      | a::aa ->
          let (lvl', a') = makeUniversalVar a lvl i in
          let (lvl'', aa') = makeArgs lvl' i aa in
            (lvl'',  a'::aa')
    in
      match parseFormula session.definitions s with
        | Some s ->
            let (lvl',t') = makeArgs lvl i argnames in
            begin match
              FOA.apply t s, FOA.apply t' s, FOA.applyFixpoint s body
            with
              | Some st, Some st', Some bs ->
                  begin match FOA.apply t' bs with
                    | Some bst' -> Some (st,lvl',st',bst')
                    | None ->
                        O.impossible
                          "unable to apply arguments to B(S).\n";
                        None
                  end
              | _ ->
                  O.error "invariant has incorrect arity.\n";
                  None
            end
        | None ->
            O.impossible "cannot parse (co)invariant.\n";
            None

  (* TODO get rid of this temporary hard-coding...
   * NOTE: logic variables are never "rigid", even though they might be
   * substituted for "rigid" terms. *)
  let normalize = Str.global_replace (Str.regexp "lift_") ""
  let unfolding_progresses name args =
    let name = normalize name in
    let rec rigid t = match Term.observe (Norm.hnorm t) with
      | Term.Lam (_,t) -> rigid t
      | Term.App (t,_) -> rigid t
      | Term.Var v when v.Term.tag = Term.Constant -> true
      | _ -> false
    in
      if List.mem name ["nat";"even";"odd";"plus";"list";"half";
                        "mem";"bind";"context";"ctxt";"one"] then
        rigid (List.hd args) (* first-arg based *)
      else if List.mem name ["cp";"eq";"typeof"] then
        rigid (List.nth args 2)
      else if List.mem name ["leq";"assoc"] then
        rigid (List.hd (List.rev args)) (* last-arg based *)
      else if List.mem name ["permute";"empty"] then
        true (* non-recursive *)
      else
        false

  let unfolding_progresses n a = let r = unfolding_progresses n a in
    if debug then
      Printf.printf "Progress %s %s = %b\n%!"
        n (String.concat "::" (List.map Pprint.term_to_string a)) r ;
      r

  type internal_sc =
    ?k:(unit -> unit) -> ?b:(Term.term list) -> string -> sequent list -> unit

  (** [intro] will be our do-it-all tactic: it takes a matcher, and applies
    * a rule with a matched formula as the active one.
    *
    * The only problem with that approach is that sometimes, there are several
    * choices for the same formula, e.g. with an additive disjunction or a fixed
    * point. The [arg] is there to specify these choices ("left"/"right").
    *
    * The focusing strategy will have to call it by passing a matcher that looks
    * for a focused or asynchronous, unfrozen formula. It will never pass any
    * [arg]. An example consequence is that [intro] should try both branches of
    * an additive disjunction if no [arg] is passed.
    *
    * The [intro] tactic will be conveniently wrapped in several specialized
    * tactics for the user, using [arg] to force choices. *)
  let intro side matcher session arg =

    (* Apply a rule with its active formula on the left hand-side. *)
    let left seq (Formula(i,b,f)) zip (sc:internal_sc) fc =
      match f with
        | FOA.AndFormula (l,r) ->
            sc "and_l" [{ seq with lhs = zip [Formula(i,b,l);Formula(i,b,r)] }]
        | FOA.OrFormula (l,r) ->
            sc "or_l" [
              { seq with lhs = zip [Formula(i,b,l)] };
              { seq with lhs = zip [Formula(i,b,r)] }
            ]
        | FOA.ImplicationFormula (l,r) ->
            sc "imp_l" [
              { seq with lhs = zip [] ; rhs =
                  if Param.intuitionistic then
                    [Formula(i,b,l)]
                  else
                    Formula(i,b,l)::seq.rhs } ;
              { seq with lhs = zip [Formula(i,b,r)] }
            ]
        | FOA.PiFormula f ->
            let hint = match f with
              | FOA.AbstractionFormula(hint,_) -> hint
              | _ -> assert false
            in
            let (lvl',var) = makeExistentialVar hint seq.lvl i in
              begin match FOA.apply [var] f with
                | Some f' ->
                    sc "pi_l" ~b:[var]
                      [{ seq with lvl=lvl' ; lhs = zip [Formula(i,b,f')] }]
                | None -> fc ()
              end
        | FOA.SigmaFormula f ->
            let hint = match f with
              | FOA.AbstractionFormula(hint,_) -> hint
              | _ -> assert false
            in
            let (lvl',var) = makeUniversalVar hint seq.lvl i in
              begin match FOA.apply [var] f with
                | Some f' ->
                    sc "sigma_l" ~b:[var]
                      [{ seq with lvl=lvl' ; lhs = zip [Formula(i,b,f')] }]
                | None -> fc ()
              end
        | FOA.NablaFormula f ->
            let (lvl',i',var) = makeNablaVar seq.lvl i in
              begin match FOA.apply [var] f with
                | Some f' ->
                    sc "nabla_l"
                      [{ seq with lvl=lvl' ; lhs = zip [Formula(i',b,f')] }]
                | None -> fc ()
              end
        | FOA.EqualityFormula _ ->
            let copier = Term.copy_eigen () in
            let copy = List.map (copyFormula ~copier) in
              begin match copyFormula ~copier (Formula(i,b,f)) with
                | Formula(i,b,FOA.EqualityFormula(t1,t2)) ->
                    begin match FOA.leftUnify t1 t2 with
                      | FOA.UnifyFailed -> sc "eq_l" []
                      | FOA.UnifySucceeded bind ->
                          let fc () = FOA.undoUnify bind ; fc () in
                            sc "eq_l" ~k:fc [{seq with lhs = copy (zip []) ;
                                                       rhs = copy seq.rhs }]
                      | FOA.UnifyError s ->
                          O.error (s ^ ".\n");
                          fc ()
                    end
                | _ -> assert false
              end
        | FOA.AtomicFormula (p,params) ->
            if p = "false" then sc "false" [] else
              atomic_init i p params (fun k -> sc "init" [] ~k) fc seq.rhs
        | FOA.ApplicationFormula (p,args) ->
            let unfold_fixpoint rule_name name args body argnames sc fc =
              (* TODO
               * The "rigidity" test should only be used on particular
               * arguments of particular fixed points, not blindly as here.
               * This is already needed to handle "leq". *)
              let bound =
                if unfolding_progresses name args then
                  seq.bound
                else
                  update_bound seq
              in
              let mkseq f =
                [{ seq with bound = bound ;
                            lhs = zip [Formula(i,b,f)] }]
              in
                if out_of_bound bound then fc () else
                  unfold_fixpoint rule_name p args body argnames mkseq sc fc
            in
            begin match p with
              | FOA.NuFormula (name,argnames,body) ->
                  (* This is synchronous. *)
                  begin match arg with
                    | Some "unfold" ->
                        unfold_fixpoint "nu_l" name args body argnames sc fc
                    | Some "init" ->
                        fixpoint_init i p args
                          (fun k -> sc "init_nu" [] ~k)
                          fc seq.rhs
                    | None ->
                        fixpoint_init i p args
                          (fun k -> sc "init_nu" [] ~k)
                          (fun () ->
                             unfold_fixpoint "nu_l"
                               name args body argnames sc fc)
                          seq.rhs
                    | s -> assert false
                  end
              | FOA.MuFormula (name,argnames,body) ->
                  (* This is asynchronous.
                   * If [arg] is "unfold", do mu_l, otherwise treat it as an
                   * invariant, otherwise try mu_l or infer an invariant. *)
                  begin match arg with
                    | Some "unfold" ->
                        unfold_fixpoint "mu_l" name args body argnames sc fc
                    | Some s ->
                        (* TODO bound check *) begin match
                          fixpoint_St_St'_BSt'
                            ~session ~lvl:seq.lvl ~i
                            ~body ~argnames ~s ~t:args
                        with
                          | Some (st,lvl',st',bst') ->
                              let st   = Formula (i,b,st) in
                              let st'  = Formula (0,b,st') in
                              let bst' = Formula (0,b,bst') in
                                sc "induction" [
                                  { seq with lhs = zip [st] } ;
                                  { seq with lvl = lvl' ;
                                             lhs = [bst'] ; rhs = [st'] }
                                ]
                          | None -> fc ()
                        end
                    | None -> (* TODO: automatic induction *)
                        unfold_fixpoint "mu_l" name args body argnames sc fc
                  end
              | _ -> assert false
            end
        | FOA.DBFormula _ | FOA.AbstractionFormula _
        | FOA.MuFormula _ | FOA.NuFormula _ -> assert false
    in

    (* Apply a rule with its active formula on the right hand-side. *)
    let right seq (Formula(i,b,f)) zip (sc:internal_sc) fc =
      if debug then Printf.printf " %s\n%!" (xml_of_formula (Formula(i,b,f))) ;
      match f with
        | FOA.AndFormula (l,r) ->
            sc "and_r" [
              { seq with rhs = zip [Formula(i,b,l)] };
              { seq with rhs = zip [Formula(i,b,r)] }
            ]
        | FOA.OrFormula (l,r) ->
            if not Param.intuitionistic then
              sc "or_r" [{ seq with rhs = zip [Formula(i,b,l);Formula(i,b,r)] }]
            else
              let left  = { seq with rhs = [Formula(i,b,l)] } in
              let right = { seq with rhs = [Formula(i,b,r)] } in
                begin match arg with
                  | Some s when s <> "" ->
                      if s.[0] = 'l' then
                        sc "left" [left]
                      else
                        sc "right" [right]
                  | _ ->
                      sc "left" [left] ~k:(fun () -> sc "right" [right])
                end
        | FOA.ImplicationFormula (l,r) ->
            sc "imp_r" [{ seq with rhs = zip [Formula(i,b,r)] ;
                                   lhs = Formula(i,b,l)::seq.lhs }]
        | FOA.PiFormula f ->
            let hint = match f with
              | FOA.AbstractionFormula(hint,_) -> hint
              | _ -> assert false
            in
            let (lvl',var) = makeUniversalVar hint seq.lvl i in
              begin match FOA.apply [var] f with
                | Some f' ->
                    sc "pi_r" ~b:[var]
                      [{ seq with lvl=lvl' ; rhs = zip [Formula(i,b,f')] }]
                | None -> fc ()
              end
        | FOA.SigmaFormula f ->
            let hint = match f with
              | FOA.AbstractionFormula(hint,_) -> hint
              | _ -> assert false
            in
            let (lvl',var) = makeExistentialVar hint seq.lvl i in
              begin match FOA.apply [var] f with
                | Some f' ->
                    sc "sigma_r" ~b:[var]
                      [{ seq with lvl=lvl' ; rhs = zip [Formula(i,b,f')] }]
                | None -> fc ()
              end
        | FOA.NablaFormula f ->
            let (lvl',i',var) = makeNablaVar seq.lvl i in
              begin match FOA.apply [var] f with
                | Some f' ->
                    sc "nabla_r"
                      [{ seq with lvl=lvl' ; rhs = zip [Formula(i',b,f')] }]
                | None -> fc ()
              end
        | FOA.EqualityFormula (t1,t2) ->
            begin match FOA.rightUnify t1 t2 with
              | FOA.UnifySucceeded(bind) ->
                  let fc' () = FOA.undoUnify bind ; fc () in
                    sc "eq_r" ~k:fc' []
              | FOA.UnifyFailed -> fc ()
              | FOA.UnifyError(s) ->
                  O.error (s ^ ".\n");
                  fc ()
            end
        | FOA.AtomicFormula (p,params) ->
            (* Since we don't check for the polarity of the atom,
             * the initial rule will be able to happen in the asynchronous
             * phase, which is a slight (meaningless) departure from the
             * focusing system. *)
            if p = "true" then sc "true" [] else
              atomic_init i p params (fun k -> sc "init" [] ~k) fc seq.lhs
        | FOA.ApplicationFormula (p,args) ->
            let unfold_fixpoint rule_name name args body argnames sc fc =
              (* TODO
               * The "rigidity" test should only be used on particular
               * arguments of particular fixed points, not blindly as here. *)
              let bound =
                if unfolding_progresses name args then
                  seq.bound
                else
                  update_bound seq
              in
              let mkseq f =
                [{ seq with bound = bound ;
                            rhs = zip [Formula(i,b,f)] }]
              in
                if out_of_bound bound then fc () else
                  unfold_fixpoint rule_name p args body argnames mkseq sc fc
            in
            begin match p with
              | FOA.MuFormula (name,argnames,body) ->
                  (* This is synchronous. *)
                  begin match arg with
                    | Some "unfold" ->
                        unfold_fixpoint "mu_r" name args body argnames sc fc
                    | Some "init" ->
                        fixpoint_init i p args
                          (fun k -> sc "init_mu" [] ~k)
                          fc seq.lhs
                    | None ->
                        fixpoint_init i p args
                          (fun k -> sc "init_mu" [] ~k)
                          (fun () ->
                             unfold_fixpoint "mu_r"
                               name args body argnames sc fc)
                          seq.lhs
                    | s -> assert false
                  end
              | FOA.NuFormula (_,argnames,body) -> (* nu body args *)
                  begin match arg with
                    | Some "unfold" ->
                        unfold_fixpoint "nu_r" name args body argnames sc fc
                    | Some s ->
                        begin match (* TODO bound check/update *)
                          fixpoint_St_St'_BSt'
                            ~session ~lvl:seq.lvl ~i
                            ~body ~argnames ~s ~t:args
                        with
                          | Some (st,lvl',st',bst') ->
                              let st   = Formula (i,b,st) in
                              let st'  = Formula (0,b,st') in
                              let bst' = Formula (0,b,bst') in
                                sc "coinduction" [
                                  { seq with rhs = zip [st] } ;
                                  { seq with lvl = lvl' ;
                                             lhs = [st'] ; rhs = [bst'] }
                                ]
                          | None -> fc ()
                        end
                    | None -> (* TODO automatic mode *)
                        unfold_fixpoint "nu_r" name args body argnames sc fc
                  end
              | _ -> assert false
            end
        | FOA.DBFormula _ | FOA.AbstractionFormula _
        | FOA.MuFormula _ | FOA.NuFormula _ -> assert false
    in

    (* Wrap up: try to find a matched formula, apply a rule on it. *)
    let tactic form_tac get_hs = fun sequent sc fc ->
      let rec parse before after =
        match matcher after with
          | None -> fc ()
          | Some (f,before',after) ->
              let before = before @ before' in
              let zip l = before @ l @ after in
              let parse_more () = parse (before @ [f]) after in
                form_tac
                  sequent f zip
                  (fun ?(k=parse_more) ?b name sequents ->
                     sc sequents (makeProofBuilder name ?b ~f sequent) k)
                  parse_more
      in
        parse [] (get_hs sequent)
    in
    let left  = tactic left  (fun s -> s.lhs) in
    let right = tactic right (fun s -> s.rhs) in
      match side with
        | `Any -> G.orElseTactical (G.makeTactical left) (G.makeTactical right)
        | `Left -> G.makeTactical left
        | `Right -> G.makeTactical right

  (** Utility for creating matchers easily. *)
  let make_matcher test formulas =
    let rec aux acc = function
      | f::tl -> if test f then Some (f,List.rev acc,tl) else aux (f::acc) tl
      | [] -> None
    in
      aux [] formulas

  (* Easy wrapper for tactics without arguments. *)
  let specialize ?arg side default_matcher session args =
    match args with
      | [Absyn.String s] ->
          begin match parseTemplate session.definitions s with
            | Some (template,focus) ->
                intro side (findFormula template focus) session arg
            | None ->
                O.error "invalid pattern" ; fun s sc fc -> fc ()
          end
      | [] -> intro side default_matcher session arg
      | _ ->
          O.error "too many arguments" ; fun s sc fc -> fc ()

  (* Even more wrapping: pass a pattern instead of a matcher.. *)
  let pattern_tac ?arg side default_pattern session args =
    match parseTemplate session.definitions default_pattern with
      | Some (template,focus) ->
          specialize ?arg side (findFormula template focus) session args
      | None -> assert false

  (* {1 Specialized basic manual tactics} *)

  let orLeft  = pattern_tac `Right "_;_" ~arg:"left"
  let orRight = pattern_tac `Right "_;_" ~arg:"right"
  let orR   = pattern_tac `Right "_;_" (* tries both in intuitionistic mode *)
  let orL   = pattern_tac `Left  "_;_"

  let andL = pattern_tac `Left  "_,_"
  let andR = pattern_tac `Right "_,_"
  let impL = pattern_tac `Left  "_=>_"
  let impR = pattern_tac `Right "_=>_"
  let eqL  = pattern_tac `Left  "_=_"
  let eqR  = pattern_tac `Right "_=_"
  let piL  = pattern_tac `Left  "pi _"
  let piR  = pattern_tac `Right "pi _"
  let sigmaL = pattern_tac `Left  "sigma _"
  let sigmaR = pattern_tac `Right "sigma _"
  let nablaL = pattern_tac `Left  "nabla _"
  let nablaR = pattern_tac `Right "nabla _"
  let trueR  = pattern_tac `Right "true"
  let falseL = pattern_tac `Left  "false"
  let muL = pattern_tac `Left  "mu _" ~arg:"unfold"
  let muR = pattern_tac `Right "mu _" ~arg:"unfold"
  let nuL = pattern_tac `Left  "nu _" ~arg:"unfold"
  let nuR = pattern_tac `Right "nu _" ~arg:"unfold"

  let inductionTactical session = function
    | [] -> pattern_tac `Left "mu _" ~arg:"" session []
    | [Absyn.String i] -> pattern_tac `Left "mu _" ~arg:i session []
    | [Absyn.String i; Absyn.String p] -> pattern_tac `Left p ~arg:i session []
    | _ -> (fun _ _ fc -> O.error "Invalid arguments.\n" ; fc ())
  let coinductionTactical session = function
    | [] -> pattern_tac `Right "nu _" ~arg:"" session []
    | [Absyn.String i] -> pattern_tac `Right "nu _" ~arg:i session []
    | [Absyn.String i; Absyn.String p] -> pattern_tac `Right p ~arg:i session []
    | _ -> (fun _ _ fc -> O.error "Invalid arguments.\n" ; fc ())

  let axiom_atom  =
    specialize `Right (make_matcher
                         (function
                            | Formula(_,_,FOA.AtomicFormula _) -> true
                            | _ -> false))
  let axiom_mu =
    specialize `Right
      (make_matcher
         (function
            | Formula(_,_,FOA.ApplicationFormula(FOA.MuFormula _,_)) -> true
            | _ -> false))
      ~arg:"init"
  let axiom_nu =
    specialize `Left
      (make_matcher
         (function
            | Formula(_,_,FOA.ApplicationFormula(FOA.NuFormula _,_)) -> true
            | _ -> false))
      ~arg:"init"
  let axiom s a =
    G.orElseTactical (axiom_atom s a)
      (G.orElseTactical (axiom_mu s a) (axiom_nu s a))

  (** {1 Structural rules} *)

  let contractL =
    let tactic session seq f zip lhs rhs sc fc =
      sc [{seq with lhs = zip [f;f]}]
    in
      makeSimpleTactical "contract_l" (matchLeft, "_") tactic

  let contractR =
    let tactic session seq f zip lhs rhs sc fc =
      sc [{seq with rhs = zip [f;f]}]
    in
      makeSimpleTactical "contract_r" (matchRight, "_") tactic

  let weakL =
    let tactic session seq f zip lhs rhs sc fc =
      sc [{ seq with lhs = zip [] }]
    in
      makeSimpleTactical "weak_l" (matchLeft, "_") tactic

  let weakR =
    let tactic session seq f zip lhs rhs sc fc =
      sc [{ seq with rhs = zip [] }]
    in
      makeSimpleTactical "weak_r" (matchRight, "_") tactic

  let weakTactical session args =
    G.orElseTactical (weakL session args) (weakR session args)

  let contractTactical session args =
    G.orElseTactical (contractL session args) (contractR session args)

  let rotateL session params seqs success failure =
    match seqs with
      | [] -> failure ()
      | ({ lhs = l::ltl } as seq)::tl ->
          success [{ seq with lhs = ltl@[l] }] tl (fun p -> p) failure
      | _ -> assert false

  let rotateR session params seqs success failure =
    match seqs with
      | [] -> failure ()
      | ({ rhs = l::rtl } as seq)::tl ->
          success [{ seq with rhs = rtl@[l] }] tl (fun p -> p) failure
      | _ -> assert false

  (** {1 Meta-rules} *)

  (** Force unification between two terms. *)
  let forceTactical session args =
    match args with
      | Absyn.String(seqstring)::Absyn.String(term)::[] ->
            let seqterm = parseTerm seqstring in
            let unterm = parseTerm term in
            if Option.isSome seqterm && Option.isSome unterm then
              let seqterm = Option.get seqterm in
              let unterm = Option.get unterm in
              (* pretactic: simply unifies the two terms. *)
              let pretactic = fun seq sc fc ->
                match FOA.rightUnify seqterm unterm with
                    FOA.UnifySucceeded(s) ->
                      let fc' () =
                        (FOA.undoUnify s;
                        fc ())
                      in
                      let pb = List.hd in
                      sc [seq] pb fc'
                  | FOA.UnifyFailed -> fc ()
                  | FOA.UnifyError(s) ->
                      (O.error (s ^ ".\n");
                      fc ())
              in
              G.makeTactical pretactic
            
            else
              (if Option.isNone seqterm then O.error "invalid sequent term.\n"
              else ();
              if Option.isNone unterm then O.error "invalid unification term.\n"
              else ();
              G.failureTactical)
      | _ -> (G.invalidArguments "unify")

  (** The cut rule.
    * This implementation is not satisfying for a classical logic. *)
  let cutTactical session args =
    match args with
      | Absyn.String(s)::[] ->
          let f = parseFormula session.definitions s in
            begin match f with
              | None -> O.error "unable to parse lemma.\n" ; G.failureTactical
              | Some f ->
                  let pretactic = fun sequent sc fc ->
                    let f' = Formula(0, (Nonfocused, Positive), f) in
                    let s1 = { sequent with rhs = [f'] } in
                    let s2 = { sequent with lhs = sequent.lhs @ [f'] } in
                    let pb = makeProofBuilder "cut" ~p:["formula",s] sequent in
                      sc [s1; s2] pb fc
                  in
                    G.makeTactical pretactic
            end
      | _ -> G.invalidArguments "cut"

  (** {1 Simplifying strategy}
    * Apply all non-branching invertible rules.
    * Handling units (true/false) requires to work on atoms on both sides. *)

  let simplify_matcher_l =
    make_matcher
      (fun (Formula(i,b,f)) ->
         match f with
           | FOA.AndFormula _
           | FOA.NablaFormula _
           | FOA.SigmaFormula _
           | FOA.EqualityFormula _
           | FOA.AtomicFormula _ -> true
           | _ -> false)

  let simplify_matcher_r =
    make_matcher
      (fun (Formula(i,b,f)) ->
         match f with
           | FOA.NablaFormula _
           | FOA.PiFormula _
           | FOA.ImplicationFormula _
           | FOA.EqualityFormula _
           | FOA.AtomicFormula _ -> true
           | FOA.OrFormula _ when not Param.intuitionistic -> true
           | _ -> false)

  let simplifyTactical session args = match args with
    | [] ->
        G.repeatTactical
          (G.orElseTactical
            (intro `Left  simplify_matcher_l session None)
            (intro `Right simplify_matcher_r session None))
    | _ -> G.invalidArguments "simplify"

  (** {1 Nabla elimination}
    * The abstract tactic implements the reduction of nabla to liftings. *)
  let abstractTactical session args =
    let rec n_downto_1 = function
      | 0 -> []
      | n -> n :: n_downto_1 (n-1)
    in
    let abstract seq =
      (* Compute the nabla-normal form of every formula in the sequent.
       * it may be more convenient to be able to target a specific one. *)
      let abstract (Formula(i,m,form)) =
        let tv = List.map Term.nabla (List.rev (n_downto_1 i)) in
        let form = FOA.eliminateNablas tv form in
          Formula(0,m,form)
      in
        { seq with lhs = List.map abstract seq.lhs ;
                   rhs = List.map abstract seq.rhs }
    in
    fun seqs sc fc ->
      match seqs with
        | s::tl -> sc [abstract s] tl (fun proofs -> proofs) fc
        | _ -> fc ()

  (** {1 Debugging}
    * The examine tactic is useful for debugging. *)
  let examineTactical session args = match args with
    | [] ->
        fun sequents sc fc ->
          let seq = List.hd sequents in
          let lhs =
            String.concat "\n  " (List.map string_of_formula_ast seq.lhs)
          in
          let rhs =
            String.concat "\n  " (List.map string_of_formula_ast seq.rhs)
          in
            O.output
              (Printf.sprintf
                 "Sequent AST:\n  %s\n----------------------------\n  %s\n"
                 lhs rhs) ;
            sc [] sequents Logic.idProofBuilder fc
    | _ -> G.invalidArguments "examine"

  (** {1 Focusing strategy} *)

  (** AtomicFormula includes the units (true/false).
    * The Negative polarity is actually never used, and the whole polarity
    * design is too weak as the polarity is set only at toplevel and not on
    * subformulas.
    * Hence, the "polarity" of mu/nu is currently fixed to resp. pos/neg. *)

  let sync_on_l pol f =
    match f with
      (* | FOA.AndFormula _ -> true *)
      | FOA.PiFormula _ | FOA.ImplicationFormula _ -> true
      | FOA.AtomicFormula _  when pol = Negative -> true
      | FOA.ApplicationFormula (FOA.NuFormula _, _) -> true
      | _ -> false

  let sync_on_r pol f =
    match f with
      | FOA.AndFormula _ -> true
      | FOA.OrFormula _ when Param.intuitionistic -> true
      | FOA.SigmaFormula _ | FOA.EqualityFormula _ -> true
      | FOA.AtomicFormula _  when pol = Positive -> true
      | FOA.ApplicationFormula (FOA.MuFormula _, _) -> true
      | _ -> false

  let fixpoint = function
    | FOA.ApplicationFormula _ -> true
    | _ -> false

  let cutThenTactical, cutRepeatTactical =
    let restorer () =
      let s = Term.save_state () in
        fun () -> Term.restore_state s
    in
      G.cutThenTactical restorer,
      G.cutRepeatTactical restorer

  (** The focused proof-search strategy makes use of building blocks
    * which process one sequent at a time, glued together using Then (and an
    * underlying Iterate) in order to get a tactic processing several goals in
    * parallel.
    * The problem is that this model hides some information. The asynchronous
    * phase, in presence of fixed points, can produce several alternative lists
    * of subgoals, which might easily have the first goal in common.
    * Using iterate, if you notice that the first goal is impossible, you can
    * just ask async for more data, and get the second alternative, which might
    * have the same impossible first goal.
    * An example of that is (nat x => nat y): the first possibility is to freeze
    * (nat x), all the others produce a subgoal (x=0 => nat y) which is
    * impossible.
    * A better strategy would be to start the focusing phase as soon as one goal
    * is produced and fail earlier (at the level of the first choice to unfold
    * nat). *)

  (** In automatic mode, intro doesn't really need a session. *)
  let automatic_intro side matcher = intro side matcher dummy_session None

  (** The decide rule focuses on a synchronous formula.
    * This tactic takes a single sequent and its successes are single sequents
    * too. *)
  let focus =
    let matcher_l =
      make_matcher
        (fun (Formula(i,(m,p),f)) -> m=Nonfocused && sync_on_l p f)
    in
    let matcher_r =
      make_matcher
        (fun (Formula(i,(m,p),f)) -> m=Nonfocused && sync_on_r p f)
    in
    let focus (Formula(i,(_,p),f)) = Formula (i,(Focused,p),f) in
    let rec tac_r before after seq sc fc =
      match matcher_r after with
        | Some (f,before',after) ->
            let before = before @ before' in
              if debug then
              Format.printf "%s@[<hov 2>Focus right@ %s@ %a@]\n%!"
                (String.make (match seq.bound with Some b -> b | None -> 0)
                   ' ')
                (string_of_formula f)
                ppxml_sequent seq ;
              sc
                { seq with rhs = before @ [ focus f ] @ after }
                (fun () -> tac_r (before@[f]) after seq sc fc)
        | None -> fc ()
    in
    let rec tac_l before after seq sc fc =
      match matcher_l after with
        | Some (f,before',after) ->
            let before = before @ before' in
              if debug then
              Format.printf "%s@[<hov 2>Focus left@ %s@ %a@]\n%!"
                (String.make (match seq.bound with Some b -> b | None -> 0)
                   ' ')
                (string_of_formula f)
                ppxml_sequent seq ;
              sc
                { seq with lhs = before @ [ focus f ] @ after }
                (fun () -> tac_l (before@[f]) after seq sc fc)
        | None -> tac_r [] seq.rhs seq sc fc
    in
      fun seq sc fc -> tac_l [] seq.lhs seq sc fc

  (** The reaction rule removes the focus from an asynchronous formula. *)
  let unfocus =
    let matcher_l =
      make_matcher
        (fun (Formula(i,(m,p),f)) -> m=Focused && not (sync_on_l p f))
    in
    let matcher_r =
      make_matcher
        (fun (Formula(i,(m,p),f)) -> m=Focused && not (sync_on_r p f))
    in
    let unfocus (Formula(i,(_,p),f)) = Formula (i,(Nonfocused,p),f) in
      (fun seq ->
         match matcher_l seq.lhs with
           | Some (f,before,after) ->
               if debug then
               Printf.printf "%sRelease left %s\n%s\n%!"
                 (String.make
                    (match seq.bound with Some b -> b | None -> 0) ' ')
                 (string_of_formula f)
                 (xml_of_sequent seq) ;
               Some { seq with lhs = before @ [ unfocus f ] @ after }
           | None ->
               begin match matcher_r seq.rhs with
                 | Some (f,before,after) ->
                     if debug then
                     Printf.printf "%sRelease right %s\n%s\n%!"
                       (String.make
                          (match seq.bound with Some b -> b | None -> 0) ' ')
                       (string_of_formula f)
                       (xml_of_sequent seq) ;
                     Some { seq with rhs = before @ [ unfocus f ] @ after }
                 | None -> None
               end)

    (** "Finite" async connectives can be introduced eagerly without backtrack.
      * For the fixed points (mu on the left, nu on the right) there is a choice
      * of "opening" or "freezing", over which backtrack should be possible. *)
    let finite =
      cutRepeatTactical (* TODO this one might be useless... but doesn't hurt *)
        (G.orElseTactical
           (automatic_intro `Left
             (make_matcher (fun (Formula(i,b,f)) ->
                              not (fixpoint f || sync_on_l (snd b) f))))
           (automatic_intro `Right
             (make_matcher (fun (Formula(i,b,f)) ->
                              not (fixpoint f || sync_on_r (snd b) f)))))

    (* TODO use polarity rather than mu/nu *)
    let left_matcher =
      make_matcher
        (fun (Formula(i,(m,_),f)) ->
           match f with
             | FOA.ApplicationFormula (FOA.MuFormula _, _) ->
                 m <> Frozen
             | _ -> false)
    let right_matcher =
      make_matcher
        (fun (Formula(i,(m,_),f)) ->
           match f with
             | FOA.ApplicationFormula (FOA.NuFormula _, _) ->
                 m <> Frozen
             | _ -> false)
    (* Unfold the first available asynchronous fixed point.
     * This will (eventually) include trying simple (co)inductions. *)
    let unfold =
        G.orElseTactical
          (automatic_intro `Left left_matcher)
          (automatic_intro `Right right_matcher)

    (** Apply a rule on the focused formula if it is synchronous. *)
    let sync_step =
      G.orElseTactical
        (automatic_intro `Left
          (make_matcher
             (fun (Formula(i,b,f)) -> fst b = Focused && sync_on_l (snd b) f)))
        (automatic_intro `Right
          (make_matcher
             (fun (Formula(i,b,f)) -> fst b = Focused && sync_on_r (snd b) f)))

  (** Focused proof-search, starting with the async phase. *)
  let rec full_async s sc fc =
    (cutThenTactical finite freeze) s sc fc

  (* Freeze the first available asynchronous fixed point,
   * takes care of calling "unfold" and re-calling "finite". *)
  and freeze sequents sc fc =
    let async = cutThenTactical finite freeze in
    match sequents with
      | [seq] ->
          begin match left_matcher seq.lhs with
            | Some (Formula(i,(_,p),f), before, after) ->
                G.orElseTactical
                  (fun _ ->
                     if debug then
                     Format.printf "%s@[<hov 2>Freeze@ %s@ %a@]\n%!"
                       (String.make
                          (match seq.bound with Some b -> b | None -> 0)
                          ' ')
                       (string_of_formula (Formula(i,(Nonfocused,p),f)))
                       ppxml_sequent seq ;
                     freeze
                       [{seq with lhs =
                           before@[Formula(i,(Frozen,p),f)]@after }])
                  (G.thenTactical (fun _ ->
                     if debug then
                     Format.printf "%s@[<hov 2>Unfold@ %s@ %a@]\n%!"
                       (String.make
                          (match seq.bound with Some b -> b | None -> 0)
                          ' ')
                       (string_of_formula (Formula(i,(Nonfocused,p),f)))
                       ppxml_sequent seq ;
                     unfold [seq])
                     async)
                  [(*stub*)] sc fc
            | None ->
                begin match right_matcher seq.rhs with
                  | Some (Formula(i,(_,p),f), before, after) ->
                      G.orElseTactical
                        (fun _ -> freeze
                           [{seq with rhs =
                               before@[Formula(i,(Frozen,p),f)]@after }])
                        (G.thenTactical (fun _ -> unfold [seq]) async)
                        [(*stub*)] sc fc
                  | None ->
                      (* Don't wait to collect all results of the async phase,
                       * check each immediately. *)
                      full_sync seq sc fc
                end
          end
      | _ -> assert false

  (** Complete focused proof-search starting with a decide rule. *)
  and full_sync seq sc fc =
    focus seq
      (fun seq k -> sync [seq] sc k)
      fc

  and sync seqs sc fc =
    assert (List.length seqs = 1) ;
    sync_step seqs
      (fun n o b k ->
         G.iterateTactical sync (n@o)          (* succeeds on n@o=[] *)
           (fun n' o' b' k' ->
              assert (n'=[] && o'=[]) ;        (* sync is a complete tactic *)
              sc [] [] (fun l -> b (b' l)) k') (* expect l = [] *)
           k)
      (fun () ->
         match unfocus (List.hd seqs) with
           | Some seq -> full_async [seq] sc fc
           | None -> fc ())

  let set_bound session args seqs sc fc =
    let n = match args with [Absyn.String n] -> int_of_string n | _ -> 3 in
    match seqs with
     | ({bound=_} as seq)::tl ->
         sc [{seq with bound = Some n}] tl (fun proofs -> proofs) fc
     | [] -> fc ()

  let proveTactical session args =
    (* Set a bound to the number of unfoldings,
     * which by the way restricts our attention to the first sequent.
     * There is no need to force full_async to complete, since it never returns
     * partial successes by design. *)
    G.thenTactical (set_bound session args) full_async

  (** {1 Tactic table} Export tactics to the user. *)

  let pervasiveTacticals =
    let (++) t (a,b) = Logic.Table.add a b t in
    let (||) a b =
      fun session args -> G.orElseTactical (a session args) (b session args)
    in

    let ts =
      G.tacticals
        ++ ("and", andL||andR)
        ++ ("and_l", andL)
        ++ ("and_r", andR)

        ++ ("imp", impL||impR)
        ++ ("imp_l", impL)
        ++ ("imp_r", impR)

        ++ ("pi", piL||piR)
        ++ ("pi_l", piL)
        ++ ("pi_r", piR)

        ++ ("sigma", sigmaL||sigmaR)
        ++ ("sigma_l", sigmaL)
        ++ ("sigma_r", sigmaR)

        ++ ("nabla", nablaL||nablaR)
        ++ ("nabla_l", nablaL)
        ++ ("nabla_r", nablaR)

        ++ ("eq", eqL||eqR)
        ++ ("eq_l", eqL)
        ++ ("eq_r", eqR)

        ++ ("axiom", axiom)

        ++ ("mu_l", muL)
        ++ ("mu_r", muR)
        ++ ("nu_l", nuL)
        ++ ("nu_r", nuR)
        ++ ("induction", inductionTactical)
        ++ ("coinduction", coinductionTactical)

        ++ ("examine", examineTactical)

        ++ ("simplify", simplifyTactical)

        ++ ("true", trueR)
        ++ ("false", falseL)
        ++ ("trivial", trueR||falseL)

        ++ ("weak_l", weakL)
        ++ ("contract_l", contractL)

        ++ ("cut", cutTactical)
        ++ ("force", forceTactical)
        ++ ("prove", proveTactical)
        ++ ("set_bound", set_bound)

        ++ ("abstract", abstractTactical)
    in

    (* Which structural rules to admit. *)
    let ts =
      let ts =
        if Param.intuitionistic then
          ts
        else
          ts
            ++ ("weak_r", weakR)
            ++ ("contract_r", contractR)
            ++ ("rotate_r", rotateR)
      in
        ts
          ++ ("weak_l", weakL)
          ++ ("contract_l", contractL)
          ++ ("rotate_l", rotateL)
    in

    (* Which disjunction tactics are meaningful. *)
    let ts =
      let ts =
        if Param.intuitionistic then
          ts
            ++ ("left", orLeft)
            ++ ("right", orRight)
        else
          ts
            ++ ("or_r", orR)
            ++ ("or", orL||orR)
      in
        ts ++ ("or_l", orL)
    in

      ts

  (** The empty session starts with the expected empty list of sequents
    * and initial list of tacticals, as well as an empty definition table.
    * Additionally it includes the identity proof builder for simplicity
    * (instead of, say, an option), as well as undo, redo, and namespace
    * info. *)
  let emptySession =
    let state = Term.save_state () in
    let ns = Term.save_namespace () in
      { tactics = pervasiveTacticals ; definitions = Logic.Table.empty ;
        sequents = [] ; builder = Logic.idProofBuilder ;
        state = state ; diff = Term.get_subst state ;
        initial_namespace = ns ; proof_namespace = ns }

  (********************************************************************
  *reset:
  * Provides a new sequent.  This amounts to returning the empty
  * sequent.
  ********************************************************************)
  let reset =
    let initialNamespace = Term.save_namespace () in
      fun () ->
        Term.restore_namespace initialNamespace ;
        emptySession

end

module Firstordernonstrict =
  Firstorder (struct
    let name = "First Order Classical Logic with Non-Strict Nabla"
    let strictNabla = false
    let intuitionistic = false
  end)

module Firstorderstrict =
  Firstorder (struct
    let name = "First Order Classical Logic with Strict Nabla"
    let strictNabla = true
    let intuitionistic = false
  end)

module MuLJstrict =
  Firstorder (struct
    let name = "Mu-LJ with Strict Nabla"
    let strictNabla = true
    let intuitionistic = true
  end)

module MuLJnonstrict =
  Firstorder (struct
    let name = "Mu-LJ with Non-Strict Nabla"
    let strictNabla = false
    let intuitionistic = true
  end)
