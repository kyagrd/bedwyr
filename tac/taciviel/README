===============================================================================

Tac::taci

===============================================================================

Taci is the command line interface to the Tac system.  It is intended to be
used from a console or terminal, or in combination with a graphical interface
(see tac/StickyTaci/README and tac/stekki/README).

Usage:
  taci may be invoked as follows:
  
    taci --logic logicname --output outputname

  Where logicname is the name of the logic to load and outputname is the
  name of the output module to use.  In general, when using taci from the
  command line, one will not specify the output module; it will default to
  the console output module.
  
  A list of available logics and output modules may be obtained as follows:
  
    taci --logics
    taci --outputs

Logics:
  There are 6 logics available in the Tac system.  The first of these,
  "nologic", is a default module that only has stub functionality.  It is
  intended to serve as a skeleton for the implementation of a new logic
  "from scratch".

  The logic "propositional" is a classical predicate logic without
  quantification of any kind.  This logic is quite simple, as it was the first
  logic implemented in the framework.

  The remaining 4 logics are all very similar.  Each is constructed from the
  same functor, using different parameters to achieve the different logics.
  Every logic is first-order, with universal, existential, and nabla
  quantification, equality on the left and right, and definitions in the form
  of fixed point combinators.  The muLJ-* logics are intuitionistic, and the
  firstorder* logics are classical.  The *-nonstrict logics are logics in which
  the axiom rule is slightly "sloppy" with respect to generic context: they do
  not check for equality.  They are therefore less restrive than LINC, but more
  restrictive than LG.
  
Tactics and Tacticals:
  In Tac one interacts with a logic by the application of tactics to a list
  of sequents.  Tactics may be generally thought of as functions from sequents
  to sequents.  They take a list of sequents, along with a success continuation
  and a failure continuation.  While the meaning and use of the list of sequents,
  is obvious, the continuations mentioned are less so.

  Success Continuation:
    The success continuation is a function that takes a list of new sequents,
    a list of old sequents, a proof builder, and a "continue" continuation.  It
    is called by a tactic when it succeeds.
    
    In Tac a sequent may choose to operate on only certain sequents in the list
    it receives.  For example, the function Logic.GenericTacticals.makeTactical
    takes a tactic that operates on only 1 sequent (as opposed to a list) and
    produces a tactical (discussed below) that operates on the first sequent in
    the list, leaving the others untouched.  Therefore the untouched sequents
    are considered "old" and any sequents generated by the tactic are considered
    "new".
  
    The proof builder is a function from a list of proofs of sequents
    to a list of proofs of sequents.

    The continue continuation is a continuation that, when called, returns the
    tactic's next success.  This enables all tactics to perform backtracking,
    and handles choice-points in a clean way.  The continue continuation should
    be sure to "undo" any destructive changes that may have occurred during the
    previous success before attempting to succeed again.

  Failure Continuation:
    The failure continuation is called by a tactic when it fails.  It is a
    function from unit to unit.  The failure continuation should undo any
    destructive changes made during the previous success.

  When invoking a tactical at the top-level the interpreter (see interpreter.ml)
  creates a new success continuation and a new failure continuation.  Each
  continuation raises a particular exception that can be caught.  Therefore,
  tactics never return except for by calling one of the provided continuations.
  This ensures that all tactics may be completely tail-recursive.
  Tacticals are functions that construct tactics.  In Tac, the only things that
  one writes as a logic author or applies as a user are tacticals.
  All tacticals are functions that take a session and a list of abstract syntax
  arguments and produce a tactic.

Implementing a Logic:
  Tac is a 2 level system that makes it easy to interact with a logic using
  tactics and tacticals by automating those parts of the system that are common
  to all logics.  The first level of the system is the "driver" that runs the
  top-level interactive loop and encapsulates all access to the current logic.
  The second level is the logic module itself.

  The driver layer of the system is responsible for parsing toplevel input
  from the command line and then interacting with the logic based on said input.
  This level implements the input/output loop.  It parses the input using a
  lexer/parser that is oblivious to the grammar of the current logic.  For this
  reason any terms that are in the syntax of the logic must be quoted; these
  terms can then be parsed by the logic in a context-specific manner.  After
  parsing the input the driver layer dispatches any commands it receives to the
  correct function, many of which are provided by the logic layer (below).
  The driver layer handles such things as the loading of (script) files, the
  management of timing and debugging information, and the application of
  tacticals.

  The logic layer, which may be changed at runtime, is responsible for all
  computations related to the logic.  This includes parsing its own syntax,
  unification, abstract syntax, and any other logic-specific duties.
  
  Each logic is a module that matches a given interface, therefore implementing
  a new logic is as straightforward as creating a module that implements a specific
  interface.  The interface that must be met is named "Logic" and is specified in
  the file "tac/taci/logic.mli".  Essentially, implementing a module that
  corresponds to this interface comes down to defining the type of a "session", a
  "sequent", and a "proof", along with various accessor functions that operate on
  these types, and a few values.

  Types:
    Session:
      A session in Taci corresponds to the state of the logic.  That is to say,
      the session should encapsulate all aspects of a logic that might change.
      Constants need not be contained in the session.

      A session should in general be considered a purely functional piece of data.
      That is, a session should always be "valid"; if a session must be modified,
      a new session should be constructed that reflects this modification.  Note
      that because a session is expected to represent all aspects of a logic, any
      change to the logic must necessarily be applicative.  However, because of
      the way certain aspects of many logics are often represented (particularly
      unification of logic or eigen variables) using destructive modification, a
      session is allowed to permit referential updates provided that it can be put
      back into a valid, unchanged state when needed. This is discussed more  
      fully when the "undo" and "redo" functions are introduced.  

    Sequent:
      The sequent type represents a sequent in the logic being defined.  There
      are no requirements placed on the type of the sequent, except in as far as
      sequents are an aspect of a logic that must be reflected in the current
      session.
  
    Proof:
      The proof type represents a proof of a sequent in the logic being defined.
      A proof must meet the same requirements as a sequent.

  Values:
    name:
      The "print" name of the logic.

    info:
      Information corresponding to the use of this logic.  This information is
      displayed whenever the user uses the "#help." command.

    start:
      Information about the logic that should be displayed once at startup.

  Functions:
    incl:
      This function is invoked with the current session and a list of files
      to include.  These included files are expected to contain logic-specific
      syntax introducing, for example, new definitions.  They might also define
      operator precedences if a logic supports such things.  The result of this
      function should be a new session that reflects the new definitions, etc.
      The given session should still be valid, and should still represent exactly the
      session as it was before the function was called (see the description of the
      session type).

    reset:
      This function is invoked with the current session.  It should generate a
      new session that reflects the initial state (that is, one without a current
      theorem, etc).  The given session again must remain unchanged modulo the
      undo and redo functions.

    prove:
      This function is invoked with the current session, a theorem name, and a
      string representing the theorem to prove in the syntax of the logic.  It
      should return a new session that may be used to prove this theorem, for
      instance by parsing the theorem and setting the current sequents appropriately.
      If the function fails it should return the original session, which should
      remain unchanged regardless.
  
    definitions:
      This function is invoked with the current session and a list of strings
      representing definitions in the syntax of the logic.  It should return a
      new session with these definitions added to the logic, if the logic provides
      definitions.

    undo:
      This function is invoked with a session that must be restored.  It should
      return the restored session.

    redo:
      This function is invoked with a session that must be restored.  It should
      return the restored session.

    validSequent:
      This function returns true if the given session has at least one sequent on
      which to operate.

    sequents:
      This function returns a session's sequents.

    string_of_sequents:
      This function returns a string representing a session's sequents.
  
    proof:
      This function returns the session's proof builder thus far.

    update:
      This function takes a session, a list of sequents, and a proof builder, and
      returns the same session with the sequents and proof builder set to the new
      values.  It is called after the success or failure of a top-level application
      of a tactical; it is at this point that the appropriate undo and redo information
      may be stored for the given session.

    tacticals:
      This function is invoked with a session, and returns a table contains all of the
      tacticals that the session contains.  The table is indexed by tactical name.

    defineTactical:
      This function is invoked with a session, a tactical name, and a tactical, and
      returns a session with the given tactical added to the session's tactical table.
      This allows for a simple way to define tacticals at the top level.  However,
      tacticals defined in this way cannot require arguments.

  Once a logic has been implemented it must be registered with Tac.  To do
  this an entry for the logic must be added to the logics_gen input file.
  More information about how to accomplish this can be found in
  "tac/logics_gen/README".
