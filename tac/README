===============================================================================

Tac

By Zach Snow, David Baelde & Alexandre Viel

===============================================================================
Tac is Free Software, and is released under the GPL3.  See the accompanying file
"/tac/COPYING" for a copy of this license.

Contents
========
  I.    System overview
  II.   Building tac
  III.  Using taci
  IV.   Using lifting in taci
  V.    Commented list of examples

I. System overview
==================

  Tac is made up of several subprojects, each in their own directory.  They
  are:
    taci:
      The command-line interface.

    logics_gen:
      A code generator that eases the addition of new logics to taci.

    StickyTaci:
      A relatively simple C#/WinForms interface to taci.  Currently
      StickyTaci only works under Windows XP.  It can be compiled in
      Linux using Mono, but the resulting executable does not run correctly
      due to incompatibilities between Mono's implementation of WinForms and
      Micorosoft's.  Furthermore, StickyTaci depends on the Scintilla control,
      and Scintilla.NET.

    Stekki:
      A rough OCaml/Tk interface to taci.  Though it is simple it is still
      nicer to work with than taci.  Currently Stekki only works under Linux.
      It can be compiled in Windows XP, but the resulting executable does not
      run correctly due to the way it interacts with taci using Unix pipes.

    tools/tactex:
      A tool for manipulating the proofs generated by taci, and for generating
      LaTeX versions of the proof.

    tools/mod2def:
      A tool for generating a muLJ definition file from a lambdaProlog module.
      Remember that implication in lambdaProlog ("=>") really is something
      different from implication in muLJ, and so a lambdaProlog module that
      uses hypothetical contexts must first be rewritten to manually track
      such contexts, in general using a list.  See examples/popl/popl.def
      for an example of this style.

II. Building tac
================

  See "/tac/INSTALL" for information on building Tac on Windows and Linux.


III. Using taci
==============

  Taci is a command-line tool that allows you to interactively build proofs in
  various logics. You can get the list of available logics using --logics:

    tac $ taci/taci --logics

  Propositional logic is a very simple classical propositional logic with only
  atoms; it's not very interesting. Firstorder, muLJ and their variations
  are first-order logics, featuring higher-order terms, nabla and fixed points.
  The muLJ* logics are intuitionistic while firstorder* are classical. The
  *-nonstrict variations are slightly sloppier than LINC when checking the axiom
  rule: they do not check for generic context equality, but since variables are
  represented by indices which cannot be renumbered it's still fairly far from
  LG.

  Let's start taci on muLJ. You should get something like:

    tac $ taci/taci --logic muLJ

    Mu-LJ with Strict Nabla

  Try the following:

    [tac <muLJ>]- #define "nat x := (x=o);(sigma y\ (x=(s y),(nat y)))".
    Definition: inductive (nat x\ ((x = o); sigma y\ ((x = (s y)), nat y))).
    [tac <muLJ>]- #theorem my_theorem "pi x\ nat x => nat (s x)".

    --------------------------
    pi x\ (nat x => nat (s x))
    [tac <muLJ>]- pi_r.

    --------------------
    (nat x => nat (s x))

  Then you can type in "imp_r." to introduce the implication.
  Then, type "#undo." twice, and you should come back at the first step. Type
  "simplify." and the universal quantification as well as the implication will
  get introduced in one step. You can now unfold nat on the right ("mu_r"),
  choose the right of the disjunction ("right"), introduce the existential and
  split the conjunction ("then(sigma_r,and_r)"). You get two goals. You can
  finish the first one using "eq_r", the second one using "axiom".

  Exit using "#exit."

  You can find more definitions and proof scripts in "examples". The example
  files are no more than a sequence of taci inputs. They can be conveniently
  used from the graphical interfaces, which allow loading/saving and
  undo/redo in a more natural way.
  
  Keep in mind other general difficulties of our approach, that are
  sometimes visible in our current implementation:

  * Taci works at the very low level of sequent calculus rules. This can often 
    be hidden by using compound tactics like simplify, async or prove. But 
    sometimes, you might have to do some low-level work by hand.
    The good side of this is that taci actually builds a sequent calculus
    proof from your input, providing a witness for the success.
   
  * Most other issues have disappeared, hopefully. But don't hesitate
    to report bugs and oddities if you see any: this is still a beta version.

IV. Using lifting in taci
==============================

The "abstract" tactic implements lifting. It still has a few unfriendly
issues:

 * Lifting is not automatically done as in the theoretical presentation of the 
   logic. It has to be done explicitely by calling the tactic "abstract".
   It is, however, done implicitly by the "prove" and "apply" tactics.

 * The lift_* predicate names do not exist: these names are displayed for 
   convenience, but you can't type them in. The system would understand that as 
   an atom. If you want to refer to a lifted version of a predicate, type in 
   some nabla quantifications, and abstract the result explicitly.

 * The lift_* predicate names matter, in that equality of fixed points (on 
   which the initial rule is built) relies on names and does not compare the 
   fixed points' bodies. It's the users' duty to not introduce a predicate that 
   would conflict with these.

IV. Commented list of examples
==============================

 * examples/ho_simple.muLJ.tac:
     Simple examples to get used to the system. One might at first be surprised
     by the invariants used there, but they eventually make sense. Better: they 
     are automatically generated by the "prove" tactic, which is not specially 
     designed for nabla but makes use of general techniques for fixed points.

 * examples/copy.muLJ.tac:
     A simple striking example, where the induction is used to establish an 
     unusual property of the generic context in that case: two variables can be 
     merged. This leads to a very concise proof.

 * examples/lift-oddity.muLJ.tac:
     The unfortunate aspect of the lifting approach: it does not commute with 
     unfolding. This means that the correspondency between the original and the
     abstracted-out nabla is only up-to name re-ordering -- which is logically 
     sound.

 * examples/lambda/lemmas.muLJ.tac:
     Some lemmas about simply typed lambda calculus, as specified in 
     examples/lambda/definitions.def. They are mostly automatically proved.
     Notice here that not only are the simple weakening/strengthening lemmas
     automatically derived, their enriched version (bind_ww, bind_www) are
     also easily proved automatically.

 * examples/lambda/typedet.muLJ.tac:
     A proof of type determinacy for the "traditional" specification of simply 
     typed lambda calculus found in examples/lambda/definitions.def.
     It makes use of an unusual strong invariant.

 * examples/lambda/subred.muLJ.tac:
     Subject reduction for simply typed lambda calculus as specified in 
     examples/lambda/definitions.defs.

 * examples/lambda/named-style-failure.muLJ.tac:
     Proofs of type determinacy and almost subject reduction for an alternative 
     specification of simply typed lambda calculus. This is an experiment with 
     an unusual style, which mostly shows its weaknesses for now.

 * examples/popl/poplmark1a.muLJ.tac, examples/popl/poplmark2a.muLJ.tac:
     Almost complete proofs of PoplMark Challenge problems 1A and 2A; the few
     remaining holes (visible as applications of the "admit" tactical) should
     be viewed as gaps in the set of primitive tacticals for working with
     generic quantification.
